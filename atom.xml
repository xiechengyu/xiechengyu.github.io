<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
  <id>https://xiechengyu.github.io/</id>
  <title>xiechengyu的博客</title>
  <subtitle>welcome</subtitle>
  <author>
    <name>xiechengyu</name>
  </author>
  <updated>2023-09-22T06:25:43.472Z</updated>
  <generator>@mr-hope/vuepress-plugin-feed</generator>
  <link rel="self" href="https://xiechengyu.github.io/atom.xml"/>
  <link rel="alternate" href="https://xiechengyu.github.io/"/>
  <rights>Copyright © 2018 xiechengyu</rights>
  <category term="笔记"/>
  <category term="前端"/>
  <category term="面试"/>
  <category term="学习"/>
  <category term="转载"/>
  <contributor>
    <name>xiechengyu</name>
  </contributor>
  <entry>
    <title type="html">swiper的配置</title>
    <id>https://xiechengyu.github.io/2019/05/26/swiper%E7%9A%84%E9%85%8D%E7%BD%AE/</id>
    <link href="https://xiechengyu.github.io/2019/05/26/swiper%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <updated>2022-02-09T03:21:27.000Z</updated>
    <summary type="html"><![CDATA[<p>跳转地址</p>
]]></summary>
    <content type="html"><![CDATA[<p>跳转地址
</p>
]]></content>
    <author>
      <name>xiechengyu</name>
    </author>
    <category term="笔记"/>
    <contributor>
      <name>xiechengyu</name>
    </contributor>
    <published>2019-05-26T20:48:17.000Z</published>
    <rights>Copyright by xiechengyu</rights>
  </entry>
  <entry>
    <title type="html">npm私有仓库使用文档</title>
    <id>https://xiechengyu.github.io/front/npm%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/</id>
    <link href="https://xiechengyu.github.io/front/npm%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/"/>
    <updated>2023-03-15T09:21:35.000Z</updated>
    <summary type="html"><![CDATA[<h1 id="前言"> 前言</h1>
<p>私有 npm 仓库可以让我们使用包就像 npm 官方仓库里的包一样方便。</p>
]]></summary>
    <content type="html"><![CDATA[<h1 id="前言"> 前言</h1>
<p>私有 npm 仓库可以让我们使用包就像 npm 官方仓库里的包一样方便。</p>

<h2 id="为什么搭建npm私有仓库"> 为什么搭建npm私有仓库：</h2>
<ul>
<li>
<p>可以将公共方法库和公共组件库进行统一的版本管理；</p>
</li>
<li>
<p>私有包托管在内部服务器或者单独的服务器上，可以防止不必要的业务代码泄露；</p>
</li>
<li>
<p>可以同步整个官方仓库，也可以只同步需要的；</p>
</li>
<li>
<p>下载的时候，可以让公共包走公共仓库，私有包走私有仓库；</p>
</li>
<li>
<p>可以缓存下载过的包；</p>
</li>
<li>
<p>对于下载，发布，有对应的权限管理；</p>
</li>
</ul>
<h1 id="使用流程"> 使用流程</h1>
<h2 id="安装开发环境"> 安装开发环境</h2>
<p>node、npm</p>
<h2 id="将npm的registry连至公司npm私有仓库"> 将npm的registry连至公司npm私有仓库</h2>
<p>在命令行中输入</p>
<p>npm config set registry url</p>
<h2 id="使用"> 使用</h2>
<p>正常通过 npm install 下载资源</p>
<h1 id="发布流程"> 发布流程</h1>
<h2 id="注册npm私有仓库账号"> 注册npm私有仓库账号</h2>
<p>1、输入 npm adduser</p>
<p>2、依次输入username，password，email</p>
<p>注册后无需重复注册</p>
<h2 id="登录npm私有仓库"> 登录npm私有仓库</h2>
<p>1、输入 npm login</p>
<p>2、依次输入username，password，email</p>
<h2 id="发布包"> 发布包</h2>
<p>1、进入打包完成的仓库，修改package.json对应版本信息</p>
<p>2、输入 npm publish</p>
<h1 id="查询方式"> 查询方式</h1>
<p>可以进入 url 查询已上传过的包</p>
]]></content>
    <author>
      <name>xiechengyu</name>
    </author>
    <category term="前端"/>
    <contributor>
      <name>xiechengyu</name>
    </contributor>
    <published>2019-06-05T11:36:17.000Z</published>
    <rights>Copyright by xiechengyu</rights>
  </entry>
  <entry>
    <title type="html">前端知识框架</title>
    <id>https://xiechengyu.github.io/front/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/</id>
    <link href="https://xiechengyu.github.io/front/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/"/>
    <updated>2022-02-08T07:39:18.000Z</updated>
    <summary type="html"><![CDATA[<h1 id="前言"> 前言</h1>
<p>我最近在看一个叫做重学前端的专栏，有一些心得体会如下。</p>
]]></summary>
    <content type="html"><![CDATA[<h1 id="前言"> 前言</h1>
<p>我最近在看一个叫做重学前端的专栏，有一些心得体会如下。</p>

<p>在这个专栏中第一个让我印象深刻的点就是要建立稳增的起那段知识的框架。</p>
<p>前端的知识在总体上分成基础部分和实践部分，基础部分包含了 JavaScript 语言（模块一）、CSS 和 HTML（模块二）以及浏览器的实现原理和 API（模块三），这三个模块涵盖了一个前端工程师所需要掌握的全部知识。实践部分（模块四）是工作过程中遇到的问题和解决方案。</p>
<h2 id="javascript"> JavaScript</h2>
<p><img src="https://static001.geekbang.org/resource/image/6a/9b/6aec0a09381a2f74014ec604ef99c19b.png" alt="img" loading="lazy"></p>
<p>在 JavaScript 的模块中，首先我们可以把语言按照文法、语义和运行时来拆分，这符合编程语言的一般规律：<strong>用一定的词法和语法，表达一定语义，从而操作运行时。</strong></p>
<p>接下来，我们又按照程序的一般规律，把运行时分为数据结构和算法部分：数据结构包含类型和实例（JavaScript 的类型系统就是它的 7 种基本类型和 7 种语言类型，实例就是它的内置对象部分）。所谓的算法，就是 JavaScript 的执行过程。</p>
<p>类型部分中，对象比其它所有类型加起来都要更为复杂，所以我们会用较长的篇幅来讲解对象，包括它的一些历史和设计思路。</p>
<p>执行过程我们则需要按照从大结构到小结构的角度讲解，从最顶层的程序与模块、事件循环和微任务，到函数、再到语句级的执行。我们从粗到细地了解执行过程。</p>
<p>实例部分，对 JavaScript 来说类似基础库，JavaScipt 的内置对象多达 150 以上，考虑到我们即使逐次讲解也必定不如 MDN 更加细致全面，所以我们会从应用和机制的角度，挑选其中几个体系来讲解。</p>
<p>文法中的语法和语义基本是一一对应关系，在 JavaScript 标准中有一份语法定义表，它同样不适合一一讲解，我们会从 JavaScript 语法中特别的地方，以及与日常开发比较相关的地方来重点讲解，剩下的内容和词法部分，我们会带领大家做一些数据挖掘工作，从这份表格中找到一些和我们日常开发息息相关的内容。</p>
<p>语义的大部分内容我们会在运行时的讲解中透出，同时它又跟语法有对应的关系，所以我们不再单独拿出来讲解。</p>
<h2 id="html-和-css"> HTML 和 CSS</h2>
<p><img src="https://static001.geekbang.org/resource/image/41/62/4153891927afac7f4c21ccf6a141f062.png" alt="img" loading="lazy"></p>
<p><strong>在 HTML 的部分</strong>，我们会按照功能和语言来划分它的知识，HTML 的功能主要由标签来承担，所以我们首先会把标签做一些分类，并对它们分别进行讲解。</p>
<p>我们都知道 HTML 的标签可以分为很多种，head 里面的我们称为元信息类标签，诸如 title、meta、style、link、base 这些，它们用来描述文档的一些基本信息。还有一类是一些诸如 section、nav 的标签，它们在视觉表现上跟 div 并没有区别，但是各有各的适用场景，我们把它们称作语义类标签。另外一类是 img、video、audio 之类的替换型媒体类标签，用来引入外部内容，平常开发中你也会经常用到。再有就是表单类的，比如 input、button。</p>
<p>所以，基于这样的分类，我把标签分成下面几种。</p>
<ol>
<li>文档元信息：通常是出现在 head 标签中的元素，包含了描述文档自身的一些信息；</li>
<li>语义相关：扩展了纯文本，表达文章结构、不同语言要素的标签；</li>
<li>链接：提供到文档内和文档外的链接；</li>
<li>替换型标签：引入声音、图片、视频等外部元素替换自身的一类标签；</li>
<li>表单：用于填写和提交信息的一类标签；</li>
<li>表格：表头、表尾、单元格等表格的结构。</li>
</ol>
<p>我们的重点会放在前四种标签上，表单和表格较少用到，而且基本以查阅型知识为主，这里就不拿出来讲解了。</p>
<p>除了标签之外，我们还应该把 HTML 当作一门语言来了解下，当然，标记语言跟编程语言不太一样，没有编程语言那么严谨，所以，我们会简要介绍 HTML 的语法和几个重要的语言机制：实体、命名空间。</p>
<p>最后我们会介绍下 HTML 的补充标准：ARIA，它是 HTML 的扩展，在可访问性领域，它有至关重要的作用。</p>
<p><strong>CSS 部分</strong>，按照惯例，我们也会从语言和功能两个角度去介绍。在语言部分，我们会从大到小介绍 CSS 的各种语法结构，比如 @rule、选择器、单位等等。功能部分，我们大致可以分为布局、绘制和交互类。</p>
<p>在布局类我们介绍两个最常用的布局：正常流和弹性布局。绘制类我们则会分成图形相关的和文字相关的绘制。最后我们会介绍动画和其它交互。</p>
<h2 id="浏览器的实现原理和-api"> 浏览器的实现原理和 API</h2>
<p><img src="https://static001.geekbang.org/resource/image/cb/cb/cbb6d198ccfb95af4906eeb0581333cb.png" alt="img" loading="lazy"></p>
<p>浏览器部分我们会先介绍下浏览器的实现原理，这是我们深入理解 API 的基础。</p>
<p>我们会从一般的浏览器设计出发，按照解析、构建 DOM 树、计算 CSS、渲染、合成和绘制的流程来讲解浏览器的工作原理。</p>
<p>在 API 部分，我们会从 W3C 零散的标准中挑选几个大块的 API 来详细讲解，主要有：事件、DOM、CSSOM 几个部分，它们分别覆盖了交互、语义和可见效果，这是我们工作中用到的主要内容。</p>
<h2 id="前端工程实践"> 前端工程实践</h2>
<p><img src="https://static001.geekbang.org/resource/image/45/ce/4568011037a5591402c4ba1547ba0dce.jpg" alt="img" loading="lazy"></p>
<h3 id="性能"> 性能</h3>
<p>对任何一个前端团队而言，性能是它价值的核心指标，从早年“重构”的实践开始，前端有通过性能证明自己价值的传统。</p>
<p>但是性能并非细节的堆砌，也不是默默做优化，所以，我会从团队的角度来跟你一起探讨性能的方法论和技术体系。</p>
<h3 id="工具链"> 工具链</h3>
<p>对一个高效又合作良好的前端团队来说，一致性的工具链是不可或缺的保障，作为开发阶段的入口，工具链又可以和性能、发布、持续集成等系统链接到一起，成为团队技术管理的基础。</p>
<h3 id="持续集成"> 持续集成</h3>
<p>持续集成并非一个新概念，但是过去持续集成概念和理论都主要针对软件开发，而对前端来说，持续集成是一个新的课题（当然对持续集成来说，前端也是一个新课题），比如 daily build 就完全不适用前端，前端代码必须是线上实时可用的。这一部分内容将会针对前端的持续集成提出一些建设的思路。</p>
<h3 id="搭建系统"> 搭建系统</h3>
<p>前端工作往往多而繁杂，针对高重复性、可模块化的业务需求，传统的人工开发不再适用，搭建系统是大部分大型前端团队的选择。这一部分内容我将会介绍什么是搭建系统，以及一些常见的搭建系统类型。</p>
<h3 id="架构与基础库"> 架构与基础库</h3>
<p>软件架构师主要解决功能复杂性的问题，服务端架构师主要解决高流量问题，而前端是页面间天然解耦，分散在用户端运行的系统，但是前端架构也有自己要解决的问题。</p>
<p>前端需求量大、专业人才稀缺，更因为前端本身运行在浏览器中，有大量兼容工作要做。所以前端架构的主要职责是兼容性、复用和能力扩展。</p>
<h2 id="结语"> 结语</h2>
<p>以上有部分是我个人的理解，还有一大部分来自于我对原文的摘抄，原文来自极客时间的重学前端专栏。</p>
]]></content>
    <author>
      <name>xiechengyu</name>
    </author>
    <category term="前端"/>
    <contributor>
      <name>xiechengyu</name>
    </contributor>
    <published>2019-06-05T11:36:17.000Z</published>
    <rights>Copyright by xiechengyu</rights>
  </entry>
  <entry>
    <title type="html">slick的配置</title>
    <id>https://xiechengyu.github.io/2019/05/29/sclick%E7%9A%84%E9%85%8D%E7%BD%AE/</id>
    <link href="https://xiechengyu.github.io/2019/05/29/sclick%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <updated>2022-02-09T03:21:27.000Z</updated>
    <summary type="html"><![CDATA[<p>跳转地址</p>
]]></summary>
    <content type="html"><![CDATA[<p>跳转地址
</p>
]]></content>
    <author>
      <name>xiechengyu</name>
    </author>
    <category term="笔记"/>
    <contributor>
      <name>xiechengyu</name>
    </contributor>
    <published>2019-05-29T09:35:17.000Z</published>
    <rights>Copyright by xiechengyu</rights>
  </entry>
  <entry>
    <title type="html">自制画板</title>
    <id>https://xiechengyu.github.io/front/%E8%87%AA%E5%88%B6%E7%94%BB%E6%9D%BF/</id>
    <link href="https://xiechengyu.github.io/front/%E8%87%AA%E5%88%B6%E7%94%BB%E6%9D%BF/"/>
    <updated>2023-03-07T08:40:42.000Z</updated>
    <summary type="html"><![CDATA[<h2 id="前言"> 前言</h2>
<p>自己基于canvas制作了一个画板</p>
]]></summary>
    <content type="html"><![CDATA[<h2 id="前言"> 前言</h2>
<p>自己基于canvas制作了一个画板</p>

<iframe src="/assets/draw.html" width="900" height="900"></iframe>
]]></content>
    <author>
      <name>xiechengyu</name>
    </author>
    <category term="前端"/>
    <contributor>
      <name>xiechengyu</name>
    </contributor>
    <published>2022-01-12T16:14:33.000Z</published>
    <rights>Copyright by xiechengyu</rights>
  </entry>
  <entry>
    <title type="html">react面试题</title>
    <id>https://xiechengyu.github.io/interview/React%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <link href="https://xiechengyu.github.io/interview/React%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <updated>2022-02-08T07:39:18.000Z</updated>
    <summary type="html"><![CDATA[<h2 id="前言"> <strong>前言</strong></h2>
<p>在学习react过程中，通过查找一些资料，汇集了一份react面试题，以备参考。</p>
]]></summary>
    <content type="html"><![CDATA[<h2 id="前言"> <strong>前言</strong></h2>
<p>在学习react过程中，通过查找一些资料，汇集了一份react面试题，以备参考。</p>

<h3 id="_1-区分real-dom和virtual-dom"> <strong>1. 区分Real DOM和Virtual DOM</strong></h3>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Real DOM</strong></th>
<th style="text-align:left"><strong>Virtual DOM</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1. 更新缓慢。</td>
<td style="text-align:left">1. 更新更快。</td>
</tr>
<tr>
<td style="text-align:left">2. 可以直接更新 HTML。</td>
<td style="text-align:left">2. 无法直接更新 HTML。</td>
</tr>
<tr>
<td style="text-align:left">3. 如果元素更新，则创建新DOM。</td>
<td style="text-align:left">3. 如果元素更新，则更新 JSX 。</td>
</tr>
<tr>
<td style="text-align:left">4. DOM操作代价很高。</td>
<td style="text-align:left">4. DOM 操作非常简单。</td>
</tr>
<tr>
<td style="text-align:left">5. 消耗的内存较多。</td>
<td style="text-align:left">5. 很少的内存消耗。</td>
</tr>
</tbody>
</table>
<h3 id="_2-什么是react"> <strong>2. 什么是React？</strong></h3>
<ul>
<li>React 是 Facebook 在 2011 年开发的前端 JavaScript 库。</li>
<li>它遵循基于组件的方法，有助于构建可重用的UI组件。</li>
<li>它用于开发复杂和交互式的 Web 和移动 UI。</li>
<li>尽管它仅在 2015 年开源，但有一个很大的支持社区。</li>
</ul>
<h3 id="_3-react有什么特点"> <strong>3. React有什么特点？</strong></h3>
<p>React的主要功能如下：</p>
<ol>
<li>它使用<strong>虚拟DOM</strong> 而不是真正的DOM。</li>
<li>它可以进行<strong>服务器端渲染</strong>。</li>
<li>它遵循<strong>单向数据流</strong>或数据绑定。</li>
</ol>
<h3 id="_4-列出react的一些主要优点。"> <strong>4. 列出React的一些主要优点。</strong></h3>
<p>React的一些主要优点是：</p>
<ol>
<li>它提高了应用的性能</li>
<li>可以方便地在客户端和服务器端使用</li>
<li>由于 JSX，代码的可读性很好</li>
<li>React 很容易与 Meteor，Angular 等其他框架集成</li>
<li>使用React，编写UI测试用例变得非常容易</li>
</ol>
<h3 id="_5-react有哪些限制"> <strong>5. React有哪些限制？</strong></h3>
<p>React的限制如下：</p>
<ol>
<li>React 只是一个库，而不是一个完整的框架</li>
<li>它的库非常庞大，需要时间来理解</li>
<li>新手程序员可能很难理解</li>
<li>编码变得复杂，因为它使用内联模板和 JSX</li>
</ol>
<h3 id="_6-什么是jsx"> <strong>6. 什么是JSX？</strong></h3>
<p>JSX 是J avaScript XML 的简写。是 React 使用的一种文件，它利用 JavaScript 的表现力和类似 HTML 的模板语法。这使得 HTML 文件非常容易理解。此文件能使应用非常可靠，并能够提高其性能。下面是JSX的一个例子：</p>
<div><pre><code><span>render</span><span>(</span><span>)</span><span>{</span>
    <span>return</span><span>(</span>        
        <span>&lt;</span>div<span>></span>
            <span>&lt;</span>h1<span>></span> Hello World from Edureka<span>!</span><span>!</span><span>&lt;</span><span>/</span>h1<span>></span>
        <span>&lt;</span><span>/</span>div<span>></span>
    <span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="_7-你了解-virtual-dom-吗-解释一下它的工作原理。"> <strong>7. 你了解 Virtual DOM 吗？解释一下它的工作原理。</strong></h3>
<p>Virtual DOM 是一个轻量级的 JavaScript 对象，它最初只是 real DOM 的副本。它是一个节点树，它将元素、它们的属性和内容作为对象及其属性。 React 的渲染函数从 React 组件中创建一个节点树。然后它响应数据模型中的变化来更新该树，该变化是由用户或系统完成的各种动作引起的。</p>
<p>Virtual DOM 工作过程有三个简单的步骤。</p>
<ol>
<li>每当底层数据发生改变时，整个 UI 都将在 Virtual DOM 描述中重新渲染。</li>
</ol>
<p><img src="https://segmentfault.com/img/bVbqdVC?w=1363&amp;h=499" alt="clipboard.png" loading="lazy"></p>
<ol>
<li>然后计算之前 DOM 表示与新表示的之间的差异。</li>
</ol>
<p><img src="https://segmentfault.com/img/bVbqdVw?w=1079&amp;h=452" alt="clipboard.png" loading="lazy"></p>
<ol>
<li>完成计算后，将只用实际更改的内容更新 real DOM。</li>
</ol>
<p><img src="https://segmentfault.com/img/bVbqdVr?w=531&amp;h=457" alt="clipboard.png" loading="lazy"></p>
<h3 id="_8-为什么浏览器无法读取jsx"> <strong>8. 为什么浏览器无法读取JSX？</strong></h3>
<p>浏览器只能处理 JavaScript 对象，而不能读取常规 JavaScript 对象中的 JSX。所以为了使浏览器能够读取 JSX，首先，需要用像 Babel 这样的 JSX 转换器将 JSX 文件转换为 JavaScript 对象，然后再将其传给浏览器。</p>
<h3 id="_9-与-es5-相比-react-的-es6-语法有何不同"> <strong>9. 与 ES5 相比，React 的 ES6 语法有何不同？</strong></h3>
<p>以下语法是 ES5 与 ES6 中的区别：</p>
<p>1.require 与 import</p>
<div><pre><code>// ES5
var React = require(&#39;react&#39;);
 
// ES6
import React from &#39;react&#39;;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>2.export 与 exports</p>
<div><pre><code>// ES5
module.exports = Component;
 
// ES6
export default Component;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>3.component 和 function</p>
<div><pre><code>// ES5
var MyComponent = React.createClass({
    render: function() {
        return
            &lt;h3&gt;Hello Edureka!&lt;/h3&gt;;
    }
});
 
// ES6
class MyComponent extends React.Component {
    render() {
        return
            &lt;h3&gt;Hello Edureka!&lt;/h3&gt;;
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>4.props</p>
<div><pre><code>// ES5
var App = React.createClass({
    propTypes: { name: React.PropTypes.string },
    render: function() {
        return
            &lt;h3&gt;Hello, {this.props.name}!&lt;/h3&gt;;
    }
});

// ES6
class App extends React.Component {
    render() {
        return
            &lt;h3&gt;Hello, {this.props.name}!&lt;/h3&gt;;
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>5.state</p>
<div><pre><code>// ES5
var App = React.createClass({
    getInitialState: function() {
        return { name: &#39;world&#39; };
    },
    render: function() {
        return
            &lt;h3&gt;Hello, {this.state.name}!&lt;/h3&gt;;
    }
});

// ES6
class App extends React.Component {
    constructor() {
        super();
        this.state = { name: &#39;world&#39; };
    }
    render() {
        return
            &lt;h3&gt;Hello, {this.state.name}!&lt;/h3&gt;;
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h3 id="_10-react与angular有何不同"> <strong>10. React与Angular有何不同？</strong></h3>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>主题</strong></th>
<th style="text-align:left"><strong>React</strong></th>
<th style="text-align:left"><strong>Angular</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><em>1. 体系结构</em></td>
<td style="text-align:left">只有 MVC 中的 View</td>
<td style="text-align:left">完整的 MVC</td>
</tr>
<tr>
<td style="text-align:left"><em>2. 渲染</em></td>
<td style="text-align:left">可以进行服务器端渲染</td>
<td style="text-align:left">客户端渲染</td>
</tr>
<tr>
<td style="text-align:left"><em>3. DOM</em></td>
<td style="text-align:left">使用 virtual DOM</td>
<td style="text-align:left">使用 real DOM</td>
</tr>
<tr>
<td style="text-align:left"><em>4. 数据绑定</em></td>
<td style="text-align:left">单向数据绑定</td>
<td style="text-align:left">双向数据绑定</td>
</tr>
<tr>
<td style="text-align:left"><em>5. 调试</em></td>
<td style="text-align:left">编译时调试</td>
<td style="text-align:left">运行时调试</td>
</tr>
<tr>
<td style="text-align:left"><em>6. 作者</em></td>
<td style="text-align:left">Facebook</td>
<td style="text-align:left">Google</td>
</tr>
</tbody>
</table>
<h2 id="react-组件"> <strong>React 组件</strong></h2>
<h3 id="_11-你怎样理解-在react中-一切都是组件-这句话。"> <strong>11. 你怎样理解“在React中，一切都是组件”这句话。</strong></h3>
<p>组件是 React 应用 UI 的构建块。这些组件将整个 UI 分成小的独立并可重用的部分。每个组件彼此独立，而不会影响 UI 的其余部分。</p>
<h3 id="_12-怎样解释-react-中-render-的目的。"> <strong>12. 怎样解释 React 中 render() 的目的。</strong></h3>
<p>每个React组件强制要求必须有一个 <strong>render()</strong>。它返回一个 React 元素，是原生 DOM 组件的表示。如果需要渲染多个 HTML 元素，则必须将它们组合在一个封闭标记内，例如 <code>&lt;form&gt;</code>、<code>&lt;group&gt;</code>、<code>&lt;div&gt;</code> 等。此函数必须保持纯净，即必须每次调用时都返回相同的结果。</p>
<h3 id="_13-如何将两个或多个组件嵌入到一个组件中"> <strong>13. 如何将两个或多个组件嵌入到一个组件中？</strong></h3>
<p>可以通过以下方式将组件嵌入到一个组件中：</p>
<div><pre><code>class MyComponent extends React.Component{
    render(){
        return(          
            &lt;div&gt;
                &lt;h1&gt;Hello&lt;/h1&gt;
                &lt;Header/&gt;
            &lt;/div&gt;
        );
    }
}
class Header extends React.Component{
    render(){
        return
            &lt;h1&gt;Header Component&lt;/h1&gt;   
   };
}
ReactDOM.render(
    &lt;MyComponent/&gt;, document.getElementById(&#39;content&#39;)
);
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3 id="_14-什么是-props"> <strong>14. 什么是 Props?</strong></h3>
<p>Props 是 React 中属性的简写。它们是只读组件，必须保持纯，即不可变。它们总是在整个应用中从父组件传递到子组件。子组件永远不能将 prop 送回父组件。这有助于维护单向数据流，通常用于呈现动态生成的数据。</p>
<h3 id="_15-react中的状态是什么-它是如何使用的"> <strong>15. React中的状态是什么？它是如何使用的？</strong></h3>
<p>状态是 React 组件的核心，是数据的来源，必须尽可能简单。基本上状态是确定组件呈现和行为的对象。与props 不同，它们是可变的，并创建动态和交互式组件。可以通过 <code>this.state()</code> 访问它们。</p>
<h3 id="_16-区分状态和-props"> <strong>16. 区分状态和 props</strong></h3>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>条件</strong></th>
<th style="text-align:left"><strong>State</strong></th>
<th style="text-align:left"><strong>Props</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1. 从父组件中接收初始值</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">2. 父组件可以改变值</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">3. 在组件中设置默认值</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">4. 在组件的内部变化</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">No</td>
</tr>
<tr>
<td style="text-align:left">5. 设置子组件的初始值</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">6. 在子组件的内部更改</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
</tbody>
</table>
<h3 id="_17-如何更新组件的状态"> <strong>17. 如何更新组件的状态？</strong></h3>
<p>可以用 <code>this.setState()</code>更新组件的状态。</p>
<div><pre><code>class MyComponent extends React.Component {
    constructor() {
        super();
        this.state = {
            name: &#39;Maxx&#39;,
            id: &#39;101&#39;
        }
    }
    render()
        {
            setTimeout(()=&gt;{this.setState({name:&#39;Jaeha&#39;, id:&#39;222&#39;})},2000)
            return (              
                &lt;div&gt;
                    &lt;h1&gt;Hello {this.state.name}&lt;/h1&gt;
                    &lt;h2&gt;Your Id is {this.state.id}&lt;/h2&gt;
                &lt;/div&gt;
            );
        }
    }
ReactDOM.render(
    &lt;MyComponent/&gt;, document.getElementById(&#39;content&#39;)
);
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h3 id="_18-react-中的箭头函数是什么-怎么用"> <strong>18. React 中的箭头函数是什么？怎么用？</strong></h3>
<p>箭头函数（<strong>=&gt;</strong>）是用于编写函数表达式的简短语法。这些函数允许正确绑定组件的上下文，因为在 ES6 中默认下不能使用自动绑定。使用高阶函数时，箭头函数非常有用。</p>
<div><pre><code>//General way
render() {    
    return(
        &lt;MyInput onChange = {this.handleChange.bind(this) } /&gt;
    );
}
//With Arrow Function
render() {  
    return(
        &lt;MyInput onChange = { (e)=&gt;this.handleOnChange(e) } /&gt;
    );
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="_19-区分有状态和无状态组件。"> <strong>19. 区分有状态和无状态组件。</strong></h3>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>有状态组件</strong></th>
<th style="text-align:left"><strong>无状态组件</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1. 在内存中存储有关组件状态变化的信息</td>
<td style="text-align:left">1. 计算组件的内部的状态</td>
</tr>
<tr>
<td style="text-align:left">2. 有权改变状态</td>
<td style="text-align:left">2. 无权改变状态</td>
</tr>
<tr>
<td style="text-align:left">3. 包含过去、现在和未来可能的状态变化情况</td>
<td style="text-align:left">3. 不包含过去，现在和未来可能发生的状态变化情况</td>
</tr>
<tr>
<td style="text-align:left">4. 接受无状态组件状态变化要求的通知，然后将 props 发送给他们。</td>
<td style="text-align:left">4.从有状态组件接收 props 并将其视为回调函数。</td>
</tr>
</tbody>
</table>
<h3 id="_20-react组件生命周期的阶段是什么"> <strong>20. React组件生命周期的阶段是什么？</strong></h3>
<p>React 组件的生命周期有三个不同的阶段：</p>
<ol>
<li>*初始渲染阶段：*这是组件即将开始其生命之旅并进入 DOM 的阶段。</li>
<li>*更新阶段：*一旦组件被添加到 DOM，它只有在 prop 或状态发生变化时才可能更新和重新渲染。这些只发生在这个阶段。</li>
<li>*卸载阶段：*这是组件生命周期的最后阶段，组件被销毁并从 DOM 中删除。</li>
</ol>
<h3 id="_21-详细解释-react-组件的生命周期方法。"> <strong>21. 详细解释 React 组件的生命周期方法。</strong></h3>
<p>一些最重要的生命周期方法是：</p>
<ol>
<li><strong>componentWillMount</strong>**()** – 在渲染之前执行，在客户端和服务器端都会执行。</li>
<li><strong>componentDidMount</strong>**()** – 仅在第一次渲染后在客户端执行。</li>
<li><strong>componentWillReceiveProps</strong>**()** – 当从父类接收到 props 并且在调用另一个渲染器之前调用。</li>
<li><strong>shouldComponentUpdate</strong>**()** – 根据特定条件返回 true 或 false。如果你希望更新组件，请返回<strong>true</strong> 否则返回 <strong>false</strong>。默认情况下，它返回 false。</li>
<li><strong>componentWillUpdate</strong>**()** – 在 DOM 中进行渲染之前调用。</li>
<li><strong>componentDidUpdate</strong>**()** – 在渲染发生后立即调用。</li>
<li><strong>componentWillUnmount</strong>**()** – 从 DOM 卸载组件后调用。用于清理内存空间。</li>
</ol>
<h3 id="_22-react中的事件是什么"> <strong>22. React中的事件是什么？</strong></h3>
<p>在 React 中，事件是对鼠标悬停、鼠标单击、按键等特定操作的触发反应。处理这些事件类似于处理 DOM 元素中的事件。但是有一些语法差异，如：</p>
<ol>
<li>用驼峰命名法对事件命名而不是仅使用小写字母。</li>
<li>事件作为函数而不是字符串传递。</li>
</ol>
<p>事件参数重包含一组特定于事件的属性。每个事件类型都包含自己的属性和行为，只能通过其事件处理程序访问。</p>
<h3 id="_23-如何在react中创建一个事件"> <strong>23. 如何在React中创建一个事件？</strong></h3>
<div><pre><code>class Display extends React.Component({    
    show(evt) {
        // code   
    },   
    render() {      
        // Render the div with an onClick prop (value is a function)        
        return (            
            &lt;div onClick={this.show}&gt;Click Me!&lt;/div&gt;
        );    
    }
});
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="_24-react中的合成事件是什么"> <strong>24. React中的合成事件是什么？</strong></h3>
<p>合成事件是围绕浏览器原生事件充当跨浏览器包装器的对象。它们将不同浏览器的行为合并为一个 API。这样做是为了确保事件在不同浏览器中显示一致的属性。</p>
<h3 id="_25-你对-react-的-refs-有什么了解"> <strong>25. 你对 React 的 refs 有什么了解？</strong></h3>
<p>Refs 是 React 中引用的简写。它是一个有助于存储对特定的 React 元素或组件的引用的属性，它将由组件渲染配置函数返回。用于对 render() 返回的特定元素或组件的引用。当需要进行 DOM 测量或向组件添加方法时，它们会派上用场。</p>
<div><pre><code>class ReferenceDemo extends React.Component{
     display() {
         const name = this.inputDemo.value;
         document.getElementById(&#39;disp&#39;).innerHTML = name;
     }
render() {
    return(        
          &lt;div&gt;
            Name: &lt;input type=&quot;text&quot; ref={input =&gt; this.inputDemo = input} /&gt;
            &lt;button name=&quot;Click&quot; onClick={this.display}&gt;Click&lt;/button&gt;            
            &lt;h2&gt;Hello &lt;span id=&quot;disp&quot;&gt;&lt;/span&gt; !!!&lt;/h2&gt;
          &lt;/div&gt;
    );
   }
 }
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="_26-列出一些应该使用-refs-的情况。"> <strong>26. 列出一些应该使用 Refs 的情况。</strong></h3>
<p>以下是应该使用 refs 的情况：</p>
<ul>
<li>需要管理焦点、选择文本或媒体播放时</li>
<li>触发式动画</li>
<li>与第三方 DOM 库集成</li>
</ul>
<h3 id="_27-如何模块化-react-中的代码"> <strong>27. 如何模块化 React 中的代码？</strong></h3>
<p>可以使用 export 和 import 属性来模块化代码。它们有助于在不同的文件中单独编写组件。</p>
<div><pre><code>//ChildComponent.jsx
export default class ChildComponent extends React.Component {
    render() {
        return(           
              &lt;div&gt;
                  &lt;h1&gt;This is a child component&lt;/h1&gt;
              &lt;/div&gt;
        );
    }
}
 
//ParentComponent.jsx
import ChildComponent from &#39;./childcomponent.js&#39;;
class ParentComponent extends React.Component {    
    render() {        
        return(           
             &lt;div&gt;               
                &lt;App /&gt;          
             &lt;/div&gt;       
        );  
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h3 id="_28-如何在-react-中创建表单"> <strong>28. 如何在 React 中创建表单</strong></h3>
<p>React 表单类似于 HTML 表单。但是在 React 中，状态包含在组件的 state 属性中，并且只能通过 <code>setState()</code> 更新。因此元素不能直接更新它们的状态，它们的提交是由 JavaScript 函数处理的。此函数可以完全访问用户输入到表单的数据。</p>
<div><pre><code>handleSubmit(event) {
    alert(&#39;A name was submitted: &#39; + this.state.value);
    event.preventDefault();
}
 
render() {
    return (        
        &lt;form onSubmit={this.handleSubmit}&gt;
            &lt;label&gt;
                Name:
                &lt;input type=&quot;text&quot; value={this.state.value} onChange={this.handleSubmit} /&gt;
            &lt;/label&gt;
            &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;
        &lt;/form&gt;
    );
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="_29-你对受控组件和非受控组件了解多少"> <strong>29. 你对受控组件和非受控组件了解多少？</strong></h3>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>受控组件</strong></th>
<th style="text-align:left"><strong>非受控组件</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1. 没有维持自己的状态</td>
<td style="text-align:left">1. 保持着自己的状态</td>
</tr>
<tr>
<td style="text-align:left">2.数据由父组件控制</td>
<td style="text-align:left">2.数据由 DOM 控制</td>
</tr>
<tr>
<td style="text-align:left">3. 通过 props 获取当前值，然后通过回调通知更改</td>
<td style="text-align:left">3. Refs 用于获取其当前值</td>
</tr>
</tbody>
</table>
<h3 id="_30-什么是高阶组件-hoc"> <strong>30. 什么是高阶组件（HOC）？</strong></h3>
<p>高阶组件是重用组件逻辑的高级方法，是一种源于 React 的组件模式。 HOC 是自定义组件，在它之内包含另一个组件。它们可以接受子组件提供的任何动态，但不会修改或复制其输入组件中的任何行为。你可以认为 HOC 是“纯（Pure）”组件。</p>
<h3 id="_31-你能用hoc做什么"> <strong>31. 你能用HOC做什么？</strong></h3>
<p>HOC可用于许多任务，例如：</p>
<ul>
<li>代码重用，逻辑和引导抽象</li>
<li>渲染劫持</li>
<li>状态抽象和控制</li>
<li>Props 控制</li>
</ul>
<h3 id="_32-什么是纯组件"> <strong>32. 什么是纯组件？</strong></h3>
<p><em>纯（Pure）</em> 组件是可以编写的最简单、最快的组件。它们可以替换任何只有 <strong>render()</strong> 的组件。这些组件增强了代码的简单性和应用的性能。</p>
<h3 id="_33-react-中-key-的重要性是什么"> <strong>33. React 中 key 的重要性是什么？</strong></h3>
<p>key 用于识别唯一的 Virtual DOM 元素及其驱动 UI 的相应数据。它们通过回收 DOM 中当前所有的元素来帮助 React 优化渲染。这些 key 必须是唯一的数字或字符串，React 只是重新排序元素而不是重新渲染它们。这可以提高应用程序的性能。</p>
<h2 id="react-redux"> <strong>React Redux</strong></h2>
<h3 id="_34-mvc框架的主要问题是什么"> <strong>34. MVC框架的主要问题是什么？</strong></h3>
<p>以下是MVC框架的一些主要问题：</p>
<ul>
<li>对 DOM 操作的代价非常高</li>
<li>程序运行缓慢且效率低下</li>
<li>内存浪费严重</li>
<li>由于循环依赖性，组件模型需要围绕 models 和 views 进行创建</li>
</ul>
<h3 id="_35-解释一下-flux"> <strong>35. 解释一下 Flux</strong></h3>
<p><img src="https://segmentfault.com/img/bVbqdVk?w=796&amp;h=262" alt="clipboard.png" loading="lazy"></p>
<p>Flux 是一种强制单向数据流的架构模式。它控制派生数据，并使用具有所有数据权限的中心 store 实现多个组件之间的通信。整个应用中的数据更新必须只能在此处进行。 Flux 为应用提供稳定性并减少运行时的错误。</p>
<h3 id="_36-什么是redux"> <strong>36. 什么是Redux？</strong></h3>
<p>Redux 是当今最热门的前端开发库之一。它是 JavaScript 程序的可预测状态容器，用于整个应用的状态管理。使用 Redux 开发的应用易于测试，可以在不同环境中运行，并显示一致的行为。</p>
<h3 id="_37-redux遵循的三个原则是什么"> <strong>37. Redux遵循的三个原则是什么？</strong></h3>
<ol>
<li>**单一事实来源：**整个应用的状态存储在单个 store 中的对象/状态树里。单一状态树可以更容易地跟踪随时间的变化，并调试或检查应用程序。</li>
<li>**状态是只读的：**改变状态的唯一方法是去触发一个动作。动作是描述变化的普通 JS 对象。就像 state 是数据的最小表示一样，该操作是对数据更改的最小表示。</li>
<li>**使用纯函数进行更改：**为了指定状态树如何通过操作进行转换，你需要纯函数。纯函数是那些返回值仅取决于其参数值的函数。</li>
</ol>
<p><img src="https://segmentfault.com/img/bVbqdU5?w=515&amp;h=485" alt="clipboard.png" loading="lazy"></p>
<h3 id="_38-你对-单一事实来源-有什么理解"> <strong>38. 你对“单一事实来源”有什么理解？</strong></h3>
<p>Redux 使用 “Store” 将程序的整个状态存储在同一个地方。因此所有组件的状态都存储在 Store 中，并且它们从 Store 本身接收更新。单一状态树可以更容易地跟踪随时间的变化，并调试或检查程序。</p>
<h3 id="_39-列出-redux-的组件。"> <strong>39. 列出 Redux 的组件。</strong></h3>
<p>Redux 由以下组件组成：</p>
<ol>
<li><strong>Action</strong> – 这是一个用来描述发生了什么事情的对象。</li>
<li><strong>Reducer</strong> – 这是一个确定状态将如何变化的地方。</li>
<li><strong>Store</strong> – 整个程序的状态/对象树保存在Store中。</li>
<li><strong>View</strong> – 只显示 Store 提供的数据。</li>
</ol>
<h3 id="_40-数据如何通过-redux-流动"> <strong>40. 数据如何通过 Redux 流动？</strong></h3>
<p><img src="https://segmentfault.com/img/bVbqdVh?w=1292&amp;h=560" alt="clipboard.png" loading="lazy"></p>
<h3 id="_41-如何在-redux-中定义-action"> <strong>41. 如何在 Redux 中定义 Action？</strong></h3>
<p>React 中的 Action 必须具有 type 属性，该属性指示正在执行的 ACTION 的类型。必须将它们定义为字符串常量，并且还可以向其添加更多的属性。在 Redux 中，action 被名为 Action Creators 的函数所创建。以下是 Action 和Action Creator 的示例：</p>
<div><pre><code>function addTodo(text) {
       return {
                type: ADD_TODO,    
                 text
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="_42-解释-reducer-的作用。"> <strong>42. 解释 Reducer 的作用。</strong></h3>
<p>Reducers 是纯函数，它规定应用程序的状态怎样因响应 ACTION 而改变。Reducers 通过接受先前的状态和 action 来工作，然后它返回一个新的状态。它根据操作的类型确定需要执行哪种更新，然后返回新的值。如果不需要完成任务，它会返回原来的状态。</p>
<h3 id="_43-store-在-redux-中的意义是什么"> <strong>43. Store 在 Redux 中的意义是什么？</strong></h3>
<p>Store 是一个 JavaScript 对象，它可以保存程序的状态，并提供一些方法来访问状态、调度操作和注册侦听器。应用程序的整个状态/对象树保存在单一存储中。因此，Redux 非常简单且是可预测的。我们可以将中间件传递到 store 来处理数据，并记录改变存储状态的各种操作。所有操作都通过 reducer 返回一个新状态。</p>
<h3 id="_44-redux与flux有何不同"> <strong>44. Redux与Flux有何不同？</strong></h3>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Flux</strong></th>
<th style="text-align:left"><strong>Redux</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1. Store 包含状态和更改逻辑</td>
<td style="text-align:left">1. Store 和更改逻辑是分开的</td>
</tr>
<tr>
<td style="text-align:left">2. 有多个 Store</td>
<td style="text-align:left">2. 只有一个 Store</td>
</tr>
<tr>
<td style="text-align:left">3. 所有 Store 都互不影响且是平级的</td>
<td style="text-align:left">3. 带有分层 reducer 的单一 Store</td>
</tr>
<tr>
<td style="text-align:left">4. 有单一调度器</td>
<td style="text-align:left">4. 没有调度器的概念</td>
</tr>
<tr>
<td style="text-align:left">5. React 组件订阅 store</td>
<td style="text-align:left">5. 容器组件是有联系的</td>
</tr>
<tr>
<td style="text-align:left">6. 状态是可变的</td>
<td style="text-align:left">6. 状态是不可改变的</td>
</tr>
</tbody>
</table>
<h3 id="_45-redux-有哪些优点"> <strong>45. Redux 有哪些优点？</strong></h3>
<p>Redux 的优点如下：</p>
<ul>
<li><strong>结果的可预测性 -</strong> 由于总是存在一个真实来源，即 store ，因此不存在如何将当前状态与动作和应用的其他部分同步的问题。</li>
<li><strong>可维护性 -</strong> 代码变得更容易维护，具有可预测的结果和严格的结构。</li>
<li><strong>服务器端渲染 -</strong> 你只需将服务器上创建的 store 传到客户端即可。这对初始渲染非常有用，并且可以优化应用性能，从而提供更好的用户体验。</li>
<li><strong>开发人员工具 -</strong> 从操作到状态更改，开发人员可以实时跟踪应用中发生的所有事情。</li>
<li><strong>社区和生态系统 -</strong> Redux 背后有一个巨大的社区，这使得它更加迷人。一个由才华横溢的人组成的大型社区为库的改进做出了贡献，并开发了各种应用。</li>
<li><strong>易于测试 -</strong> Redux 的代码主要是小巧、纯粹和独立的功能。这使代码可测试且独立。</li>
<li><strong>组织 -</strong> Redux 准确地说明了代码的组织方式，这使得代码在团队使用时更加一致和简单。</li>
</ul>
<h2 id="react-路由"> <strong>React 路由</strong></h2>
<h3 id="_46-什么是react-路由"> <strong>46. 什么是React 路由？</strong></h3>
<p>React 路由是一个构建在 React 之上的强大的路由库，它有助于向应用程序添加新的屏幕和流。这使 URL 与网页上显示的数据保持同步。它负责维护标准化的结构和行为，并用于开发单页 Web 应用。 React 路由有一个简单的API。</p>
<h3 id="_47-为什么react-router-v4中使用-switch-关键字"> <strong>47. 为什么React Router v4中使用 switch 关键字 ？</strong></h3>
<p>虽然 div 用于封装 Router 中的多个路由，当你想要仅显示要在多个定义的路线中呈现的单个路线时，可以使用 “switch” 关键字。使用时，switch 标记会按顺序将已定义的 URL 与已定义的路由进行匹配。找到第一个匹配项后，它将渲染指定的路径。从而绕过其它路线。</p>
<h3 id="_48-为什么需要-react-中的路由"> <strong>48. 为什么需要 React 中的路由？</strong></h3>
<p>Router 用于定义多个路由，当用户定义特定的 URL 时，如果此 URL 与 Router 内定义的任何 “路由” 的路径匹配，则用户将重定向到该特定路由。所以基本上我们需要在自己的应用中添加一个 Router 库，允许创建多个路由，每个路由都会向我们提供一个独特的视图</p>
<div><pre><code>&lt;switch&gt;
    &lt;route exact path=’/’ component={Home}/&gt;
    &lt;route path=’/posts/:id’ component={Newpost}/&gt;
    &lt;route path=’/posts’   component={Post}/&gt;
&lt;/switch&gt;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="_49-列出-react-router-的优点。"> <strong>49. 列出 React Router 的优点。</strong></h3>
<p>几个优点是：</p>
<ol>
<li>就像 React 基于组件一样，在 React Router v4 中，API 是 <em>'All About Components'</em>。可以将 Router 可视化为单个根组件（BrowserRouter），其中我们将特定的子路由（route）包起来。</li>
<li>无需手动设置历史值：在 React Router v4 中，我们要做的就是将路由包装在 BrowserRouter 组件中。</li>
<li>包是分开的：共有三个包，分别用于 Web、Native 和 Core。这使我们应用更加紧凑。基于类似的编码风格很容易进行切换。</li>
</ol>
<h3 id="_50-react-router与常规路由有何不同"> <strong>50. React Router与常规路由有何不同？</strong></h3>
<table>
<thead>
<tr>
<th><strong>主题</strong></th>
<th style="text-align:left"><strong>常规路由</strong></th>
<th style="text-align:left"><strong>React 路由</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>参与的页面</strong></td>
<td style="text-align:left">每个视图对应一个新文件</td>
<td style="text-align:left">只涉及单个HTML页面</td>
</tr>
<tr>
<td><strong>URL 更改</strong></td>
<td style="text-align:left">HTTP 请求被发送到服务器并且接收相应的 HTML 页面</td>
<td style="text-align:left">仅更改历史记录属性</td>
</tr>
<tr>
<td><strong>体验</strong></td>
<td style="text-align:left">用户实际在每个视图的不同页面切换</td>
<td style="text-align:left">用户认为自己正在不同的页面间切换</td>
</tr>
</tbody>
</table>
<h3 id="_51-react-中-keys-的作用是什么"> 51.React 中 keys 的作用是什么？</h3>
<p>Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。</p>
<div><pre><code>render () {
  return (
    &lt;ul&gt;
      {this.state.todoItems.map(({item, key}) =&gt; {
        return &lt;li key={key}&gt;{item}&lt;/li&gt;
      })}
    &lt;/ul&gt;
  )
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。</p>
<h3 id="_52-调用-setstate-之后发生了什么"> 52.调用 setState 之后发生了什么？</h3>
<p>在代码中调用 setState 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面。在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</p>
<h3 id="_53-react-生命周期函数"> 53.react 生命周期函数</h3>
<ul>
<li>初始化阶段：
<ul>
<li>getDefaultProps:获取实例的默认属性</li>
<li>getInitialState:获取每个实例的初始化状态</li>
<li>componentWillMount：组件即将被装载、渲染到页面上</li>
<li>render:组件在这里生成虚拟的 DOM 节点</li>
<li>componentDidMount:组件真正在被装载之后</li>
</ul>
</li>
<li>运行中状态：
<ul>
<li>componentWillReceiveProps:组件将要接收到属性的时候调用</li>
<li>shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）</li>
<li>componentWillUpdate:组件即将更新不能修改属性和状态</li>
<li>render:组件重新描绘</li>
<li>componentDidUpdate:组件已经更新</li>
</ul>
</li>
<li>销毁阶段：
<ul>
<li>componentWillUnmount:组件即将销毁</li>
</ul>
</li>
</ul>
<h3 id="_54-shouldcomponentupdate-是做什么的-react-性能优化是哪个周期函数"> 54.shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）</h3>
<p>shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。</p>
<p>参考react 性能优化-sf</p>
<h3 id="_55-为什么虚拟-dom-会提高性能-必考"> 55.为什么虚拟 dom 会提高性能?(必考)</h3>
<p>虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。</p>
<p>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。</p>
<p>参考 <a href="https://www.zhihu.com/question/29504639?sort=created" target="_blank" rel="noopener noreferrer">如何理解虚拟 DOM?-zhihu</a></p>
<h3 id="_56-react-diff-原理-常考-大厂必考"> 56.react diff 原理（常考，大厂必考）</h3>
<ul>
<li>把树形结构按照层级分解，只比较同级元素。</li>
<li>给列表结构的每个单元添加唯一的 key 属性，方便比较。</li>
<li>React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）</li>
<li>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.</li>
<li>选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。</li>
</ul>
<p>参考：React 的 diff 算法</p>
<h3 id="_57-react-中-refs-的作用是什么"> 57.React 中 refs 的作用是什么？</h3>
<p>Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加 ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回：</p>
<div><pre><code>class CustomForm extends Component {
  handleSubmit = () =&gt; {
    console.log(&quot;Input Value: &quot;, this.input.value)
  }
  render () {
    return (
      &lt;form onSubmit={this.handleSubmit}&gt;
        &lt;input
          type=&#39;text&#39;
          ref={(input) =&gt; this.input = input} /&gt;
        &lt;button type=&#39;submit&#39;&gt;Submit&lt;/button&gt;
      &lt;/form&gt;
    )
  }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>上述代码中的 input 域包含了一个 ref 属性，该属性声明的回调函数会接收 input 对应的 DOM 元素，我们将其绑定到 this 指针以便在其他的类函数中使用。另外值得一提的是，refs 并不是类组件的专属，函数式组件同样能够利用闭包暂存其值：</p>
<div><pre><code>function CustomForm ({handleSubmit}) {
  let inputElement
  return (
    &lt;form onSubmit={() =&gt; handleSubmit(inputElement.value)}&gt;
      &lt;input
        type=&#39;text&#39;
        ref={(input) =&gt; inputElement = input} /&gt;
      &lt;button type=&#39;submit&#39;&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  )
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="_58-如果你创建了类似于下面的-twitter-元素-那么它相关的类定义是啥样子的"> 58.如果你创建了类似于下面的 Twitter 元素，那么它相关的类定义是啥样子的？</h3>
<div><pre><code>&lt;Twitter username=&#39;tylermcginnis33&#39;&gt;
  {(user) =&gt; user === null
    ? &lt;Loading /&gt;
    : &lt;Badge info={user} /&gt;}
&lt;/Twitter&gt;
import React, { Component, PropTypes } from &#39;react&#39;
import fetchUser from &#39;twitter&#39;
// fetchUser take in a username returns a promise
// which will resolve with that username&#39;s data.
class Twitter extends Component {
  // finish this
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>如果你还不熟悉回调渲染模式（Render Callback Pattern），这个代码可能看起来有点怪。这种模式中，组件会接收某个函数作为其子组件，然后在渲染函数中以 props.children 进行调用：</p>
<div><pre><code>import React, { Component, PropTypes } from &#39;react&#39;
import fetchUser from &#39;twitter&#39;
class Twitter extends Component {
  state = {
    user: null,
  }
  static propTypes = {
    username: PropTypes.string.isRequired,
  }
  componentDidMount () {
    fetchUser(this.props.username)
      .then((user) =&gt; this.setState({user}))
  }
  render () {
    return this.props.children(this.state.user)
  }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>这种模式的优势在于将父组件与子组件解耦和，父组件可以直接访问子组件的内部状态而不需要再通过 Props 传递，这样父组件能够更为方便地控制子组件展示的 UI 界面。譬如产品经理让我们将原本展示的 Badge 替换为 Profile，我们可以轻易地修改下回调函数即可：</p>
<div><pre><code>&lt;Twitter username=&#39;tylermcginnis33&#39;&gt;
  {(user) =&gt; user === null
    ? &lt;Loading /&gt;
    : &lt;Profile info={user} /&gt;}
&lt;/Twitter&gt;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="_59-展示组件-presentational-component-和容器组件-container-component-之间有何不同"> 59.展示组件(Presentational component)和容器组件(Container component)之间有何不同</h3>
<ul>
<li>展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。</li>
<li>容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 Flux actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。</li>
</ul>
<h3 id="_60-类组件-class-component-和函数式组件-functional-component-之间有何不同"> 60.类组件(Class component)和函数式组件(Functional component)之间有何不同</h3>
<ul>
<li>类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 store 并维持状态</li>
<li>当组件仅是接收 props，并将组件自身渲染到页面时，该组件就是一个 '无状态组件(stateless component)'，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件</li>
</ul>
<h3 id="_61-组件的-状态-state-和属性-props-之间有何不同"> 61.(组件的)状态(state)和属性(props)之间有何不同</h3>
<ul>
<li>State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。</li>
<li>Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据--回调函数也可以通过 props 传递。</li>
</ul>
<h3 id="_62-何为受控组件-controlled-component"> 62.何为受控组件(controlled component)</h3>
<p>在 HTML 中，类似 <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code> 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 onChange 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为&quot;受控元素&quot;。</p>
<h3 id="_63-何为高阶组件-higher-order-component"> 63.何为高阶组件(higher order component)</h3>
<p>高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC 最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。</p>
<h3 id="_64-为什么建议传递给-setstate-的参数是一个-callback-而不是一个对象"> 64.为什么建议传递给 setState 的参数是一个 callback 而不是一个对象</h3>
<p>因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state。</p>
<h3 id="_65-除了在构造函数中绑定-this-还有其它方式吗"> 65.除了在构造函数中绑定 this，还有其它方式吗</h3>
<p>你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。</p>
<h3 id="_66-在构造函数中-调用-super-props-的目的是什么"> 66.(在构造函数中)调用 super(props) 的目的是什么</h3>
<p>在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()。传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props。</p>
<h3 id="_67-应该在-react-组件的何处发起-ajax-请求"> 67.应该在 React 组件的何处发起 Ajax 请求</h3>
<p>在 React 组件中，应该在 componentDidMount 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 componentDidMount 中发起网络请求将保证这有一个组件可以更新了。</p>
<h3 id="_68-描述事件在-react-中的处理方式。"> 68.描述事件在 React 中的处理方式。</h3>
<p>为了解决跨浏览器兼容性问题，您的 React 中的事件处理程序将传递 SyntheticEvent 的实例，它是 React 的浏览器本机事件的跨浏览器包装器。</p>
<p>这些 SyntheticEvent 与您习惯的原生事件具有相同的接口，除了它们在所有浏览器中都兼容。有趣的是，React 实际上并没有将事件附加到子节点本身。React 将使用单个事件监听器监听顶层的所有事件。这对于性能是有好处的，这也意味着在更新 DOM 时，React 不需要担心跟踪事件监听器。</p>
<h3 id="_69-createelement-和-cloneelement-有什么区别"> 69.createElement 和 cloneElement 有什么区别？</h3>
<p>React.createElement():JSX 语法就是用 React.createElement()来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如 div、span，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。</p>
<div><pre><code>React.createElement(
    type,
    [props],
    [...children]
)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>React.cloneElement()与 React.createElement()相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而就的子元素奖杯替换。</p>
<div><pre><code>React.cloneElement(
  element,
  [props],
  [...children]
)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="_70-react-中有三种构建组件的方式"> 70.React 中有三种构建组件的方式</h3>
<p>React.createClass()、ES6 class 和无状态函数。</p>
<h3 id="_71-react-组件的划分业务组件技术组件"> 71.react 组件的划分业务组件技术组件？</h3>
<ul>
<li>根据组件的职责通常把组件分为 UI 组件和容器组件。</li>
<li>UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。</li>
<li>两者通过 React-Redux 提供 connect 方法联系起来。</li>
</ul>
<h3 id="_72-简述-flux-思想"> 72.简述 flux 思想</h3>
<p>Flux 的最大特点，就是数据的&quot;单向流动&quot;。</p>
<ol>
<li>用户访问 View</li>
<li>View 发出用户的 Action</li>
<li>Dispatcher 收到 Action，要求 Store 进行相应的更新</li>
<li>Store 更新后，发出一个&quot;change&quot;事件</li>
<li>View 收到&quot;change&quot;事件后，更新页面</li>
</ol>
<h3 id="_73-react-项目用过什么脚手架-本题是开放性题目"> 73.React 项目用过什么脚手架（本题是开放性题目）</h3>
<p>creat-react-app Yeoman 等</p>
<h3 id="_74-了解-redux-么-说一下-redux-把"> 74.了解 redux 么，说一下 redux 把</h3>
<ul>
<li>redux 是一个应用数据流框架，主要是解决了组件间状态共享的问题，原理是集中式管理，主要有三个核心方法，action，store，reducer，工作流程是 view 调用 store 的 dispatch 接收 action 传入 store，reducer 进行 state 操作，view 通过 store 提供的 getState 获取最新的数据，flux 也是用来进行数据操作的，有四个组成部分 action，dispatch，view，store，工作流程是 view 发出一个 action，派发器接收 action，让 store 进行数据更新，更新完成以后 store 发出 change，view 接受 change 更新视图。Redux 和 Flux 很像。主要区别在于 Flux 有多个可以改变应用状态的 store，在 Flux 中 dispatcher 被用来传递数据到注册的回调事件，但是在 redux 中只能定义一个可更新状态的 store，redux 把 store 和 Dispatcher 合并,结构更加简单清晰</li>
<li>新增 state,对状态的管理更加明确，通过 redux，流程更加规范了，减少手动编码量，提高了编码效率，同时缺点时当数据更新时有时候组件不需要，但是也要重新绘制，有些影响效率。一般情况下，我们在构建多交互，多数据流的复杂项目应用时才会使用它们</li>
</ul>
<h3 id="_75-redux-有什么缺点"> 75.redux 有什么缺点</h3>
<ul>
<li>一个组件所需要的数据，必须由父组件传过来，而不能像 flux 中直接从 store 取。</li>
<li>当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新 render，可能会有效率影响，或者需要写复杂的 shouldComponentUpdate 进行判断。</li>
</ul>
<p>6、vue和react的区别
1、react严格上针对的是mvc模式的view层，vue则是mvvm模式。
2、操作dom的方式不同，vue使用的是指令操作dom，react是通过js进行操作。
3、数据绑定不同，vue实现的是双向绑定，react的数据流动是单向的。</p>
<h3 id="_76-vue和react的区别"> 76.vue和react的区别</h3>
<p>1、react严格上针对的是mvc模式的view层，vue则是mvvm模式。</p>
<p>2、操作dom的方式不同，vue使用的是指令操作dom，react是通过js进行操作。</p>
<p>3、数据绑定不同，vue实现的是双向绑定，react的数据流动是单向的。</p>
<p>4、react中state是不能直接改变的，需要使用setState改变。vue中的state不是必须的，数据主要是由data属性在vue对象中管理的。</p>
<h3 id="_77、react性能优化的方案"> 77、react性能优化的方案</h3>
<blockquote>
<p>（1）重写shouldComponentUpdate来避免不必要的dom操作。
（2）使用 production 版本的react.js。
（3）使用key来帮助React识别列表中所有子组件的最小变化。</p>
</blockquote>
]]></content>
    <author>
      <name>xiechengyu</name>
    </author>
    <category term="面试"/>
    <contributor>
      <name>xiechengyu</name>
    </contributor>
    <published>2019-07-18T11:29:17.000Z</published>
    <rights>Copyright by xiechengyu</rights>
  </entry>
  <entry>
    <title type="html">npm私有仓库搭建文档</title>
    <id>https://xiechengyu.github.io/front/npm%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA%E6%96%87%E6%A1%A3/</id>
    <link href="https://xiechengyu.github.io/front/npm%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA%E6%96%87%E6%A1%A3/"/>
    <updated>2023-03-07T08:40:42.000Z</updated>
    <summary type="html"><![CDATA[<h1 id="前言"> 前言</h1>
<p>我们平时使用npm publish进行发布时，上传的仓库默认地址是npm，通过Verdaccio工具在本地新建一个仓库地址，再把本地的默认上传仓库地址切换到本地仓库地址即可。当npm install时没有找到本地的仓库，则Verdaccio默认配置中会从npm中央仓库下载。</p>
]]></summary>
    <content type="html"><![CDATA[<h1 id="前言"> 前言</h1>
<p>我们平时使用npm publish进行发布时，上传的仓库默认地址是npm，通过Verdaccio工具在本地新建一个仓库地址，再把本地的默认上传仓库地址切换到本地仓库地址即可。当npm install时没有找到本地的仓库，则Verdaccio默认配置中会从npm中央仓库下载。</p>

<h1 id="环境"> 环境</h1>
<ul>
<li>
<p>node</p>
</li>
<li>
<p>verdaccio</p>
</li>
<li>
<p>nrm（快速切换仓库源）</p>
</li>
<li>
<p>pm2（守护进程）</p>
</li>
</ul>
<h1 id="在linux环境中搭建"> 在linux环境中搭建</h1>
<h2 id="全局安装verdaccio"> 全局安装verdaccio</h2>
<p>npm install --global verdaccio</p>
<h2 id="全局安装pm2"> 全局安装pm2</h2>
<p>npm install -g pm2</p>
<h2 id="给pm2和verdaccio添加到命令"> 给pm2和verdaccio添加到命令</h2>
<p>ln -s /usr/local/nodejs/bin/verdaccio /usr/local/bin/verdaccio</p>
<p>ln -s /usr/local/nodejs/bin/pm2 /usr/local/bin/pm2</p>
<h2 id="创建一个普通用户"> 创建一个普通用户</h2>
<p>useradd wuhs</p>
<p>mkdir -p verdaccio/npmdata</p>
<h2 id="修改配置文件"> 修改配置文件</h2>
<p>cp /root/.config/verdaccio/config.yaml /home/wuhs/verdaccio/</p>
<p>cd /home/wuhs/verdaccio/</p>
<p>chown root.root config.yaml</p>
<p>su - wuhs</p>
<p>cd verdaccio/</p>
<p>vim config.yaml</p>
<p>修改为</p>
<div><pre><code>#
# This is the default configuration file. It allows all users to do anything,
# please read carefully the documentation and best practices to
# improve security.
#
# Look here for more config file examples:
# https://github.com/verdaccio/verdaccio/tree/5.x/conf
#
# Read about the best practices
# https://verdaccio.org/docs/best

# path to a directory with all packages
storage: ./storage
# path to a directory with plugins to include
plugins: ./plugins

# https://verdaccio.org/docs/webui
web:
  title: 玩美npm私库
  # comment out to disable gravatar support
  # gravatar: false
  # by default packages are ordercer ascendant (asc|desc)
  # sort_packages: asc
  # convert your UI to the dark side
  # darkMode: true
  # html_cache: true
  # by default all features are displayed
  # login: true
  # showInfo: true
  # showSettings: true
  # In combination with darkMode you can force specific theme
  # showThemeSwitch: true
  # showFooter: true
  # showSearch: true
  # showRaw: true
  # showDownloadTarball: true
  #  HTML tags injected after manifest &lt;scripts/&gt;
  # scriptsBodyAfter:
  #    - '&lt;script type=&quot;text/javascript&quot; src=&quot;https://my.company.com/customJS.min.js&quot;&gt;&lt;/script&gt;'
  #  HTML tags injected before ends &lt;/head&gt;
  #  metaScripts:
  #    - '&lt;script type=&quot;text/javascript&quot; src=&quot;https://code.jquery.com/jquery-3.5.1.slim.min.js&quot;&gt;&lt;/script&gt;'
  #    - '&lt;script type=&quot;text/javascript&quot; src=&quot;https://browser.sentry-cdn.com/5.15.5/bundle.min.js&quot;&gt;&lt;/script&gt;'
  #    - '&lt;meta name=&quot;robots&quot; content=&quot;noindex&quot; /&gt;'
  #  HTML tags injected first child at &lt;body/&gt;
  #  bodyBefore:
  #    - '&lt;div id=&quot;myId&quot;&gt;html before webpack scripts&lt;/div&gt;'
  #  Public path for template manifest scripts (only manifest)
  #  publicPath: http://somedomain.org/

# https://verdaccio.org/docs/configuration#authentication
auth:
  htpasswd:
    file: ./htpasswd
    # Maximum amount of users allowed to register, defaults to &quot;+inf&quot;.
    # You can set this to -1 to disable registration.
    # max_users: 1000
    # Hash algorithm, possible options are: &quot;bcrypt&quot;, &quot;md5&quot;, &quot;sha1&quot;, &quot;crypt&quot;.
    # algorithm: bcrypt # by default is crypt, but is recommended use bcrypt for new installations
    # Rounds number for &quot;bcrypt&quot;, will be ignored for other algorithms.
    # rounds: 10

# https://verdaccio.org/docs/configuration#uplinks
# a list of other known repositories we can talk to
uplinks:
  npmjs:
    # url: https://registry.npmjs.org/
    # 镜像
    url: https://skimdb.npmjs.com/registry/

# Learn how to protect your packages
# https://verdaccio.org/docs/protect-your-dependencies/
# https://verdaccio.org/docs/configuration#packages
packages:
  '@*/*':
    # scoped packages
    access: $all
    publish: $authenticated
    unpublish: $authenticated
    #代理 如果本地仓库没找到会去npmjs中找，npmjs就是uplinks中的变量
    proxy: npmjs

  '**':
    # allow all users (including non-authenticated users) to read and
    # publish all packages
    #
    # you can specify usernames/groupnames (depending on your auth plugin)
    # and three keywords: &quot;$all&quot;, &quot;$anonymous&quot;, &quot;$authenticated&quot;
    access: $all

    # allow all known users to publish/publish packages
    # (anyone can register by default, remember?)
    publish: $authenticated
    unpublish: $authenticated

    # if package is not available locally, proxy requests to 'npmjs' registry
    proxy: npmjs

# To improve your security configuration and  avoid dependency confusion
# consider removing the proxy property for private packages
# https://verdaccio.org/docs/best#remove-proxy-to-increase-security-at-private-packages

# https://verdaccio.org/docs/configuration#server
# You can specify HTTP/1.1 server keep alive timeout in seconds for incoming connections.
# A value of 0 makes the http server behave similarly to Node.js versions prior to 8.0.0, which did not have a keep-alive timeout.
# WORKAROUND: Through given configuration you can workaround following issue https://github.com/verdaccio/verdaccio/issues/301. Set to 0 in case 60 is not enough.
server:
  keepAliveTimeout: 60
  # Allow `req.ip` to resolve properly when Verdaccio is behind a proxy or load-balancer
  # See: https://expressjs.com/en/guide/behind-proxies.html
  # trustProxy: '127.0.0.1'

# https://verdaccio.org/docs/configuration#offline-publish
# publish:
#   allow_offline: false

# https://verdaccio.org/docs/configuration#url-prefix
# url_prefix: /verdaccio/
# VERDACCIO_PUBLIC_URL='https://somedomain.org';
# url_prefix: '/my_prefix'
# // url -&gt; https://somedomain.org/my_prefix/
# VERDACCIO_PUBLIC_URL='https://somedomain.org';
# url_prefix: '/'
# // url -&gt; https://somedomain.org/
# VERDACCIO_PUBLIC_URL='https://somedomain.org/first_prefix';
# url_prefix: '/second_prefix'
# // url -&gt; https://somedomain.org/second_prefix/'

# https://verdaccio.org/docs/configuration#security
# security:
#   api:
#     legacy: true
#     jwt:
#       sign:
#         expiresIn: 29d
#       verify:
#         someProp: [value]
#    web:
#      sign:
#        expiresIn: 1h # 1 hour by default
#      verify:
#         someProp: [value]

# https://verdaccio.org/docs/configuration#user-rate-limit
# userRateLimit:
#   windowMs: 50000
#   max: 1000

# https://verdaccio.org/docs/configuration#max-body-size
# max_body_size: 10mb

# https://verdaccio.org/docs/configuration#listen-port
# listen:
# - localhost:4873            # default value
# - http://localhost:4873     # same thing
# - 0.0.0.0:4873              # listen on all addresses (INADDR_ANY)
# - https://example.org:4873  # if you want to use https
# - &quot;[::1]:4873&quot;                # ipv6
# - unix:/tmp/verdaccio.sock    # unix socket

# The HTTPS configuration is useful if you do not consider use a HTTP Proxy
# https://verdaccio.org/docs/configuration#https
# https:
#   key: ./path/verdaccio-key.pem
#   cert: ./path/verdaccio-cert.pem
#   ca: ./path/verdaccio-csr.pem

# https://verdaccio.org/docs/configuration#proxy
# http_proxy: http://something.local/
# https_proxy: https://something.local/

# https://verdaccio.org/docs/configuration#notifications
# notify:
#   method: POST
#   headers: [{ &quot;Content-Type&quot;: &quot;application/json&quot; }]
#   endpoint: https://usagge.hipchat.com/v2/room/3729485/notification?auth_token=mySecretToken
#   content: '{&quot;color&quot;:&quot;green&quot;,&quot;message&quot;:&quot;New package published: * {{ name }}*&quot;,&quot;notify&quot;:true,&quot;message_format&quot;:&quot;text&quot;}'

middlewares:
  audit:
    enabled: true

# 监听本地所有ip，配置了后可以通过公网访问
listen: 0.0.0.0:10241

# https://verdaccio.org/docs/logger
# log settings
logs: { type: stdout, format: pretty, level: http }
#experiments:
#  # support for npm token command
#  token: false
#  # disable writing body size to logs, read more on ticket 1912
#  bytesin_off: false
#  # enable tarball URL redirect for hosting tarball with a different server, the tarball_url_redirect can be a template string
#  tarball_url_redirect: 'https://mycdn.com/verdaccio/${packageName}/${filename}'
#  # the tarball_url_redirect can be a function, takes packageName and filename and returns the url, when working with a js configuration file
#  tarball_url_redirect(packageName, filename) {
#    const signedUrl = // generate a signed url
#    return signedUrl;
#  }

# translate your registry, api i18n not available yet
# i18n:
# list of the available translations https://github.com/verdaccio/verdaccio/blob/master/packages/plugins/ui-theme/src/i18n/ABOUT_TRANSLATIONS.md
#   web: en-US
</code></pre>
</div><h2 id="使用pm2启动verdaccio"> 使用pm2启动verdaccio</h2>
<p>pm2 start verdaccio</p>
<h2 id="设置开机自启动"> 设置开机自启动</h2>
<p>1、执行pm2 save 保存已启动项目</p>
<p>2、执行pm2 startup以后会得到以下提示 设置环境变量</p>
<div><pre><code>1 [PM2] Init System found: upstart
2 [PM2] To setup the Startup Script, copy/paste the following command:
3 sudo env PATH=$PATH:/opt/bitnami/nodejs/bin /opt/bitnami/nodejs/lib/node_modules/pm2/bin/pm2 startup upstart -u bitnami --hp /home/bitnami
</code></pre>
</div><p>3、粘贴复制 sudo env….这一部分的命令 执行命令 完成。</p>
<p>4、设置完成，sudo reboot 手动重启服务器pm2 list 查看验证</p>
<h1 id="在windows环境中搭建"> 在windows环境中搭建</h1>
<h2 id="全局安装verdaccio-2"> 全局安装verdaccio</h2>
<p>npm install --global verdaccio</p>
<h2 id="全局安装pm2-2"> 全局安装pm2</h2>
<p>npm install -g pm2</p>
<h2 id="修改配置文件-2"> 修改配置文件</h2>
<p>将 C:\Users\谢成昱.config\verdaccio\config.yaml 文件更改内容为</p>
<div><pre><code>#
# This is the default configuration file. It allows all users to do anything,
# please read carefully the documentation and best practices to
# improve security.
#
# Look here for more config file examples:
# https://github.com/verdaccio/verdaccio/tree/5.x/conf
#
# Read about the best practices
# https://verdaccio.org/docs/best

# path to a directory with all packages
storage: ./storage
# path to a directory with plugins to include
plugins: ./plugins

# https://verdaccio.org/docs/webui
web:
  title: 玩美npm私库
  # comment out to disable gravatar support
  # gravatar: false
  # by default packages are ordercer ascendant (asc|desc)
  # sort_packages: asc
  # convert your UI to the dark side
  # darkMode: true
  # html_cache: true
  # by default all features are displayed
  # login: true
  # showInfo: true
  # showSettings: true
  # In combination with darkMode you can force specific theme
  # showThemeSwitch: true
  # showFooter: true
  # showSearch: true
  # showRaw: true
  # showDownloadTarball: true
  #  HTML tags injected after manifest &lt;scripts/&gt;
  # scriptsBodyAfter:
  #    - '&lt;script type=&quot;text/javascript&quot; src=&quot;https://my.company.com/customJS.min.js&quot;&gt;&lt;/script&gt;'
  #  HTML tags injected before ends &lt;/head&gt;
  #  metaScripts:
  #    - '&lt;script type=&quot;text/javascript&quot; src=&quot;https://code.jquery.com/jquery-3.5.1.slim.min.js&quot;&gt;&lt;/script&gt;'
  #    - '&lt;script type=&quot;text/javascript&quot; src=&quot;https://browser.sentry-cdn.com/5.15.5/bundle.min.js&quot;&gt;&lt;/script&gt;'
  #    - '&lt;meta name=&quot;robots&quot; content=&quot;noindex&quot; /&gt;'
  #  HTML tags injected first child at &lt;body/&gt;
  #  bodyBefore:
  #    - '&lt;div id=&quot;myId&quot;&gt;html before webpack scripts&lt;/div&gt;'
  #  Public path for template manifest scripts (only manifest)
  #  publicPath: http://somedomain.org/

# https://verdaccio.org/docs/configuration#authentication
auth:
  htpasswd:
    file: ./htpasswd
    # Maximum amount of users allowed to register, defaults to &quot;+inf&quot;.
    # You can set this to -1 to disable registration.
    # max_users: 1000
    # Hash algorithm, possible options are: &quot;bcrypt&quot;, &quot;md5&quot;, &quot;sha1&quot;, &quot;crypt&quot;.
    # algorithm: bcrypt # by default is crypt, but is recommended use bcrypt for new installations
    # Rounds number for &quot;bcrypt&quot;, will be ignored for other algorithms.
    # rounds: 10

# https://verdaccio.org/docs/configuration#uplinks
# a list of other known repositories we can talk to
uplinks:
  npmjs:
    # url: https://registry.npmjs.org/
    # 镜像
    url: https://skimdb.npmjs.com/registry/

# Learn how to protect your packages
# https://verdaccio.org/docs/protect-your-dependencies/
# https://verdaccio.org/docs/configuration#packages
packages:
  '@*/*':
    # scoped packages
    access: $all
    publish: $authenticated
    unpublish: $authenticated
    #代理 如果本地仓库没找到会去npmjs中找，npmjs就是uplinks中的变量
    proxy: npmjs

  '**':
    # allow all users (including non-authenticated users) to read and
    # publish all packages
    #
    # you can specify usernames/groupnames (depending on your auth plugin)
    # and three keywords: &quot;$all&quot;, &quot;$anonymous&quot;, &quot;$authenticated&quot;
    access: $all

    # allow all known users to publish/publish packages
    # (anyone can register by default, remember?)
    publish: $authenticated
    unpublish: $authenticated

    # if package is not available locally, proxy requests to 'npmjs' registry
    proxy: npmjs

# To improve your security configuration and  avoid dependency confusion
# consider removing the proxy property for private packages
# https://verdaccio.org/docs/best#remove-proxy-to-increase-security-at-private-packages

# https://verdaccio.org/docs/configuration#server
# You can specify HTTP/1.1 server keep alive timeout in seconds for incoming connections.
# A value of 0 makes the http server behave similarly to Node.js versions prior to 8.0.0, which did not have a keep-alive timeout.
# WORKAROUND: Through given configuration you can workaround following issue https://github.com/verdaccio/verdaccio/issues/301. Set to 0 in case 60 is not enough.
server:
  keepAliveTimeout: 60
  # Allow `req.ip` to resolve properly when Verdaccio is behind a proxy or load-balancer
  # See: https://expressjs.com/en/guide/behind-proxies.html
  # trustProxy: '127.0.0.1'

# https://verdaccio.org/docs/configuration#offline-publish
# publish:
#   allow_offline: false

# https://verdaccio.org/docs/configuration#url-prefix
# url_prefix: /verdaccio/
# VERDACCIO_PUBLIC_URL='https://somedomain.org';
# url_prefix: '/my_prefix'
# // url -&gt; https://somedomain.org/my_prefix/
# VERDACCIO_PUBLIC_URL='https://somedomain.org';
# url_prefix: '/'
# // url -&gt; https://somedomain.org/
# VERDACCIO_PUBLIC_URL='https://somedomain.org/first_prefix';
# url_prefix: '/second_prefix'
# // url -&gt; https://somedomain.org/second_prefix/'

# https://verdaccio.org/docs/configuration#security
# security:
#   api:
#     legacy: true
#     jwt:
#       sign:
#         expiresIn: 29d
#       verify:
#         someProp: [value]
#    web:
#      sign:
#        expiresIn: 1h # 1 hour by default
#      verify:
#         someProp: [value]

# https://verdaccio.org/docs/configuration#user-rate-limit
# userRateLimit:
#   windowMs: 50000
#   max: 1000

# https://verdaccio.org/docs/configuration#max-body-size
# max_body_size: 10mb

# https://verdaccio.org/docs/configuration#listen-port
# listen:
# - localhost:4873            # default value
# - http://localhost:4873     # same thing
# - 0.0.0.0:4873              # listen on all addresses (INADDR_ANY)
# - https://example.org:4873  # if you want to use https
# - &quot;[::1]:4873&quot;                # ipv6
# - unix:/tmp/verdaccio.sock    # unix socket

# The HTTPS configuration is useful if you do not consider use a HTTP Proxy
# https://verdaccio.org/docs/configuration#https
# https:
#   key: ./path/verdaccio-key.pem
#   cert: ./path/verdaccio-cert.pem
#   ca: ./path/verdaccio-csr.pem

# https://verdaccio.org/docs/configuration#proxy
# http_proxy: http://something.local/
# https_proxy: https://something.local/

# https://verdaccio.org/docs/configuration#notifications
# notify:
#   method: POST
#   headers: [{ &quot;Content-Type&quot;: &quot;application/json&quot; }]
#   endpoint: https://usagge.hipchat.com/v2/room/3729485/notification?auth_token=mySecretToken
#   content: '{&quot;color&quot;:&quot;green&quot;,&quot;message&quot;:&quot;New package published: * {{ name }}*&quot;,&quot;notify&quot;:true,&quot;message_format&quot;:&quot;text&quot;}'

middlewares:
  audit:
    enabled: true

# 监听本地所有ip，配置了后可以通过公网访问
listen: 0.0.0.0:10241

# https://verdaccio.org/docs/logger
# log settings
logs: { type: stdout, format: pretty, level: http }
#experiments:
#  # support for npm token command
#  token: false
#  # disable writing body size to logs, read more on ticket 1912
#  bytesin_off: false
#  # enable tarball URL redirect for hosting tarball with a different server, the tarball_url_redirect can be a template string
#  tarball_url_redirect: 'https://mycdn.com/verdaccio/${packageName}/${filename}'
#  # the tarball_url_redirect can be a function, takes packageName and filename and returns the url, when working with a js configuration file
#  tarball_url_redirect(packageName, filename) {
#    const signedUrl = // generate a signed url
#    return signedUrl;
#  }

# translate your registry, api i18n not available yet
# i18n:
# list of the available translations https://github.com/verdaccio/verdaccio/blob/master/packages/plugins/ui-theme/src/i18n/ABOUT_TRANSLATIONS.md
#   web: en-US
</code></pre>
</div><h2 id="下载、安装windows自启动包"> 下载、安装windows自启动包</h2>
<p>1、npm install pm2-windows-startup -g</p>
<p>2、pm2-startup install</p>
<h2 id="使用pm2启动verdaccio-2"> 使用pm2启动verdaccio</h2>
<p>pm2 start D:\nvm\v18.13.0\node_modules\verdaccio\bin\verdaccio</p>
<h2 id="设置开机自启动-2"> 设置开机自启动</h2>
<p>1、执行pm2 save 保存已启动项目</p>
<p>2、重启后通过 pm2 list查看</p>
]]></content>
    <author>
      <name>xiechengyu</name>
    </author>
    <category term="前端"/>
    <contributor>
      <name>xiechengyu</name>
    </contributor>
    <published>2019-06-05T11:36:17.000Z</published>
    <rights>Copyright by xiechengyu</rights>
  </entry>
  <entry>
    <title type="html">学习笔记</title>
    <id>https://xiechengyu.github.io/interview/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <link href="https://xiechengyu.github.io/interview/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <updated>2022-06-20T02:57:22.000Z</updated>
    <summary type="html"><![CDATA[<h2 id="前言"> 前言</h2>
<p>面试准备中学习笔记</p>
]]></summary>
    <content type="html"><![CDATA[<h2 id="前言"> 前言</h2>
<p>面试准备中学习笔记</p>

<h1 id="js"> js:</h1>
<h2 id="原型链"> 原型链：</h2>
<p><img src="https://raw.githubusercontent.com/mqyqingfeng/Blog/master/Images/prototype5.png" alt="原型链示意图" loading="lazy"></p>
<div><pre><code><span>function</span> <span>Person</span><span>(</span><span>)</span> <span>{</span>

<span>}</span>

<span>var</span> person <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>

console<span>.</span><span>log</span><span>(</span>person<span>.</span>__proto__ <span>==</span> <span>Person</span><span>.</span>prototype<span>)</span> <span>// true</span>
console<span>.</span><span>log</span><span>(</span><span>Person</span><span>.</span>prototype<span>.</span>constructor <span>==</span> Person<span>)</span> <span>// true</span>
<span>// 顺便学习一个ES5的方法,可以获得对象的原型</span>
console<span>.</span><span>log</span><span>(</span>Object<span>.</span><span>getPrototypeOf</span><span>(</span>person<span>)</span> <span>===</span> <span>Person</span><span>.</span>prototype<span>)</span> <span>// true</span>
console<span>.</span><span>log</span><span>(</span><span>Object</span><span>.</span>prototype<span>.</span>__proto__ <span>===</span> <span>null</span><span>)</span> <span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>var a = f.prototype, b = Object.getPrototypeOf(f);</p>
<p>a是构造函数f的原型 ： {constructor: ƒ} b是实例f的原型对象 ： ƒ () { [native code] }</p>
<p><strong>什么是原型链？</strong></p>
<p>当对象查找一个属性的时候，如果没有在自身找到，那么就会查找自身的原型，如果原型还没有找到，那么会继续查找原型的原型，直到找到 Object.prototype 的原型时，此时原型为 null，查找停止。 这种通过 通过原型链接的逐级向上的查找链被称为原型链</p>
<p><strong>什么是原型继承？</strong></p>
<p>一个对象可以使用另外一个对象的属性或者方法，就称之为继承。具体是通过将这个对象的原型设置为另外一个对象，这样根据原型链的规则，如果查找一个对象属性且在自身不存在时，就会查找另外一个对象，相当于一个对象可以使用另外一个对象的属性和方法了。</p>
<h2 id="继承"> 继承：</h2>
<p>寄生组合式继承的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>
<h2 id="作用域链"> 作用域链：</h2>
<p>VO:变量对象，AO:活动对象，</p>
<h2 id="闭包"> 闭包：</h2>
<ol>
<li>从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。</li>
<li>从实践角度：以下函数才算是闭包：
<ol>
<li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</li>
<li>在代码中引用了自由变量</li>
</ol>
</li>
</ol>
<h2 id="变量提升"> 变量提升：</h2>
<p>在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。</p>
<h2 id="this指向"> this指向：</h2>
<p>追根溯源的从 ECMASciript 规范讲解 this 的指向</p>
<p>Reference 的构成，由三个组成部分，分别是：</p>
<ul>
<li>base value</li>
<li>referenced name</li>
<li>strict reference</li>
</ul>
<p>base value 就是属性所在的对象或者就是 EnvironmentRecord，它的值只可能是 undefined, an Object, a Boolean, a String, a Number, or an environment record 其中的一种。</p>
<p>referenced name 就是属性的名称。</p>
<div><pre><code><span>var</span> foo <span>=</span> <span>1</span><span>;</span>

<span>// 对应的Reference是：</span>
<span>var</span> fooReference <span>=</span> <span>{</span>
    <span>base</span><span>:</span> EnvironmentRecord<span>,</span>
    <span>name</span><span>:</span> <span>'foo'</span><span>,</span>
    <span>strict</span><span>:</span> <span>false</span>
<span>}</span><span>;</span>

<span>GetValue</span><span>(</span>fooReference<span>)</span> <span>// 1;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>获取 Reference 组成部分的方法，比如 GetBase 和 IsPropertyReference。</p>
<p>GetBase()返回 reference 的 base value。IsPropertyReference()如果 base value 是一个对象，就返回true。</p>
<p>GetValue 返回对象属性真正的值。</p>
<p>如何判断this指向：</p>
<p>1.计算 MemberExpression 的结果赋值给 ref。MemberExpression 其实就是()左边的部分。</p>
<p>2.判断 ref 是不是一个 Reference 类型</p>
<p>2.1如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)</p>
<p>2.2如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref),该函数始终返回undefined</p>
<p>2.3如果 ref 不是 Reference，那么 this 的值为 undefined</p>
<p>this指向undefined，如果有调用在严格模式下报错，非严格模式下为window</p>
<p>MemberExpression :</p>
<ul>
<li>PrimaryExpression // 原始表达式 可以参见《JavaScript权威指南第四章》</li>
<li>FunctionExpression // 函数定义表达式</li>
<li>MemberExpression [ Expression ] // 属性访问表达式</li>
<li>MemberExpression . IdentifierName // 属性访问表达式</li>
<li>new MemberExpression Arguments // 对象创建表达式</li>
</ul>
<p>有赋值操作符、逻辑与算法、逗号操作符都会调用GetValue()，返回的对象都不会是reference</p>
<p>this一般有几种调用场景
var obj = {a: 1, b: function(){console.log(this);}}
1、作为对象调用时，指向该对象 obj.b(); // 指向obj
2、作为函数调用, var b = obj.b; b(); // 指向全局window
3、作为构造函数调用 var b = new Fun(); // this指向当前实例对象
4、作为call与apply调用 obj.b.apply(object, []); // this指向当前的object</p>
<h2 id="立即执行函数"> 立即执行函数</h2>
<div><pre><code><span>// 在IIFE里，`i`值被锁定在了`lockedInIndex`里。</span>
<span>// 在循环结束执行时，尽管`i`值的数值是所有元素的总和，但每一次函数表达式被调用时，</span>
<span>// IIFE 里的 `lockedInIndex` 值都是`i`传给它的值,所以当链接被点击时，正确的值被弹出。</span>

<span>var</span> elems <span>=</span> document<span>.</span><span>getElementsByTagName</span><span>(</span><span>'a'</span><span>)</span><span>;</span>
<span>for</span><span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span>i <span>&lt;</span> elems<span>.</span>length<span>;</span>i<span>++</span><span>)</span> <span>{</span>
    <span>(</span><span>function</span><span>(</span><span>lockedInIndex</span><span>)</span><span>{</span>
        elems<span>[</span>i<span>]</span><span>.</span><span>addEventListener</span><span>(</span><span>'click'</span><span>,</span><span>function</span><span>(</span><span>e</span><span>)</span><span>{</span>
            e<span>.</span><span>preventDefault</span><span>(</span><span>)</span><span>;</span>
            <span>alert</span><span>(</span><span>'I am link #'</span> <span>+</span> lockedInIndex<span>)</span><span>;</span>
            <span>}</span><span>,</span><span>false</span><span>)</span>
    <span>}</span><span>)</span><span>(</span>i<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="instanceof-原理"> instanceof 原理</h2>
<p>用 <code>typeof</code> 来判断<code>number</code>, <code>string</code>, <code>object</code>, <code>boolean</code>, <code>function</code>, <code>undefined</code>, <code>symbol</code> 这七种类型</p>
<p><code>typeof</code> 的原理：</p>
<p>js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息👉</p>
<ul>
<li>
<p>000：对象</p>
</li>
<li>
<p>010：浮点数</p>
</li>
<li>
<p>100：字符串</p>
</li>
<li>
<p>110：布尔</p>
</li>
<li>
<p>1：整数</p>
</li>
<li>
<p>所有机器码均为0：null</p>
</li>
<li>
<p>−2^30 整数:undefined</p>
</li>
</ul>
<p>Object.prototype.toString，我们可以利用这个方法来对一个变量的类型来进行比较准确的判断</p>
<div><pre><code><span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span><span>1</span><span>)</span> <span>// "[object Number]"</span>

<span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span><span>'hi'</span><span>)</span> <span>// "[object String]"</span>

<span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span><span>{</span><span>a</span><span>:</span><span>'hi'</span><span>}</span><span>)</span> <span>// "[object Object]"</span>

<span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span><span>[</span><span>1</span><span>,</span><span>'a'</span><span>]</span><span>)</span> <span>// "[object Array]"</span>

<span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span><span>true</span><span>)</span> <span>// "[object Boolean]"</span>

<span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span><span>}</span><span>)</span> <span>// "[object Function]"</span>

<span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span><span>null</span><span>)</span> <span>// "[object Null]"</span>

<span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span><span>undefined</span><span>)</span> <span>// "[object Undefined]"</span>

<span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span><span>Symbol</span><span>(</span><span>1</span><span>)</span><span>)</span> <span>// "[object Symbol]"</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>instanceof就是查找原型链。</p>
<p>简单来说，我们使用 <code>typeof</code> 来判断基本数据类型是 ok 的，不过需要注意当用 <code>typeof</code> 来判断 <code>null</code> 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 <code>instanceof</code>，但是 <code>instanceof</code> 也可能判断不准确，比如一个数组，他可以被 <code>instanceof</code> 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 <code>Object.prototype.toString.call</code> 方法。</p>
<h2 id="apply、call、bind"> apply、call、bind</h2>
<p>调用改变函数this指向</p>
<h2 id="柯里化"> 柯里化</h2>
<p>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术</p>
<h2 id="v8垃圾回收机制"> v8垃圾回收机制</h2>
<h3 id="如何避免内存泄漏"> 如何避免内存泄漏</h3>
<h4 id="_1、尽可能少地创建全局变量"> 1、尽可能少地创建全局变量</h4>
<p>如果你遇到需要必须使用全局变量的场景，那么请保证一定要在全局变量使用完毕后将其设置为<code>null</code>从而触发回收机制。</p>
<h4 id="_2、手动清除定时器"> 2、手动清除定时器</h4>
<h4 id="_3、少用闭包"> 3、少用闭包</h4>
<h4 id="_4、清除dom引用"> 4、清除DOM引用</h4>
<h4 id="_5、-弱引用"> 5、 弱引用</h4>
<p>WeakMap<code>和</code>WeakSet</p>
<h2 id="双精度浮点数"> 双精度浮点数</h2>
<p>0.1+0.2 不等于0.3</p>
<div><pre><code><span>function</span> <span>DeviationValue</span><span>(</span><span>num1<span>,</span> num2</span><span>)</span> <span>{</span>
    <span>return</span> Math<span>.</span><span>abs</span><span>(</span>num1 <span>-</span> num2<span>)</span> <span>&lt;</span> Number<span>.</span><span>EPSILON</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>因为JavaScript使用IEEE浮点类型双精度。转换为二进制在计算但是小数无限延伸，二进制截取53位导致精度丢失。
这就是0.1+0.2不为0.3的原因
Number.EPSILON的精度是2^-52，所以只要丢失精度小于Number.EPSILON基本可以确认相等。</p>
<h2 id="new运算符"> new运算符</h2>
<p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一</p>
<div><pre><code><span>function</span> <span>objectFactory</span><span>(</span><span>)</span> <span>{</span>

    <span>var</span> obj <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>,</span>

    Constructor <span>=</span> <span>[</span><span>]</span><span>.</span><span>shift</span><span>.</span><span>call</span><span>(</span>arguments<span>)</span><span>;</span>

    obj<span>.</span>__proto__ <span>=</span> <span>Constructor</span><span>.</span>prototype<span>;</span>

    <span>var</span> ret <span>=</span> <span>Constructor</span><span>.</span><span>apply</span><span>(</span>obj<span>,</span> arguments<span>)</span><span>;</span>

    <span>return</span> <span>typeof</span> ret <span>===</span> <span>'object'</span> <span>?</span> ret <span>:</span> obj<span>;</span>

<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="event-loop事件循环机制"> Event Loop事件循环机制</h2>
<h3 id="_1-执行栈与事件队列"> 1.执行栈与事件队列</h3>
<p>js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。</p>
<p><img src="https://pic4.zhimg.com/80/v2-da078fa3eadf3db4bf455904ae06f84b_1440w.jpg" alt="img" loading="lazy"></p>
<h3 id="_2-macro-task与micro-task"> 2.macro task与micro task</h3>
<p>在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会 查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈...如此反复，进入循环。</p>
<p>我们只需记住<strong>当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行</strong>。</p>
<p>macro-task大概包括：</p>
<ul>
<li>script(整体代码)</li>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate</li>
<li>I/O</li>
<li>UI render</li>
</ul>
<p>micro-task大概包括:</p>
<ul>
<li>process.nextTick</li>
<li>Promise</li>
<li>Async/Await(实际就是promise)</li>
<li>MutationObserver(html5新特性)</li>
</ul>
<p>如果有async/await函数，那么await函数后会先跳出函数，继续执行本次事件循环，本次结束后回来将await后的代码加入微任务队列</p>
<h3 id="node环境下的事件循环机制"> node环境下的事件循环机制</h3>
<p>node中的事件循环的顺序：</p>
<p>外部输入数据--&gt;轮询阶段(poll)--&gt;检查阶段(check)--&gt;关闭事件回调阶段(close callback)--&gt;定时器检测阶段(timer)--&gt;I/O事件回调阶段(I/O callbacks)--&gt;闲置阶段(idle, prepare)--&gt;轮询阶段...</p>
<div><pre><code> ┌───────────────────────┐
┌─&gt;│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll          │&amp;lt;──connections───     │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><ul>
<li>timers: 这个阶段执行定时器队列中的回调如 <code>setTimeout()</code> 和 <code>setInterval()</code>。</li>
<li>I/O callbacks: 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和<code>setImmediate()</code>的回调。</li>
<li>idle, prepare: 这个阶段仅在内部使用，可以不必理会。</li>
<li>poll: 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。</li>
<li>check: <code>setImmediate()</code>的回调会在这个阶段执行。</li>
<li>close callbacks: 例如<code>socket.on('close', ...)</code>这种close事件的回调。</li>
</ul>
<p>因为在I/O事件的回调中，setImmediate方法的回调永远在timer的回调前执行。</p>
<p>node11 版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行对应的微任务队列。</p>
<h2 id="promise原理"> Promise原理</h2>
<p>主要考手写promise</p>
<h2 id="高阶函数"> 高阶函数</h2>
<p>函数作为参数或者函数作为返回值</p>
<h1 id="css"> Css:</h1>
<h2 id="盒子模型"> 盒子模型：</h2>
<h3 id="外边距重叠"> 外边距重叠</h3>
<p>只有普通文档流中块框的垂直外边距才会发生外边距合并，行内框、浮动框或绝对定位之间的外边距不会合并。</p>
<h3 id="bfc-block-formatting-context-块级格式化上下文"> BFC**(Block Formatting Context) ** 块级格式化上下文</h3>
<p><strong>如何创建BFC</strong></p>
<ol>
<li>overflow不为visible;</li>
<li>float的值不为none；</li>
<li>position的值不为static或relative；</li>
<li>display属性为inline-blocks,table,table-cell,table-caption,flex,inline-flex;</li>
</ol>
<h2 id="css-模块化的实现方式"> CSS 模块化的实现方式</h2>
<h3 id="bem-命名规范"> BEM 命名规范</h3>
<p>BEM 的意思就是块（block）、元素（element）、修饰符（modifier）。是由 Yandex 团队提出的一种前端命名方法论。这种巧妙的命名方法让你的 css 类对其他开发者来说更加透明而且更有意义。</p>
<p>BEM 的命名规范如下：</p>
<div><pre><code>/* 块即是通常所说的 Web 应用开发中的组件或模块。每个块在逻辑上和功能上都是相互独立的。 */
.block {
}

/* 元素是块中的组成部分。元素不能离开块来使用。BEM 不推荐在元素中嵌套其他元素。 */
.block__element {
}

/* 修饰符用来定义块或元素的外观和行为。同样的块在应用不同的修饰符之后，会有不同的外观 */
.block--modifier {
}
复制代码
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>通过 bem 的命名方式，可以让我们的 css 代码层次结构清晰，通过严格的命名也可以解决命名冲突的问题，但也不能完全避免，毕竟只是一个命名约束，不按规范写照样能运行。</p>
<h2 id="html和浏览器"> html和浏览器</h2>
<h3 id="跨标签页通信"> 跨标签页通信</h3>
<h4 id="broadcast-channel"> BroadCast Channel</h4>
<p>下面的方式就可以创建一个标识为<code>AlienZHOU</code>的频道：</p>
<div><pre><code>const bc = new BroadcastChannel(&#39;AlienZHOU&#39;);
复制代码
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>各个页面可以通过<code>onmessage</code>来监听被广播的消息：</p>
<div><pre><code>bc.onmessage = function (e) {
    const data = e.data;
    const text = &#39;[receive] &#39; + data.msg + &#39; —— tab &#39; + data.from;
    console.log(&#39;[BroadcastChannel] receive message:&#39;, text);
};
复制代码
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>要发送消息时只需要调用实例上的<code>postMessage</code>方法即可：</p>
<div><pre><code>bc.postMessage(mydata);
</code></pre>
<div><span>1</span><br></div></div><h4 id="service-worker"> Service Worker</h4>
<h4 id="localstorage"> LocalStorage</h4>
<p>当 LocalStorage 变化时，会触发<code>storage</code>事件。利用这个特性，我们可以在发送消息时，把消息写入到某个 LocalStorage 中；然后在各个页面内，通过监听<code>storage</code>事件即可收到通知。</p>
<div><pre><code>window.addEventListener(&#39;storage&#39;, function (e) {
    if (e.key === &#39;ctc-msg&#39;) {
        const data = JSON.parse(e.newValue);
        const text = &#39;[receive] &#39; + data.msg + &#39; —— tab &#39; + data.from;
        console.log(&#39;[Storage I] receive message:&#39;, text);
    }
});
复制代码
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>在各个页面添加如上的代码，即可监听到 LocalStorage 的变化。当某个页面需要发送消息时，只需要使用我们熟悉的<code>setItem</code>方法即可</p>
<h4 id="shared-worker"> Shared Worker</h4>
<h4 id="indexeddb"> IndexedDB</h4>
<h4 id="window-open-window-opener"> window.open + window.opener</h4>
<h2 id="history和hash两种路由"> history和hash两种路由</h2>
<h3 id="hash模式"> hash模式</h3>
<p>使用window.location.hash属性及窗口的onhashchange事件，可以实现监听浏览器地址hash值变化，执行相应的js切换网页。下面具体介绍几个使用过程中必须理解的要点：</p>
<p>hash指的是地址中#号以及后面的字符，也称为散列值。hash也称作锚点，本身是用来做页面跳转定位的。如http://localhost/index.html#abc，这里的#abc就是hash；
散列值是不会随请求发送到服务器端的，所以改变hash，不会重新加载页面；
监听 window 的 hashchange 事件，当散列值改变时，可以通过 location.hash 来获取和设置hash值；
location.hash值的变化会直接反应到浏览器地址栏；</p>
<h3 id="history模式"> history模式</h3>
<p>window.history 属性指向 History 对象，它表示当前窗口的浏览历史。当发生改变时，只会改变页面的路径，不会刷新页面。
History 对象保存了当前窗口访问过的所有页面网址。通过 history.length 可以得出当前窗口一共访问过几个网址。
由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航。
浏览器工具栏的“前进”和“后退”按钮，其实就是对 History 对象进行操作。</p>
<p>popstate 事件
每当 history 对象出现变化时，就会触发 popstate 事件。</p>
<p>注意：</p>
<p>仅仅调用pushState()方法或replaceState()方法 ，并不会触发该事件;
只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用History.back()、History.forward()、History.go()方法时才会触发。
另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。
页面第一次加载的时候，浏览器不会触发popstate事件。
使用的时候，可以为popstate事件指定回调函数，回调函数的参数是一个 event 事件对象，它的 state 属性指向当前的 state 对象。</p>
<div><pre><code>window<span>.</span><span>addEventListener</span><span>(</span><span>'popstate'</span><span>,</span> <span>function</span><span>(</span><span>e</span><span>)</span> <span>{</span>
	<span>//e.state 相当于 history.state</span>
	console<span>.</span><span>log</span><span>(</span><span>'state: '</span> <span>+</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span>e<span>.</span>state<span>)</span><span>)</span><span>;</span>
	console<span>.</span><span>log</span><span>(</span>history<span>.</span>state<span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>通过history.pushState 实现页面 tab 切换的功能。</p>
<h2 id="dom树"> DOM树</h2>
<p>HTML 解析器（HTMLParser）的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。</p>
<p><strong>第一个阶段，通过分词器将字节流转换为 Token。</strong></p>
<p><strong>后续的第二个和第三个阶段是同步进行的，需要将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中</strong>。</p>
<blockquote>
<p>HTML 解析器维护了一个Token 栈结构，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。具体的处理规则如下所示：</p>
</blockquote>
<ul>
<li>如果压入到栈中的是StartTag Token，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。</li>
<li>如果分词器解析出来是文本 Token，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。</li>
<li>如果分词器解析出来的是EndTag 标签，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就将 StartTag div 从栈中弹出，表示该 div 元素解析完成。</li>
</ul>
<p>引入 JavaScript 线程会阻塞 DOM，不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码。</p>
<p>Chrome 浏览器做了很多优化，其中一个主要的优化是预解析操作。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。</p>
<p>需要先解析 JavaScript 语句之上所有的 CSS 样式。所以如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。</p>
<p>而 JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，都会执行 CSS 文件下载，解析操作，再执行 JavaScript 脚本。</p>
<h2 id="事件模型"> 事件模型</h2>
<p>浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。这是事件驱动编程模式（event-driven）的主要编程方式。</p>
<p>JavaScript 有三种方法，可以为事件绑定监听函数。</p>
<h5 id="html-的-on-属性"> HTML 的 on- 属性</h5>
<h5 id="元素节点的事件属性"> 元素节点的事件属性</h5>
<h5 id="eventtarget-addeventlistener"> EventTarget.addEventListener()</h5>
<p><code>addEventListener</code>方法第三个参数的不同，会导致绑定两个监听函数</p>
<h3 id="事件代理"> 事件代理</h3>
<p>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。</p>
<div><pre><code>event<span>.</span><span>stopPropagation</span><span>(</span><span>)</span><span>;</span><span>//阻止事件冒泡</span>
event<span>.</span><span>stopImmediatePropagation</span><span>(</span><span>)</span><span>;</span><span>//阻止事件冒泡的同时，停止执行直接的js</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="缓存机制"> 缓存机制</h2>
<p>HTTP请求(Request)报文，报文格式为：请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体(只有POST才有报文主体)。</p>
<p>HTTP响应(Response)报文，报文格式为：状态行 – HTTP头(通用信息头，响应头，实体头) – 响应报文主体。</p>
<p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：</p>
<p><img src="/assets/img/image-20210506163022010.png" alt="image-20210506163022010" loading="lazy"></p>
<p>由上图我们可以知道：</p>
<ul>
<li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li>
<li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li>
</ul>
<p>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强制缓存和协商缓存。</p>
<h3 id="强制缓存"> 强制缓存</h3>
<h5 id="expires"> Expires</h5>
<h5 id="cache-control"> Cache-Control</h5>
<p>在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：</p>
<ul>
<li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</li>
<li>private：所有内容只有客户端可以缓存，Cache-Control的默认取值</li>
<li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li>
<li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li>
<li>max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效</li>
</ul>
<p>Cache-Control优先。</p>
<p>from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –&gt; disk。</p>
<p>虽然我已经直接把结论说出来了，但是相信有不少人对此不能理解，那么接下来我们一起详细分析一下缓存读取问题，这里仍让以我的博客为例进行分析：</p>
<p>访问https://heyingye.github.io/ –&gt; 200 –&gt; 关闭博客的标签页 –&gt; 重新打开https://heyingye.github.io/ –&gt; 200(from disk cache) –&gt; 刷新 –&gt; 200(from memory cache)</p>
<p>有强制缓存优先走缓存，没有缓存请求服务器，缓存失效走协商缓存</p>
<h4 id="协商缓存"> 协商缓存</h4>
<p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</p>
<h5 id="协商缓存生效-返回304"> 协商缓存生效，返回304</h5>
<p><img src="/assets/img/25896355-020A-4429-B26C-25814A1DB19D.png" alt="25896355-020A-4429-B26C-25814A1DB19D" loading="lazy"></p>
<h5 id="协商缓存失效-返回200和请求结果结果"> 协商缓存失效，返回200和请求结果结果</h5>
<p><img src="/assets/img/90063D17-AAC7-4C3A-BC2A-B9FA72668708.png" alt="90063D17-AAC7-4C3A-BC2A-B9FA72668708" loading="lazy"></p>
<p>同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。</p>
<p>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存，主要过程如下：</p>
<p><img src="/assets/img/F65ADB02-FDEA-48CA-A01F-553995F43B8F.png" alt="F65ADB02-FDEA-48CA-A01F-553995F43B8F" loading="lazy"></p>
<h2 id="浏览器架构"> 浏览器架构</h2>
<h2 id="浏览器工作原理"> 浏览器工作原理</h2>
<h2 id="内存泄露"> 内存泄露</h2>
<h3 id="javascript-内存泄漏的一些场景"> JavaScript 内存泄漏的一些场景</h3>
<h5 id="意外的全局变量"> 意外的全局变量</h5>
<h5 id="被遗忘的计时器-在beforedestroy生命周期内清除"> 被遗忘的计时器（在beforeDestroy生命周期内清除）</h5>
<h5 id="被遗忘的事件监听器-在beforedestroy生命周期removeeventlistener"> 被遗忘的事件监听器（在beforeDestroy生命周期removeEventListener）</h5>
<h5 id="被遗忘的-es6-set-成员-使用完后delete或使用weakset"> 被遗忘的 ES6 Set 成员（使用完后delete或使用WeakSet）</h5>
<h5 id="被遗忘的-es6-map-键名-使用完后delete键名或使用weakmap"> 被遗忘的 ES6 Map 键名（使用完后delete键名或使用WeakMap）</h5>
<h5 id="被遗忘的订阅发布事件监听器"> 被遗忘的订阅发布事件监听器</h5>
<h5 id="被遗忘的闭包"> 被遗忘的闭包</h5>
<h5 id="脱离-dom-的引用"> 脱离 DOM 的引用</h5>
<h3 id="如何发现内存泄漏"> 如何发现内存泄漏？</h3>
<h1 id="性能"> 性能</h1>
<h3 id="前端性能优化"> 前端性能优化</h3>
<ul>
<li>超过50ms的响应，一定要提供反馈，比如倒计时，进度百分比等。</li>
<li>可以采用 <a href="https://web.dev/native-lazy-loading/" target="_blank" rel="noopener noreferrer">lazy load</a>，<a href="https://web.dev/reduce-javascript-payloads-with-code-splitting/" target="_blank" rel="noopener noreferrer">code-splitting</a> 等 <a href="https://web.dev/fast/" target="_blank" rel="noopener noreferrer">其他优化</a> 手段，让第一次加载的资源更少</li>
</ul>
<h4 id="分析rail用的工具"> 分析RAIL用的工具</h4>
<ul>
<li><a href="https://developers.google.com/web/tools/chrome-devtools" target="_blank" rel="noopener noreferrer">Chrome DevTools</a></li>
<li><a href="https://web.dev/measure/" target="_blank" rel="noopener noreferrer">Lighthouse</a></li>
<li><a href="https://webpagetest.org/easy" target="_blank" rel="noopener noreferrer">WebPageTest</a></li>
</ul>
<p>RAIL是一个旅程，为了提升用户在网站的交互体验而不断探索。你需要去理解用户如何感知你的站点，这样才能设置最佳的性能目标</p>
<ul>
<li>聚焦用户</li>
<li>100ms内响应用户的输入</li>
<li>10ms内产生1帧，在滚动或者动画执行时</li>
<li>最大化主线程的空闲时间</li>
<li>5s内让网页变得可交互</li>
</ul>
<h2 id="重排-reflow-和重绘-repaints"> 重排(reflow)和重绘(Repaints)</h2>
<p>在页面的生命周期中，<strong>网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断触发重排(reflow)和重绘(repaint)</strong>，不管页面发生了重绘还是重排，都会影响性能，最可怕的是重排，会使我们付出高额的性能代价，所以我们应尽量避免。</p>
<ul>
<li>重绘：某些元素的外观被改变，例如：元素的填充颜色</li>
<li>重排：重新生成布局，重新排列元素。</li>
</ul>
<p><strong>重绘不一定导致重排，但重排一定会导致重绘</strong>。</p>
<h4 id="下面情况会发生重排"> 下面情况会发生重排：</h4>
<ul>
<li>页面初始渲染，这是开销最大的一次重排</li>
<li>添加/删除可见的DOM元素</li>
<li>改变元素位置</li>
<li>改变元素尺寸，比如边距、填充、边框、宽度和高度等</li>
<li>改变元素内容，比如文字数量，图片大小等</li>
<li>改变元素字体大小</li>
<li>改变浏览器窗口尺寸，比如resize事件发生时</li>
<li>激活CSS伪类（例如：<code>:hover</code>）</li>
<li>设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow</li>
<li>查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等，除此之外，当我们调用 <code>getComputedStyle</code>方法，或者IE里的 <code>currentStyle</code> 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。</li>
</ul>
<h4 id="重排优化建议"> 重排优化建议:</h4>
<h5 id="减少重排范围"> 减少重排范围</h5>
<h5 id="减少重排次数"> 减少重排次数</h5>
<h6 id="样式集中改变"> 样式集中改变</h6>
<h6 id="分离读写操作"> 分离读写操作</h6>
<h6 id="将-dom-离线"> 将 DOM 离线</h6>
<h6 id="使用-absolute-或-fixed-脱离文档流"> 使用 absolute 或 fixed 脱离文档流</h6>
<h6 id="优化动画"> 优化动画</h6>
<h3 id="小结"> 小结：</h3>
<ul>
<li>渲染的三个阶段 Layout，Paint，Composite Layers。 Layout：重排，又叫回流。 Paint:重绘，重排重绘这些步骤都是在 CPU 中发生的。 Compostite Layers：CPU 把生成的 BitMap（位图）传输到 GPU，渲染到屏幕。</li>
<li>CSS3 就是在 GPU 发生的：Transform  Opacity。在 GPU 发生的属性比较高效。所以 CSS3 性能比较高。</li>
</ul>
<h2 id="优化白屏"> 优化白屏</h2>
<h3 id="_1-dns解析优化"> 1. DNS解析优化</h3>
<h3 id="_2-tcp网络链路优化"> 2. TCP网络链路优化</h3>
<h3 id="_3-服务端处理优化"> 3. 服务端处理优化</h3>
<h3 id="_4-浏览器下载、解析、渲染页面优化"> 4. 浏览器下载、解析、渲染页面优化</h3>
<p>根据浏览器对页面的下载、解析、渲染过程，可以考虑一下的优化处理：</p>
<ul>
<li>尽可能的精简HTML的代码和结构</li>
<li>尽可能的优化CSS文件和结构</li>
<li>一定要合理的放置JS代码，尽量不要使用内联的JS代码</li>
</ul>
<h2 id="大量图片加载"> 大量图片加载</h2>
<p>1、优先加载首屏图片</p>
<p>、在 HTTP/1.0 和 HTTP/1.1 协议下，由于 Chrome 只支持同域同时发送 6 个并发请求，可以进行域名切分，来提升并发的请求数量，或者使用 HTTP/2 协议。</p>
<p>3、动态裁剪图片</p>
<p>4、优化图片大小</p>
<h2 id="描述下浏览器从输入网址到页面展现的整个过程"> 描述下浏览器从输入网址到页面展现的整个过程</h2>
<p>输入网址URL
浏览器获取url，通过DNS解析获得网址的对应IP地址。首先先去各个缓存当中看看有没有DNS缓存，如果有则直接显示，不需要重新发送HTTP请求，如果没有进行下一步。
通过DNS解析获得网址的对应IP地址
浏览器与服务器 通过TCP三次握手协商来建立一个 TCP连接。（1.浏览器问 “服务器，在吗？” 2.服务器回答“在的，怎么了？” 3.浏览器说“我想请你帮个忙”）
浏览器服务器 发送一个 HTTP 请求报文
服务器处理请求并返回一个 HTTP 响应报文
浏览器收到响应，进行客户端渲染，生成Dom树、Css样式树、执行Js交互
构建渲染树，计算并布局。
浏览器绘制页面。</p>
<h2 id="动画性能"> 动画性能</h2>
<h4 id="精简dom-合理布局"> 精简DOM，合理布局</h4>
<h4 id="使用transform代替left、top减少使用引起页面重排的属性"> 使用transform代替left、top减少使用引起页面重排的属性</h4>
<h4 id="开启硬件加速"> 开启硬件加速</h4>
<h4 id="尽量避免浏览器创建不必要的图形层"> 尽量避免浏览器创建不必要的图形层</h4>
<h4 id="尽量减少js动画-如需要-使用对性能友好的requestanimationframe"> 尽量减少js动画，如需要，使用对性能友好的requestAnimationFrame</h4>
<h4 id="使用chrome-performance工具调试动画性能"> 使用chrome performance工具调试动画性能</h4>
<h1 id="工程化"> 工程化</h1>
<h2 id="模块化机制"> 模块化机制</h2>
<ul>
<li>CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。</li>
<li>AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。</li>
<li>CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM 打包，模块的加载逻辑偏重</li>
<li><strong>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案</strong>。</li>
</ul>
<h2 id="tree-shaking"> tree-shaking</h2>
<h2 id="uglify原理"> Uglify原理</h2>
<h2 id="babel原理"> babel原理</h2>
<h2 id="webpack工作流程"> webpack工作流程</h2>
<h2 id="webpack插件机制"> webpack插件机制</h2>
<h2 id="webpack-loader机制"> Webpack loader机制</h2>
<h2 id="前端微服务"> 前端微服务</h2>
<p>Qiankun</p>
<p>https://qiankun.umijs.org/zh</p>
<h1 id="框架"> 框架</h1>
<h2 id="react"> react</h2>
<h2 id="vue"> vue</h2>
<h1 id="操作系统"> 操作系统</h1>
<h1 id="网络"> 网络</h1>
<h2 id="tcp"> tcp</h2>
<p>3次握手跟4次挥手 3次握手就跟早期打电话时的情况一样：1、听得到吗？2、听得到，你呢？3、我也听到了。然后才开始真正对话 4次挥手是：1、老师，下课了。2、好，我知道了，我说完这点。3、好了，说完了，下课吧。4、谢谢老师，老师再见</p>
<h2 id="七层网络结构"> 七层网络结构</h2>
<p><img src="https://pic1.zhimg.com/80/v2-2d62ba265be486cb94ab531912aa3b9c_1440w.jpg" alt="img" loading="lazy"></p>
<h2 id="http"> http</h2>
<h4 id="http-0-9-1-0"> HTTP 0.9 / 1.0</h4>
<h4 id="http-1-1"> HTTP/1.1</h4>
<p>keepalive可长连接</p>
<h4 id="http-2"> HTTP/2</h4>
<ul>
<li>HTTP/2是一个二进制协议，增加了数据传输的效率。</li>
<li>HTTP/2是可以在一个TCP链接中并发请求多个HTTP请求，移除了HTTP/1.1中的串行请求。</li>
</ul>
<h4 id="http-3"> HTTP/3</h4>
<p>把tcp改成udp</p>
<h2 id="https"> https</h2>
<ul>
<li>数据加密 传输内容进行混淆</li>
<li>身份验证 通信双方验证对方的身份真实性</li>
<li>数据完整性保护 检测传输的内容是否被篡改或伪造</li>
</ul>
<h4 id="加密方式"> 加密方式</h4>
<p>HTTPS采用共享密钥加密和公开密钥加密混合的加密方式，在交换密钥对环节使用公开密钥加密方式（防止被监听泄漏密钥）加密共享的密钥，在随后的通信过程中使用共享密钥的方式使用共享的密钥进行加解密。</p>
<h4 id="认证方式"> 认证方式</h4>
<ul>
<li>操作系统和浏览器内置</li>
<li>证书颁发机构</li>
<li>手动指定证书</li>
</ul>
<h4 id="https数据交互过程"> HTTPS数据交互过程</h4>
<p>SSL 和 TLS</p>
<h2 id="http2-0"> http2.0</h2>
<h2 id="http3-0"> http3.0</h2>
<p>使用UDP取代TCP</p>
<ul>
<li>UDP本身是无连接的、没有建链和拆链成本</li>
</ul>
<h2 id="websocket"> websocket</h2>
<p>Webscoket是Web浏览器和服务器之间的一种全双工通信协议，其中WebSocket协议由IETF定为标准，WebSocket API由W3C定为标准。一旦Web客户端与服务器建立起连接，之后的全部数据通信都通过这个连接进行。通信过程中，可互相发送JSON、XML、HTML或图片等任意格式的数据。
WS（WebSocket）与HTTP协议相比，</p>
<p>相同点主要有：</p>
<p>都是基于TCP的应用层协议；
都使用Request/Response模型进行连接的建立；
在连接的建立过程中对错误的处理方式相同，在这个阶段WS可能返回和HTTP相同的返回码；
都可以在网络中传输数据。
不同之处在于：</p>
<p>WS使用HTTP来建立连接，但是定义了一系列新的header域，这些域在HTTP中并不会使用；
WS的连接不能通过中间人来转发，它必须是一个直接连接；
WS连接建立之后，通信双方都可以在任何时刻向另一方发送数据；
WS连接建立之后，数据的传输使用帧来传递，不再需要Request消息；
WS的数据帧有序。</p>
<h1 id="node"> Node</h1>
<h2 id="模块机制"> 模块机制</h2>
<h3 id="commonjs规范"> <code>CommonJS</code>规范</h3>
<p>通过require()载入模块，module.export xxx 导出模块</p>
<h3 id="import和require"> <code>import</code>和<code>require</code></h3>
<p><code>import</code>是ES6的模块规范，<code>require</code>是commonjs的模块规范，<strong>import是静态加载模块，require是动态加载</strong></p>
<p>import性能更好，按需引入，支持tree-shaking</p>
<h2 id="cluster是从来管理多线程的"> cluster是从来管理多线程的</h2>
<h2 id="stream-流机制"> stream 流机制</h2>
<h2 id="pipe原理"> pipe原理</h2>
<p><img src="/assets/img/jy71hykr3w.gif" alt="img" loading="lazy"></p>
<h1 id="设计架构"> 设计架构</h1>
<h2 id="设计模式"> 设计模式</h2>
<h2 id="重构"> 重构</h2>
<p><strong>设计模式是理想主义</strong>
为理想的软件设计提供目标，但是达到这个目标通常很困难，很有可能存在过度设计</p>
<p><strong>重构是实用主义</strong>
满足当前需求设计同时，在版本迭代中不断改进当前的设计，尽量靠近设计模式的理想国度</p>
<p>相辅相成的关系，设计模式为重构提供目标，在不断的重构中达到理想状态</p>
<h2 id="mvvm"> MVVM</h2>
<p>在MVVM架构下，View 和 Model 之间其实并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</p>
<p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，ViewModel里面包含DOM Listeners和Data Bindings，DOM Listeners和Data Bindings是实现双向绑定的关键。DOM Listeners监听页面所有View层DOM元素的变化，当发生变化，Model层的数据随之变化；Data Bindings监听Model层的数据，当数据发生变化，View层的DOM元素随之变化。</p>
<p><img src="https://pic4.zhimg.com/80/v2-3bc814dcdad6fe27546c67faf1f7e8e7_1440w.jpg" alt="img" loading="lazy"></p>
<h1 id="网络安全"> 网络安全</h1>
<h2 id="xss-攻击"> <code>XSS</code> 攻击</h2>
<p><code>XSS</code> 攻击是指浏览器中执行恶意脚本, 然后拿到用户的信息进行操作。主要分为<code>存储型</code>、<code>反射型</code>和<code>文档型</code>。防范的措施包括:</p>
<ul>
<li>对输入内容过滤或者转码，尤其是类似于<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;a&gt;</code>标签</li>
<li>利用CSP</li>
<li>利用Cookie的HttpOnly属性</li>
</ul>
<p>除了以上策略之外，我们还可以通过添加验证码防止脚本冒充用户提交危险操作。而对于一些不受信任的输入，还可以限制其输入长度，这样可以增大 XSS 攻击的难度。</p>
<p>CSP，即浏览器中的内容安全策略，它的核心思想大概就是服务器决定浏览器加载哪些资源，具体来说有几个功能👇</p>
<ul>
<li>限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；</li>
<li>禁止向第三方域提交数据，这样用户数据也不会外泄；</li>
<li>提供上报机制，能帮助我们及时发现 XSS 攻击。</li>
<li>禁止执行内联脚本和未授权的脚本</li>
</ul>
<h2 id="csrf攻击"> CSRF攻击</h2>
<p>跟XSS对比的话，CSRF攻击并不需要将恶意代码注入HTML中，而是跳转新的页面，利用**「服务器的验证漏洞」<strong>和</strong>「用户之前的登录状态」**来模拟用户进行操作</p>
<p>CSRF(Cross-site request forgery), 即跨站请求伪造，本质是冲着浏览器分不清发起请求是不是真正的用户本人，所以防范的关键在于在请求中放入黑客所不能伪造的信息。从而防止黑客伪造一个完整的请求欺骗服务器。</p>
<p><strong>「防范措施」</strong>：验证码机制，验证来源站点，利用Cookie的SameSite属性，CSRF Token</p>
<h1 id="遇到的问题"> 遇到的问题</h1>
<h2 id="_1、element-ui-的el-table表格"> 1、element ui 的el-table表格</h2>
<p>现象：在el-table最后一列操作栏设置el-popover时，出现了多个el-popover</p>
<p>原因：element ui 的el-table表格的表头和其他定位元素，比如设置了fixed属性的列，他其实是多创建了一个table，隐藏了部分其他不需要的元素。通过看源码得知，从控制台验证。</p>
<p>解决：不设置fix：right，感觉是element的一个坑</p>
<h2 id="_2、swiper的兼容性问题。"> 2、swiper的兼容性问题。</h2>
<p>现象：用户在低版本安卓、ios系统打开app，网页页面空白</p>
<p>原因：1、第三方库swiper提供的是源码，es6语法的源码没有经过编译。</p>
<p>2、第三方库swiper的依赖库dom7也用了es6语法并且没有编译。</p>
<p>3、babel编译代码时会默认忽略node_modules里的依赖。</p>
<p>解决：1、确定了js文件是加载了但是vue代码没执行，获取到用户的浏览器版本是chrome51，专门去找了对应版本的浏览器，在windows虚拟机安装后复现出问题，确定是es6语法报错，并且开启测试服的sourcemap，找到对应语法所在的依赖就是swiper。</p>
<p>在项目配置里显示指定babel编译第三方依赖swiper。</p>
<p>2、之后尝试了一下ie浏览器发现可以查出语法报错问题，是dom7这个依赖的es6语法。</p>
<p>在项目配置里显示指定babel编译依赖dom7。</p>
<div><pre><code><span>transpileDependencies</span><span>:</span> <span>[</span> <span>"swiper"</span><span>,</span> <span>"dom7"</span> <span>]</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="_3、"> 3、</h2>
]]></content>
    <author>
      <name>xiechengyu</name>
    </author>
    <category term="面试"/>
    <contributor>
      <name>xiechengyu</name>
    </contributor>
    <published>2021-05-11T20:34:09.000Z</published>
    <rights>Copyright by xiechengyu</rights>
  </entry>
  <entry>
    <title type="html">需要手写的代码</title>
    <id>https://xiechengyu.github.io/interview/%E9%9C%80%E8%A6%81%E6%89%8B%E5%86%99%E7%9A%84%E4%BB%A3%E7%A0%81/</id>
    <link href="https://xiechengyu.github.io/interview/%E9%9C%80%E8%A6%81%E6%89%8B%E5%86%99%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    <updated>2022-06-15T08:27:26.000Z</updated>
    <summary type="html"><![CDATA[<h2 id="前言"> 前言</h2>
<p>面试准备中需要手写的代码</p>
]]></summary>
    <content type="html"><![CDATA[<h2 id="前言"> 前言</h2>
<p>面试准备中需要手写的代码</p>

<h1 id="promise"> promise</h1>
<div><pre><code><span>class</span> <span>MyPromise</span> <span>{</span>
  <span>constructor</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>callbacks <span>=</span> <span>[</span><span>]</span><span>;</span>
    <span>this</span><span>.</span>state <span>=</span> <span>"PENDING"</span><span>;</span>
    <span>this</span><span>.</span>value <span>=</span> <span>null</span><span>;</span>

    <span>fn</span><span>(</span><span>this</span><span>.</span><span>_resolve</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>,</span> <span>this</span><span>.</span><span>_reject</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>)</span><span>;</span>
  <span>}</span>

  <span>then</span><span>(</span><span>onFulfilled<span>,</span> onRejected</span><span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>MyPromise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span>
      <span>this</span><span>.</span><span>_handle</span><span>(</span><span>{</span>
        <span>onFulfilled</span><span>:</span> onFulfilled <span>||</span> <span>null</span><span>,</span>
        <span>onRejected</span><span>:</span> onRejected <span>||</span> <span>null</span><span>,</span>
        resolve<span>,</span>
        reject<span>,</span>
      <span>}</span><span>)</span>
    <span>)</span><span>;</span>
  <span>}</span>

  <span>catch</span><span>(</span>onRejected<span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span><span>then</span><span>(</span><span>null</span><span>,</span> onRejected<span>)</span><span>;</span>
  <span>}</span>

  <span>_handle</span><span>(</span><span>callback</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>this</span><span>.</span>state <span>===</span> <span>"PENDING"</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>callbacks<span>.</span><span>push</span><span>(</span>callback<span>)</span><span>;</span>

      <span>return</span><span>;</span>
    <span>}</span>

    <span>let</span> cb <span>=</span>
      <span>this</span><span>.</span>state <span>===</span> <span>"FULFILLED"</span> <span>?</span> callback<span>.</span>onFulfilled <span>:</span> callback<span>.</span>onRejected<span>;</span>
    <span>if</span> <span>(</span><span>!</span>cb<span>)</span> <span>{</span>
      cb <span>=</span> <span>this</span><span>.</span>state <span>===</span> <span>"FULFILLED"</span> <span>?</span> callback<span>.</span>resolve <span>:</span> callback<span>.</span>reject<span>;</span>
      <span>cb</span><span>(</span><span>this</span><span>.</span>value<span>)</span><span>;</span>

      <span>return</span><span>;</span>
    <span>}</span>

    <span>let</span> ret<span>;</span>

    <span>try</span> <span>{</span>
      ret <span>=</span> <span>cb</span><span>(</span><span>this</span><span>.</span>value<span>)</span><span>;</span>
      cb <span>=</span> <span>this</span><span>.</span>state <span>===</span> <span>"FULFILLED"</span> <span>?</span> callback<span>.</span>resolve <span>:</span> callback<span>.</span>reject<span>;</span>
    <span>}</span> <span>catch</span> <span>(</span>error<span>)</span> <span>{</span>
      ret <span>=</span> error<span>;</span>
      cb <span>=</span> callback<span>.</span>reject<span>;</span>
    <span>}</span> <span>finally</span> <span>{</span>
      <span>cb</span><span>(</span>ret<span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>

  <span>_resolve</span><span>(</span><span>value</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>value <span>&amp;&amp;</span> <span>(</span><span>typeof</span> value <span>===</span> <span>"object"</span> <span>||</span> <span>typeof</span> value <span>===</span> <span>"function"</span><span>)</span><span>)</span> <span>{</span>
      <span>let</span> then <span>=</span> value<span>.</span>then<span>;</span>

      <span>if</span> <span>(</span><span>typeof</span> then <span>===</span> <span>"function"</span><span>)</span> <span>{</span>
        <span>then</span><span>.</span><span>call</span><span>(</span>value<span>,</span> <span>this</span><span>.</span><span>_resolve</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>,</span> <span>this</span><span>.</span><span>_reject</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>)</span><span>;</span>
        <span>return</span><span>;</span>
      <span>}</span>
    <span>}</span>

    <span>this</span><span>.</span>state <span>===</span> <span>"FULFILLED"</span><span>;</span>
    <span>this</span><span>.</span>value <span>=</span> value<span>;</span>
    <span>this</span><span>.</span>callbacks<span>.</span><span>forEach</span><span>(</span><span>(</span><span>fn</span><span>)</span> <span>=></span> <span>this</span><span>.</span><span>_handle</span><span>(</span>fn<span>)</span><span>)</span><span>;</span>
  <span>}</span>

  <span>_reject</span><span>(</span><span>error</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>state <span>===</span> <span>"REJECTED"</span><span>;</span>
    <span>this</span><span>.</span>value <span>=</span> error<span>;</span>
    <span>this</span><span>.</span>callbacks<span>.</span><span>forEach</span><span>(</span><span>(</span><span>fn</span><span>)</span> <span>=></span> <span>this</span><span>.</span><span>_handle</span><span>(</span>fn<span>)</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>const</span> p1 <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>function</span> <span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>
  <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>reject</span><span>(</span><span>new</span> <span>Error</span><span>(</span><span>"fail"</span><span>)</span><span>)</span><span>,</span> <span>3000</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>const</span> p2 <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>function</span> <span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>
  <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>resolve</span><span>(</span>p1<span>)</span><span>,</span> <span>1000</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

p2<span>.</span><span>then</span><span>(</span><span>(</span><span>result</span><span>)</span> <span>=></span> console<span>.</span><span>log</span><span>(</span>result<span>)</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>(</span><span>error</span><span>)</span> <span>=></span> console<span>.</span><span>log</span><span>(</span>error<span>)</span><span>)</span><span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br></div></div><h1 id="浅克隆"> 浅克隆</h1>
<div><pre><code><span>function</span> <span>shallowClone</span><span>(</span><span>obj</span><span>)</span> <span>{</span>
  <span>let</span> cloneObj <span>=</span> <span>{</span><span>}</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>in</span> obj<span>)</span> <span>{</span>
    cloneObj<span>[</span>i<span>]</span> <span>=</span> obj<span>[</span>i<span>]</span><span>;</span>
  <span>}</span>
  <span>return</span> cloneObj<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h1 id="深克隆"> 深克隆</h1>
<ul>
<li>考虑基础类型</li>
<li>引用类型
<ul>
<li>RegExp、Date、函数 不是 JSON 安全的</li>
<li>会丢失 constructor，所有的构造函数都指向 Object</li>
<li>破解循环引用</li>
</ul>
</li>
</ul>
<div><pre><code><span>function</span> <span>deepCopy</span><span>(</span><span>obj</span><span>)</span> <span>{</span>
  <span>let</span> result <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>
  <span>if</span> <span>(</span><span>typeof</span> obj <span>===</span> <span>'object'</span><span>)</span> <span>{</span>
    result <span>=</span> obj<span>.</span>constructor <span>===</span> Array <span>?</span> <span>[</span><span>]</span> <span>:</span> <span>{</span><span>}</span><span>;</span>
    <span>for</span> <span>(</span><span>var</span> i <span>in</span> obj<span>)</span> <span>{</span>
      result<span>[</span>i<span>]</span> <span>=</span> <span>typeof</span> obj<span>[</span>i<span>]</span> <span>===</span> <span>'object'</span> <span>?</span> <span>deepCopy</span><span>(</span>obj<span>[</span>i<span>]</span><span>)</span> <span>:</span> obj<span>[</span>i<span>]</span><span>;</span>
    <span>}</span>
  <span>}</span> <span>else</span> <span>{</span>
    result <span>=</span> obj<span>;</span>
  <span>}</span>
  <span>return</span> result<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h1 id="curry"> curry</h1>
<div><pre><code><span>function</span> <span>createCurry</span><span>(</span><span>func<span>,</span> beforeRoundArg <span>=</span> <span>[</span><span>]</span></span><span>)</span> <span>{</span>
  <span>return</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>let</span> args <span>=</span> <span>[</span><span>...</span>beforeRoundArg<span>,</span> <span>...</span>arguments<span>]</span>
    <span>if</span> <span>(</span>args<span>.</span>length <span>&lt;</span> func<span>.</span>length<span>)</span> <span>{</span>
      <span>return</span> <span>createCurry</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> func<span>,</span> args<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>func</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> args<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h1 id="四种排序"> 四种排序</h1>
<h2 id="选择排序"> <strong>选择排序</strong></h2>
<p>平均时间复杂度O（n2）</p>
<p>空间复杂度O（1）（用于交换时作为临时变量）</p>
<p>算法描述：</p>
<p>第一次遍历所有的元素，找出最小的那个放在一号位上</p>
<p>第二次遍历n-1次，找出剩余元素中最小的那个放在二号位上</p>
<p>以此类推。。。。。。</p>
<div><pre><code><span>function</span> <span>selectSort</span><span>(</span><span>arr</span><span>)</span><span>{</span>
    <span>if</span><span>(</span><span>!</span>Array<span>.</span><span>isArray</span><span>(</span>arr<span>)</span><span>)</span> <span>return</span><span>;</span>
    <span>//临时变量</span>
    <span>let</span> temp<span>;</span>
    <span>for</span><span>(</span><span>let</span> i<span>=</span><span>0</span><span>,</span> len<span>=</span>arr<span>.</span>length<span>;</span> i<span>&lt;</span>len<span>-</span><span>1</span><span>;</span> i<span>++</span><span>)</span><span>{</span>
        <span>for</span><span>(</span><span>let</span> j<span>=</span>i<span>+</span><span>1</span><span>;</span> j<span>&lt;</span>len<span>;</span> j<span>++</span><span>)</span><span>{</span>
            <span>if</span><span>(</span>arr<span>[</span>i<span>]</span><span>></span>arr<span>[</span>j<span>]</span><span>)</span><span>{</span>
                temp <span>=</span> arr<span>[</span>i<span>]</span><span>;</span>
                arr<span>[</span>i<span>]</span> <span>=</span> arr<span>[</span>j<span>]</span><span>;</span>
                arr<span>[</span>j<span>]</span> <span>=</span> temp<span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> arr<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="冒泡排序"> 冒泡排序：</h2>
<p>平均时间复杂度O（n2）</p>
<p>空间复杂度O（1）（用于交换时作为临时变量）</p>
<p>算法描述：</p>
<p>选择相邻的两个数两两进行比较，小的那个数一直往前冒，这样就可以在第一轮找到最小的那个数</p>
<p>接着在剩下的数中重复上述操作。。。。。。</p>
<div><pre><code><span>function</span> <span>bubbleSort</span><span>(</span><span>arr</span><span>)</span><span>{</span>
    <span>if</span><span>(</span><span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span>arr<span>)</span><span>.</span><span>slice</span><span>(</span><span>8</span><span>,</span><span>-</span><span>1</span><span>)</span> <span>!=</span> <span>"Array"</span><span>)</span> <span>return</span><span>;</span>
    <span>// 临时变量</span>
    <span>let</span> temp<span>;</span>
    <span>for</span><span>(</span><span>let</span> i<span>=</span><span>0</span><span>,</span> len<span>=</span>arr<span>.</span>length<span>;</span> i<span>&lt;</span>len<span>-</span><span>2</span><span>;</span> i<span>++</span><span>)</span><span>{</span>
        <span>for</span><span>(</span><span>let</span> j<span>=</span>len<span>-</span><span>1</span><span>;</span> j<span>></span>i<span>;</span> j<span>--</span><span>)</span><span>{</span>
            <span>if</span><span>(</span>arr<span>[</span>j<span>]</span><span>&lt;</span>arr<span>[</span>j<span>-</span><span>1</span><span>]</span><span>)</span><span>{</span>
                temp <span>=</span> arr<span>[</span>j<span>]</span><span>;</span>
                arr<span>[</span>j<span>]</span> <span>=</span> arr<span>[</span>j<span>-</span><span>1</span><span>]</span><span>;</span>
                arr<span>[</span>j<span>-</span><span>1</span><span>]</span> <span>=</span> temp<span>;</span> 
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> arr<span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="快速排序"> 快速排序</h2>
<p>平均时间复杂度：O(n*logn2n)</p>
<p>空间复杂度：O(log2n)~O(n)</p>
<p>算法描述：</p>
<p>1．先从数列中取出一个数作为基准数。</p>
<p>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</p>
<p>3．再对左右区间重复第二步，直到各区间只有一个数。</p>
<p>start和end分别指向数组的第一个元素后最后一个元素</p>
<p>首先让数组的第一个元素作为基准数，这样一号位就空出来了，首先从后往前找一个小于基准数的元素，然后填入一号为</p>
<p>接着从前往后找一个大于基准数的元素填入刚才填入一号位的那个元素的位置</p>
<p>以此类推直到start等于end为止，最后把基准数存入数组的start或者end位置</p>
<p>第一轮过后比第一个数大的元素都在他的右边比他小的都在左边，接着就是分别对所有的数组进行递归操作</p>
<div><pre><code> <span>function</span> <span>quickSort</span><span>(</span><span>arr<span>,</span> start<span>,</span> end</span><span>)</span> <span>{</span>
        <span>if</span><span>(</span>start <span>>=</span> end<span>)</span> <span>return</span><span>;</span>
        <span>let</span> i <span>=</span> start<span>,</span> j <span>=</span> end<span>,</span> k <span>=</span> arr<span>[</span>start<span>]</span><span>;</span>
        <span>while</span> <span>(</span>i <span>&lt;</span> j<span>)</span> <span>{</span>
            <span>//从后往前找</span>
            <span>while</span> <span>(</span>i <span>&lt;</span> j <span>&amp;&amp;</span> k <span>&lt;</span> arr<span>[</span>j<span>]</span><span>)</span> <span>{</span>
                j<span>--</span><span>;</span>
            <span>}</span>
            <span>//排除i==j跳出循环的情况</span>
            <span>if</span> <span>(</span>i<span>&lt;</span>j<span>)</span> <span>{</span>
                arr<span>[</span>i<span>++</span><span>]</span> <span>=</span> arr<span>[</span>j<span>]</span><span>;</span>
            <span>}</span>
            <span>// 从前往后找</span>
           <span>while</span><span>(</span>i<span>&lt;</span>j <span>&amp;&amp;</span> k <span>>=</span>arr<span>[</span>i<span>]</span><span>)</span><span>{</span>
               i<span>++</span><span>;</span>
           <span>}</span>
           <span>//排除i==j跳出循环的情况</span>
           <span>if</span><span>(</span>i <span>&lt;</span> j<span>)</span><span>{</span>
               arr<span>[</span>j<span>--</span><span>]</span> <span>=</span> arr<span>[</span>i<span>]</span><span>;</span> 
           <span>}</span>
        <span>}</span>
        arr<span>[</span>i<span>]</span> <span>=</span> k<span>;</span>
        <span>quickSort</span><span>(</span>arr<span>,</span> start<span>,</span> i<span>-</span><span>1</span><span>)</span><span>;</span>
        <span>quickSort</span><span>(</span>arr<span>,</span> i<span>+</span><span>1</span><span>,</span> end<span>)</span><span>;</span>
        <span>return</span> arr<span>;</span>
    <span>}</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h2 id="插入排序"> 插入排序</h2>
<p>平均时间复杂度：O(n2)</p>
<p>空间复杂度：O(n2)</p>
<p>算法描述：</p>
<p>插入即表示将一个新的数据插入到一个有序数组中，并继续保持有序。</p>
<p>例如有一个长度为N的无序数组，进行N-1次的插入即能完成排序；</p>
<p>第一次，数组第1个数认为是有序的数组，将数组第二个元素插入仅有1个有序的数组中；</p>
<p>第二次，数组前两个元素组成有序的数组，将数组第三个元素插入由两个元素构成的有序数组中</p>
<p>......</p>
<p>第N-1次，数组前N-1个元素组成有序的数组，将数组的第N个元素插入由N-1个元素构成的有序数组中，则完成了整个插入排序。</p>
<div><pre><code>  <span>function</span> <span>insertSort</span><span>(</span><span>arr</span><span>)</span><span>{</span>
        <span>//从一号位开始执行插入排序，因为0号位元素可以直接当成有序数</span>
        <span>for</span><span>(</span><span>let</span> i<span>=</span><span>1</span><span>,</span>len<span>=</span>arr<span>.</span>length<span>;</span> i<span>&lt;</span>len<span>;</span> i<span>++</span><span>)</span><span>{</span>
            <span>// 用于遍历已经有序的数组</span>
            <span>let</span> j<span>=</span><span>0</span><span>;</span>
            <span>while</span><span>(</span>j<span>&lt;</span>i <span>&amp;&amp;</span> arr<span>[</span>j<span>]</span> <span>&lt;</span> arr<span>[</span>i<span>]</span><span>)</span><span>{</span>
                    j<span>++</span><span>;</span>
            <span>}</span>
            <span>//排除j==i跳出循环的情况</span>
            <span>if</span><span>(</span>j<span>&lt;</span>i<span>)</span><span>{</span>
                <span>//插入a[i]</span>
                arr<span>.</span><span>splice</span><span>(</span>j<span>,</span><span>0</span><span>,</span>arr<span>[</span>i<span>]</span><span>)</span><span>;</span>
                <span>//删除a[i],注意插入arr[i]后数组多了一个元素</span>
                arr<span>.</span><span>splice</span><span>(</span>i<span>+</span><span>1</span><span>,</span><span>1</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> arr<span>;</span>
    <span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h1 id="二分查找"> 二分查找</h1>
<p>思想是找到中间值下标，如果输入值未中间值则输出中间值索引，如果输入值小于中间值则将当前中间值变为末尾下标继续二分查找，如果输入值大于中间值则将当前中间值变为初始下标继续二分查找。可以循环，可以递归。</p>
<div><pre><code><span>//循环</span>
<span>function</span> <span>binarySearch</span><span>(</span><span>arr<span>,</span> sel</span><span>)</span> <span>{</span>
  <span>//首先确定首、尾下标</span>
  <span>var</span> low <span>=</span> <span>0</span><span>;</span>
  <span>var</span> high <span>=</span> arr<span>.</span>length <span>-</span> <span>1</span><span>;</span>
  <span>while</span> <span>(</span>low <span>&lt;=</span> high<span>)</span> <span>{</span> <span>//只要查找区间起始点和结束点中间还有值(要包括两值相同的情况)，我们就继续进行查找</span>
    <span>var</span> mid <span>=</span> <span>(</span>low <span>+</span> high<span>)</span> <span>/</span> <span>2</span><span>;</span> <span>//确定中间值下标</span>
    <span>if</span> <span>(</span>sel <span>==</span> arr<span>[</span>mid<span>]</span><span>)</span> <span>{</span> <span>//如果查找值等于中间值</span>
      <span>return</span> mid  <span>//则这个mid值，就是查找到的数组下标</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>sel <span>&lt;</span> arr<span>[</span>mid<span>]</span><span>)</span> <span>{</span> <span>//如果查找值小于中间值</span>
      high <span>=</span> mid <span>-</span> <span>1</span><span>;</span> <span>//则在左半部分查找，需要重新确认区间high的位置</span>
    <span>}</span> <span>else</span> <span>{</span> <span>//否则查找值大于中间值</span>
      low <span>=</span> mid <span>+</span> <span>1</span> <span>//则在右半部分查找，需要重新确认区间low的位置</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>-</span><span>1</span><span>//查找完都没有查找到，就退出</span>
<span>}</span>
<span>var</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>]</span><span>;</span>
<span>var</span> sel <span>=</span> <span>7</span><span>;</span>
<span>var</span> index <span>=</span> <span>binarySearch</span><span>(</span>arr<span>,</span> sel<span>)</span>
console<span>.</span><span>log</span><span>(</span><span>"查找下标为："</span> <span>+</span> index<span>)</span>

<span>//递归</span>
<span>function</span> <span>binary_search2</span><span>(</span><span>arr<span>,</span> low<span>,</span> high<span>,</span> key</span><span>)</span> <span>{</span>
	<span>if</span><span>(</span>low <span>></span> high<span>)</span> <span>{</span>
		<span>return</span> <span>-</span><span>1</span><span>;</span>
	<span>}</span>
	<span>var</span> mid <span>=</span> <span>parseInt</span><span>(</span><span>(</span>high <span>+</span> low<span>)</span> <span>/</span> <span>2</span><span>)</span><span>;</span>
	<span>if</span><span>(</span>arr<span>[</span>mid<span>]</span> <span>==</span> key<span>)</span> <span>{</span>
		<span>return</span> mid<span>;</span>
	<span>}</span> <span>else</span> <span>if</span><span>(</span>arr<span>[</span>mid<span>]</span> <span>></span> key<span>)</span> <span>{</span>
		high <span>=</span>mid <span>-</span><span>1</span><span>;</span>
		<span>return</span> <span>binary_search2</span><span>(</span>arr<span>,</span> low<span>,</span> high<span>,</span> key<span>)</span><span>;</span>
	<span>}</span> <span>else</span> <span>if</span><span>(</span>arr<span>[</span>mid<span>]</span> <span>&lt;</span> key<span>)</span> <span>{</span>
		low <span>=</span> mid <span>+</span><span>1</span><span>;</span>
		<span>return</span> <span>binary_search2</span><span>(</span>arr<span>,</span> low<span>,</span> high<span>,</span> key<span>)</span><span>;</span>
	<span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><h1 id="节流"> 节流</h1>
<p>节流的意思是让函数有节制地执行，而不是毫无节制的触发一次就执行一次。什么叫有节制呢？就是在一段时间内，只执行一次。</p>
<p>规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</p>
<div><pre><code><span>function</span> <span>throttle</span><span>(</span><span>fn<span>,</span> delay</span><span>)</span> <span>{</span>
  <span>let</span> flag <span>=</span> <span>true</span>
  <span>let</span> timer <span>=</span> <span>null</span>
  <span>return</span> <span>function</span> <span>(</span><span><span>...</span>args</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>flag<span>)</span> <span>return</span>
    flag <span>=</span> <span>false</span>
    <span>clearTimeout</span><span>(</span>timer<span>)</span>
    timer <span>=</span> <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
      <span>fn</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> args<span>)</span>
      flag <span>=</span> <span>true</span>
    <span>}</span><span>,</span> delay<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h1 id="防抖"> 防抖</h1>
<p>在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</p>
<div><pre><code><span>function</span> <span>debounce</span><span>(</span><span>fn<span>,</span> delay</span><span>)</span> <span>{</span>
  <span>let</span> timer <span>=</span> <span>null</span>
  <span>return</span> <span>function</span> <span>(</span><span><span>...</span>args</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>timer<span>)</span> <span>clearTimeout</span><span>(</span>timer<span>)</span>
    timer <span>=</span> <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
      <span>fn</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> args<span>)</span>
    <span>}</span><span>,</span> delay<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h1 id="call"> call</h1>
<div><pre><code><span>Function</span><span>.</span>prototype<span>.</span><span>myCall</span> <span>=</span> <span>function</span> <span>(</span><span>obj<span>,</span> <span>...</span>args</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>obj <span>==</span> <span>undefined</span> <span>||</span> obj <span>==</span> <span>null</span><span>)</span> <span>{</span>
    obj <span>=</span> globalThis
  <span>}</span>
  obj<span>.</span>fn <span>=</span> <span>this</span>
  <span>let</span> res <span>=</span> obj<span>.</span><span>fn</span><span>(</span><span>...</span>args<span>)</span>
  <span>delete</span> obj<span>.</span>fn
  <span>return</span> res
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h1 id="apply"> apply</h1>
<div><pre><code><span>Function</span><span>.</span>prototype<span>.</span><span>myAplly</span> <span>=</span> <span>function</span> <span>(</span><span>obj<span>,</span> arr</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>obj <span>==</span> <span>undefined</span> <span>||</span> obj <span>==</span> <span>null</span><span>)</span> <span>{</span>
    obj <span>=</span> globalThis
  <span>}</span>
  obj<span>.</span>fn <span>=</span> <span>this</span>
  <span>let</span> res <span>=</span> obj<span>.</span><span>fn</span><span>(</span><span>...</span>arr<span>)</span>
  <span>delete</span> obj<span>.</span>fn
  <span>return</span> res
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h1 id="bind"> bind</h1>
<div><pre><code><span>Function</span><span>.</span>prototype<span>.</span><span>myBind</span> <span>=</span> <span>function</span> <span>(</span><span>obj<span>,</span> <span>...</span>args</span><span>)</span> <span>{</span>
  <span>let</span> that <span>=</span> <span>this</span>
  <span>let</span> <span>fn</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>this</span> <span>instanceof</span> <span>fn</span><span>)</span> <span>{</span>
      <span>return</span> <span>new</span> <span>that</span><span>(</span><span>...</span>args<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>return</span> <span>that</span><span>.</span><span>call</span><span>(</span>obj<span>,</span> <span>...</span>args<span>)</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> fn
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h1 id="new"> new</h1>
<div><pre><code><span>function</span> <span>newInstance</span> <span>(</span><span>Fn<span>,</span> <span>...</span>args</span><span>)</span> <span>{</span>
  <span>const</span> obj <span>=</span> <span>{</span><span>}</span>
  obj<span>.</span>__proto__ <span>=</span> <span>Fn</span><span>.</span>prototype
  <span>const</span> result <span>=</span> <span>Fn</span><span>.</span><span>call</span><span>(</span>obj<span>,</span> <span>...</span>args<span>)</span>
  <span>// 如果Fn返回的是一个对象类型, 那返回的就不再是obj, 而是Fn返回的对象否则返回obj</span>
  <span>return</span> result <span>instanceof</span> <span>Object</span> <span>?</span> result <span>:</span> obj
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h1 id="eventbus实现"> eventBus实现</h1>
<div><pre><code> <span>class</span> <span>Bus</span> <span>{</span>
  <span>constructor</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>callbacks <span>=</span> <span>{</span><span>}</span>
  <span>}</span>
  <span>$on</span><span>(</span><span>name<span>,</span> fn</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>callbacks<span>[</span>name<span>]</span> <span>=</span> <span>this</span><span>.</span>callbacks<span>[</span>name<span>]</span> <span>||</span> <span>[</span><span>]</span>
    <span>this</span><span>.</span>callbacks<span>[</span>name<span>]</span><span>.</span><span>push</span><span>(</span>fn<span>)</span>
  <span>}</span>
  <span>$emit</span><span>(</span><span>name<span>,</span> args</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>this</span><span>.</span>callbacks<span>[</span>name<span>]</span><span>)</span> <span>{</span>
      <span>//存在遍历所有callback</span>
      <span>this</span><span>.</span>callbacks<span>[</span>name<span>]</span><span>.</span><span>forEach</span><span>(</span><span>cb</span> <span>=></span> <span>cb</span><span>(</span>args<span>)</span><span>)</span>
    <span>}</span>
  <span>}</span>
  <span>$off</span><span>(</span><span>name</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>this</span><span>.</span>callbacks<span>[</span>name<span>]</span><span>)</span> <span>{</span>
      <span>delete</span> <span>(</span><span>this</span><span>.</span>callbacks<span>[</span>name<span>]</span><span>)</span>
    <span>}</span>
  <span>}</span>
  <span>$once</span><span>(</span><span>name<span>,</span> fn</span><span>)</span> <span>{</span>
    <span>const</span> <span>fns</span> <span>=</span> <span>(</span><span>args</span><span>)</span> <span>=></span> <span>{</span>
      <span>fn</span><span>(</span>args<span>)</span>
      <span>this</span><span>.</span><span>$off</span><span>(</span>name<span>)</span>
    <span>}</span>
    <span>this</span><span>.</span><span>$on</span><span>(</span>name<span>,</span> fns<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div>]]></content>
    <author>
      <name>xiechengyu</name>
    </author>
    <category term="面试"/>
    <contributor>
      <name>xiechengyu</name>
    </contributor>
    <published>2021-10-21T18:09:32.000Z</published>
    <rights>Copyright by xiechengyu</rights>
  </entry>
  <entry>
    <title type="html">面经</title>
    <id>https://xiechengyu.github.io/interview/%E9%9D%A2%E7%BB%8F/</id>
    <link href="https://xiechengyu.github.io/interview/%E9%9D%A2%E7%BB%8F/"/>
    <updated>2022-06-20T02:57:22.000Z</updated>
    <summary type="html"><![CDATA[<h2 id="前言"> 前言</h2>
<p>前同事面试经历，借此参考学习</p>
]]></summary>
    <content type="html"><![CDATA[<h2 id="前言"> 前言</h2>
<p>前同事面试经历，借此参考学习</p>

<p>一面:</p>
<ol>
<li>事件冒泡 捕获</li>
</ol>
<div><pre><code>
</code></pre>
<div><span>1</span><br></div></div><ol start="2">
<li>webpack 构建流程 compile和compilation对象区别</li>
<li>es6的继承和es5的继承区别</li>
<li>vue的双向绑定实现</li>
<li>http协议相关(http2 http1.1 http缓存)</li>
<li>js parse  json to dom</li>
<li>正则 捕获.....</li>
<li>计算树的总路径</li>
<li>快速排序 时间复杂度和空间负责度</li>
<li>gnerator async await</li>
<li>手写Promise.all</li>
<li>webpack loader和plugin区别 自己简单写一个loader</li>
<li>computed和watch区别</li>
<li>为什么会出现跨域? 跨域解决方案 浏览器有安全策略
<ol>
<li>jsonp(script=&quot;http://www.baidu.com?callback=test&quot;)</li>
<li>nginx</li>
<li>Acess-control-origin: *</li>
<li>websocket</li>
<li>domain + iframe</li>
</ol>
</li>
</ol>
<p>二面</p>
<ol>
<li>柯里化</li>
<li>状态机</li>
<li>项目 足够了解 优化方案</li>
</ol>
<p>快⼿
⼀⾯</p>
<ol>
<li>Symbol</li>
<li>Promise、Promise.all、Promise then的第⼆个参数和catch执⾏顺序、async、await</li>
<li>gnerator</li>
<li>⼩程序直播</li>
<li>⼩程序执⾏机制</li>
<li>合并两个有序数组</li>
</ol>
<p>⼆⾯</p>
<ol>
<li>闭包</li>
<li>观察者模式 事件管理类的定义</li>
<li>事件触发的最⼩时间间隔</li>
<li>ES6常⽤特性 promise/map/set/symbol</li>
<li>promise aysnc/await</li>
<li>代码输出顺序</li>
<li>算法题，m*n矩阵⾛法</li>
</ol>
<p>三⾯</p>
<ol>
<li>描述直播⽅案</li>
<li>直播⽅案优缺点</li>
<li>直播⽅案改进点</li>
<li>webrtc</li>
<li>教师端监控⽅式</li>
<li>crash时如何监控</li>
<li>如何排查⽼师问题</li>
</ol>
<p>字节
⼀⾯</p>
<ol>
<li>事件冒泡和捕获</li>
<li>⾃⼰定dom的事件冒泡和捕获是否都能实现</li>
<li>浏览器的Event Loop和Node的Event Loop区别</li>
<li>为什么需要Event Loop</li>
<li>你了解vue的源码部分</li>
<li>vue computed和watch区别，做了哪些性能优化</li>
<li>说⼀下如果把python转换成js代码，让你实现如何实现</li>
<li>实现js的parser思路</li>
<li>⼿动实现trim函数</li>
<li>webworker</li>
</ol>
<p>⼆⾯</p>
<ol>
<li>webpack模块加载和编译模块思路</li>
<li>⼿写实现⼀个domtojson</li>
<li>⼿写实现⼀个www.bytedance.com反转成com.bytedance.www，不能使⽤字符串api，时间复杂度和 空间复杂度尽可能低</li>
</ol>
<p>三⾯</p>
<ol>
<li>状态机</li>
<li>展示github项⽬HappyCode聊了聊状态机</li>
<li>展示博客⼀篇⽂章聊了聊思路和实现</li>
<li>说说你了解的编译过程</li>
</ol>
<p>美团
⼀⾯</p>
<ol>
<li>介绍项⽬</li>
<li>Promise、Promise.race、Promise.any</li>
<li>var A = {}; var B = function(){}; // A.proto === ? // B.proto === ?</li>
<li>实现Abc123Def转换为abc123-def的函数</li>
<li>list = [{data:['a','b','c']},1, [2, [3, 4, 5]], 6]转成['a', 'b', 'c', 1, 2, 3, 4, 5, 6]</li>
<li>ts泛型</li>
<li>webcomponent和微前端</li>
</ol>
<p>⼆⾯</p>
<ol>
<li>介绍项⽬</li>
<li>介绍难点</li>
<li>聊聊wasm</li>
<li>回⽅阵 给定⼤⼩，以螺旋顺序返回数字的⽅阵. 矩阵应填充⾃然数字，从左上⻆的 1 开始，以向内，顺时针螺旋顺序增加，如下例所示: ⼤⼩为 3 的螺旋矩阵： 1 2 3 8 9 4 7 6 5 尺⼨为 4 的螺旋矩阵： 1 2 3 4 12 13 14 5 11 16 15 6 10 9 8 7</li>
</ol>
<p>百度
⼀⾯</p>
<ol>
<li>聊聊写的github项⽬betterwebworker</li>
<li>说⼀下⼀个线程你如何调度它的优先级</li>
<li>说⼀下betterwebworker项⽬亮点</li>
<li>说⼀下使⽤ts好处</li>
<li>说⼀下你是跟组内协作的</li>
<li>https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/ 7
. https://leetcode-cn.com/problems/n-th-tribonacci-number/</li>
<li>⼿写Promise.all实现</li>
</ol>
<p>⼆⾯</p>
<ol>
<li>说说微前端</li>
<li>说⼀下generator</li>
<li>主要⾯了很多场景题，都是结合⼀下业务的</li>
</ol>
<p>三⾯</p>
<ol>
<li>主要聊职业规划和团队这个是技术经理⾯，没问什么难点</li>
<li>⼿写了⼀个求1-100所有素数函数</li>
</ol>
<p>四⾯</p>
<ol>
<li>主要说你做的业务有没有兴趣 五⾯还没⾯。。</li>
</ol>
<p>⼩⽶
⼀⾯</p>
<ol>
<li>es6 class</li>
<li>es5 function</li>
<li>call apply bind</li>
<li>reduce</li>
<li>⼿写实现⼀个map函数</li>
<li>Promise</li>
<li>将两个反向存储在链表中的整数求和（即整数的个位存放在了链表⾸部，⼀位数对应⼀个节点），返 回的结果仍⽤链表形式。 给定两个链表ListNode* A，ListNode* B，请返回A+B的结果(ListNode*)。 {1,2,3},{3,2,1} 返回：{4,4,4}</li>
</ol>
<p>⼆⾯没⾯让我取消了</p>
<p>Tubi
⼀⾯</p>
<ol>
<li>场景题，25分钟写⼀个⼩项⽬</li>
<li>⼀些场景你设计的思路</li>
</ol>
<p>⼆⾯</p>
<ol>
<li>场景题，30分钟写⼀个⼩项⽬</li>
<li>场景题，30分钟写⼀个⼩项⽬，考察点vue、防抖、节流、lru算法</li>
</ol>
<p>UMU
⼀⾯</p>
<ol>
<li>如何⽐较两个css⽂件不同</li>
<li>如何写⼀个css parser</li>
<li>你是如何理解this的</li>
<li>你是如何理解作⽤域和上下⽂的</li>
<li>编程可以不使⽤this嘛</li>
<li>聊聊你们直播⽅案</li>
<li>聊聊如何⽐较两个链表不同</li>
<li>⼿写diff两颗树不同</li>
</ol>
<p>⼆⾯</p>
<ol>
<li>⼿写查找⼀个字符串中第⼀个只出现⼀次的字符</li>
<li>聊聊你平常⼯作模式</li>
</ol>
<p>美团
一面</p>
<ol>
<li>
<p>数组降维 递归实现</p>
</li>
<li>
<p>parse</p>
<div><pre><code>&lt;div&gt;hello,{{person.name}}&lt;/div&gt;’ person.name =&#39;jerry&#39; return &lt;div&gt;hello,jerry&lt;/div&gt;
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>webpack complier 和complation区别</p>
</li>
<li>
<p>json to dom</p>
</li>
<li>
<p>eventLoop</p>
</li>
<li>
<p>vue-loader</p>
</li>
<li>
<p>webpack构建流程</p>
</li>
<li>
<p>快速排序(二分法)时间复杂度</p>
</li>
<li>
<p>进程间的通信(ipc)</p>
</li>
</ol>
<p>二面</p>
<ol>
<li>遍历二叉树</li>
<li>网络安全xss,csrf,如何预防</li>
<li>跨域,如何解决</li>
<li>option请求作用,什么是简单,复杂请求</li>
<li>[1,2,4,3,2,1] 找出只出现一次且最大的那个值(只遍历一次)</li>
<li>合并两个有序数组,时间复杂度O(m+n);</li>
<li>require和import, 以及webpack编译import是如何转换的</li>
<li>webgl渲染流程</li>
</ol>
<p>三面</p>
<ol>
<li>项目问的比较细</li>
<li>Memory cache 和disk cache场景,什么时候会走哪个</li>
<li>http缓存</li>
<li>Cookie 和localstorage</li>
<li>最近在读什么书</li>
</ol>
<p>阿里-高德
一面</p>
<ol>
<li>直播方案</li>
<li>sdk的设计思路</li>
<li>replace 几个参数的类型</li>
<li>快速排序的实现及复杂度</li>
<li>vue-router vuex 怎么引入</li>
<li>实现拖拽的思路</li>
<li>websocket实时聊天的优化</li>
<li>正则的捕获</li>
</ol>
<p>二面(之后取消了)</p>
<ol>
<li>vue知道哪些源码并实现(我说的双向绑定)</li>
<li>vue注入依赖阶段说一下</li>
<li>页面离开后如果日志上报失败该怎么办</li>
<li>Var str = ‘aabbccddeaa’;找出只出现一次的值尽可能时间复杂度低</li>
<li>Var str = ‘aabbccddeaa’ 输出🤔a2b2c2d2e1a2</li>
</ol>
<p>网易
一面</p>
<ol>
<li>axios 如何取消请求</li>
<li>git rebase</li>
<li>electron进程间通信</li>
<li>webpack构建依赖的常用loader plugin以及具体作用</li>
<li>http1.1 和http2.0区别</li>
<li>MediaSource作用</li>
<li>vue2 和vue3区别</li>
<li>code: 百钱买百鸡</li>
</ol>
<p>二面(挂了)</p>
<ol>
<li>vue watch和computed场景题 (这个操蛋,把我绕晕了)</li>
<li>Canvas 渲染优化手段</li>
<li>canvas和webgl的优缺点</li>
<li>为什么canvas渲染会卡顿</li>
<li>事件捕获和冒泡的场景题(还涉及到阻止冒泡和阻止默认行为)</li>
</ol>
<p>字节
一面(挂了,我怀疑是我改时间到晚上8点导致这哥们不高兴了,面了1个半小时)</p>
<ol>
<li>http2.0和http1.1区别(涉及到头部压缩Hpack算法原理,多路复用的原理)</li>
<li>position每个值的作用(相对于哪些元素脱离文档流)</li>
<li>Rem, em, vw,vh</li>
<li>跨域(出现,解决及原理)</li>
<li>网络安全(xss,csrf原理及防御)</li>
<li>webgl为什么比canvas性能更优</li>
<li>讲下yuv比rgb数据小的原因</li>
<li>盒模型</li>
<li>vue的数据双向绑定原理</li>
<li>讲讲vuex</li>
<li>Vue-router的有哪几种导航</li>
<li>sendBecon的好处</li>
<li>快速排序的时间复杂度及空间复杂度</li>
<li>浏览器eventLoop和node eventLoop</li>
<li>Node下fs模块 readFIle,writeFile的实现原理</li>
<li>Electron remote模块讲一下</li>
<li>为什么项目要选择音频和视频分开这种方案</li>
</ol>
<p>腾讯
一面</p>
<ol>
<li>webpack流程</li>
<li>loader和plugin区别</li>
<li>写个简单的loader</li>
<li>白屏,首屏domReady,时间怎么计算</li>
<li>如何优化白屏时间</li>
<li>http缓存</li>
<li>Vue3为什么打包后比vue2体积小</li>
</ol>
<p>二面</p>
<ol>
<li>https和http区别</li>
<li>ssl的流程</li>
<li>Es6继承和es5继承的区别</li>
<li>正则相关题</li>
<li>防抖和节流</li>
<li>讲讲web worker</li>
<li>如何代码设置不缓存</li>
</ol>
<p>三面</p>
<ol>
<li>聊聊项目</li>
<li>职业规划</li>
<li>输入url发生了什么</li>
</ol>
]]></content>
    <author>
      <name>xiechengyu</name>
    </author>
    <category term="面试"/>
    <contributor>
      <name>xiechengyu</name>
    </contributor>
    <published>2022-06-15T15:53:23.000Z</published>
    <rights>Copyright by xiechengyu</rights>
  </entry>
  <entry>
    <title type="html">初识typescript</title>
    <id>https://xiechengyu.github.io/learn/%E5%88%9D%E8%AF%86typescript/</id>
    <link href="https://xiechengyu.github.io/learn/%E5%88%9D%E8%AF%86typescript/"/>
    <updated>2022-06-19T09:00:10.000Z</updated>
    <summary type="html"><![CDATA[<h2 id="前言"> 前言</h2>
<p>在学习vue3.0的过程中，发现typescript的重要性，专门抽出时间仔细学习一下。</p>
<p>参考文档：<a href="https://www.tslang.cn/docs/handbook/basic-types.html" target="_blank" rel="noopener noreferrer">地址</a></p>
]]></summary>
    <content type="html"><![CDATA[<h2 id="前言"> 前言</h2>
<p>在学习vue3.0的过程中，发现typescript的重要性，专门抽出时间仔细学习一下。</p>
<p>参考文档：<a href="https://www.tslang.cn/docs/handbook/basic-types.html" target="_blank" rel="noopener noreferrer">地址</a></p>

<h2 id="与js的区别"> 与js的区别</h2>
<h3 id="基础类型"> 基础类型</h3>
<h4 id="元组-tuple"> 元组 Tuple</h4>
<p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 <code>string</code>和<code>number</code>类型的元组。</p>
<div><pre><code><span>// Declare a tuple type</span>
<span>let</span> x<span>:</span> <span>[</span><span>string</span><span>,</span> <span>number</span><span>]</span><span>;</span>
<span>// Initialize it</span>
x <span>=</span> <span>[</span><span>'hello'</span><span>,</span> <span>10</span><span>]</span><span>;</span> <span>// OK</span>
<span>// Initialize it incorrectly</span>
x <span>=</span> <span>[</span><span>10</span><span>,</span> <span>'hello'</span><span>]</span><span>;</span> <span>// Error</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>当访问一个已知索引的元素，会得到正确的类型：</p>
<div><pre><code><span>console</span><span>.</span><span>log</span><span>(</span>x<span>[</span><span>0</span><span>]</span><span>.</span><span>substr</span><span>(</span><span>1</span><span>)</span><span>)</span><span>;</span> <span>// OK</span>
<span>console</span><span>.</span><span>log</span><span>(</span>x<span>[</span><span>1</span><span>]</span><span>.</span><span>substr</span><span>(</span><span>1</span><span>)</span><span>)</span><span>;</span> <span>// Error, 'number' does not have 'substr'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>当访问一个越界的元素，会使用联合类型替代：</p>
<div><pre><code>x<span>[</span><span>3</span><span>]</span> <span>=</span> <span>'world'</span><span>;</span> <span>// OK, 字符串可以赋值给(string | number)类型</span>

<span>console</span><span>.</span><span>log</span><span>(</span>x<span>[</span><span>5</span><span>]</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// OK, 'string' 和 'number' 都有 toString</span>

x<span>[</span><span>6</span><span>]</span> <span>=</span> <span>true</span><span>;</span> <span>// Error, 布尔不是(string | number)类型</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="枚举"> 枚举</h4>
<p><code>enum</code>类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>
<div><pre><code><span>enum</span> Color <span>{</span>Red<span>,</span> Green<span>,</span> Blue<span>}</span>
<span>let</span> c<span>:</span> Color <span>=</span> Color<span>.</span>Green<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>默认情况下，从<code>0</code>开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 <code>1</code>开始编号：</p>
<div><pre><code><span>enum</span> Color <span>{</span>Red <span>=</span> <span>1</span><span>,</span> Green<span>,</span> Blue<span>}</span>
<span>let</span> c<span>:</span> Color <span>=</span> Color<span>.</span>Green<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>或者，全部都采用手动赋值：</p>
<div><pre><code><span>enum</span> Color <span>{</span>Red <span>=</span> <span>1</span><span>,</span> Green <span>=</span> <span>2</span><span>,</span> Blue <span>=</span> <span>4</span><span>}</span>
<span>let</span> c<span>:</span> Color <span>=</span> Color<span>.</span>Green<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：</p>
<div><pre><code><span>enum</span> Color <span>{</span>Red <span>=</span> <span>1</span><span>,</span> Green<span>,</span> Blue<span>}</span>
<span>let</span> colorName<span>:</span> <span>string</span> <span>=</span> Color<span>[</span><span>2</span><span>]</span><span>;</span>

<span>console</span><span>.</span><span>log</span><span>(</span>colorName<span>)</span><span>;</span>  <span>// 显示'Green'因为上面代码里它的值是2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id="any"> Any</h4>
<p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 <code>any</code>类型来标记这些变量：</p>
<div><pre><code><span>let</span> notSure<span>:</span> <span>any</span> <span>=</span> <span>4</span><span>;</span>
notSure <span>=</span> <span>"maybe a string instead"</span><span>;</span>
notSure <span>=</span> <span>false</span><span>;</span> <span>// okay, definitely a boolean</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>在对现有代码进行改写的时候，<code>any</code>类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 <code>Object</code>有相似的作用，就像它在其它语言中那样。 但是 <code>Object</code>类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：</p>
<div><pre><code><span>let</span> notSure<span>:</span> <span>any</span> <span>=</span> <span>4</span><span>;</span>
notSure<span>.</span><span>ifItExists</span><span>(</span><span>)</span><span>;</span> <span>// okay, ifItExists might exist at runtime</span>
notSure<span>.</span><span>toFixed</span><span>(</span><span>)</span><span>;</span> <span>// okay, toFixed exists (but the compiler doesn't check)</span>

<span>let</span> prettySure<span>:</span> Object <span>=</span> <span>4</span><span>;</span>
prettySure<span>.</span><span>toFixed</span><span>(</span><span>)</span><span>;</span> <span>// Error: Property 'toFixed' doesn't exist on type 'Object'.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>当你只知道一部分数据的类型时，<code>any</code>类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>
<div><pre><code><span>let</span> list<span>:</span> <span>any</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>true</span><span>,</span> <span>"free"</span><span>]</span><span>;</span>

list<span>[</span><span>1</span><span>]</span> <span>=</span> <span>100</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="void"> void</h4>
<p>某种程度上来说，<code>void</code>类型像是与<code>any</code>类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p>
<div><pre><code><span>function</span> <span>warnUser</span><span>(</span><span>)</span><span>:</span> <span>void</span> <span>{</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>"This is my warning message"</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>声明一个<code>void</code>类型的变量没有什么大用，因为你只能为它赋予<code>undefined</code>和<code>null</code>：</p>
<div><pre><code><span>let</span> unusable<span>:</span> <span>void</span> <span>=</span> <span>undefined</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="null-和-undefined"> Null 和 Undefined</h4>
<p>TypeScript里，<code>undefined</code>和<code>null</code>两者各自有自己的类型分别叫做<code>undefined</code>和<code>null</code>。 和 <code>void</code>相似，它们的本身的类型用处不是很大：</p>
<div><pre><code><span>// Not much else we can assign to these variables!</span>
<span>let</span> u<span>:</span> <span>undefined</span> <span>=</span> <span>undefined</span><span>;</span>
<span>let</span> n<span>:</span> <span>null</span> <span>=</span> <span>null</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型。 就是说你可以把 <code>null</code>和<code>undefined</code>赋值给<code>number</code>类型的变量。</p>
<h4 id="never"> Never</h4>
<p><code>never</code>类型表示的是那些永不存在的值的类型。 例如， <code>never</code>类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 <code>never</code>类型，当它们被永不为真的类型保护所约束时。</p>
<p><code>never</code>类型是任何类型的子类型，也可以赋值给任何类型；然而，<em>没有</em>类型是<code>never</code>的子类型或可以赋值给<code>never</code>类型（除了<code>never</code>本身之外）。 即使 <code>any</code>也不可以赋值给<code>never</code>。</p>
<p>下面是一些返回<code>never</code>类型的函数：</p>
<div><pre><code><span>// 返回never的函数必须存在无法达到的终点</span>
<span>function</span> <span>error</span><span>(</span>message<span>:</span> <span>string</span><span>)</span><span>:</span> <span>never</span> <span>{</span>
    <span>throw</span> <span>new</span> <span>Error</span><span>(</span>message<span>)</span><span>;</span>
<span>}</span>

<span>// 推断的返回值类型为never</span>
<span>function</span> <span>fail</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>error</span><span>(</span><span>"Something failed"</span><span>)</span><span>;</span>
<span>}</span>

<span>// 返回never的函数必须存在无法达到的终点</span>
<span>function</span> <span>infiniteLoop</span><span>(</span><span>)</span><span>:</span> <span>never</span> <span>{</span>
    <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h4 id="类型断言"> 类型断言</h4>
<p>有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>
<p>通过<em>类型断言</em>这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。</p>
<p>类型断言有两种形式。 其一是“尖括号”语法：</p>
<div><pre><code><span>let</span> someValue<span>:</span> <span>any</span> <span>=</span> <span>"this is a string"</span><span>;</span>

<span>let</span> strLength<span>:</span> <span>number</span> <span>=</span> <span>(</span><span>&lt;</span><span>string</span><span>></span>someValue<span>)</span><span>.</span>length<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>另一个为<code>as</code>语法：</p>
<div><pre><code><span>let</span> someValue<span>:</span> <span>any</span> <span>=</span> <span>"this is a string"</span><span>;</span>

<span>let</span> strLength<span>:</span> <span>number</span> <span>=</span> <span>(</span>someValue <span>as</span> <span>string</span><span>)</span><span>.</span>length<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 <code>as</code>语法断言是被允许的。</p>
<h4 id="变量声明"> 变量声明</h4>
<p>对象解构的展开还有其它一些意想不到的限制。 首先，它仅包含对象 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties" target="_blank" rel="noopener noreferrer">自身的可枚举属性</a>。 大体上是说当你展开一个对象实例时，你会丢失其方法：</p>
<div><pre><code><span>class</span> <span><span>C</span></span> <span>{</span>
  p <span>=</span> <span>12</span><span>;</span>
  <span>m</span><span>(</span><span>)</span> <span>{</span>
  <span>}</span>
<span>}</span>
<span>let</span> c <span>=</span> <span>new</span> <span><span>C</span></span><span>(</span><span>)</span><span>;</span>
<span>let</span> clone <span>=</span> <span>{</span> <span>...</span>c <span>}</span><span>;</span>
clone<span>.</span>p<span>;</span> <span>// ok</span>
clone<span>.</span><span>m</span><span>(</span><span>)</span><span>;</span> <span>// error!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div>]]></content>
    <author>
      <name>xiechengyu</name>
    </author>
    <category term="学习"/>
    <contributor>
      <name>xiechengyu</name>
    </contributor>
    <published>2021-03-22T17:42:04.000Z</published>
    <rights>Copyright by xiechengyu</rights>
  </entry>
  <entry>
    <title type="html">初识vue3.0</title>
    <id>https://xiechengyu.github.io/learn/%E5%88%9D%E8%AF%86vue3/</id>
    <link href="https://xiechengyu.github.io/learn/%E5%88%9D%E8%AF%86vue3/"/>
    <updated>2022-02-08T07:39:18.000Z</updated>
    <summary type="html"><![CDATA[<h1 id="前言"> 前言</h1>
<p>最近看了兴起的vue3.0框架，有几点知识记录一二。</p>
]]></summary>
    <content type="html"><![CDATA[<h1 id="前言"> 前言</h1>
<p>最近看了兴起的vue3.0框架，有几点知识记录一二。</p>

<h2 id="_1、setup-函数的用法。"> 1、setup 函数的用法。</h2>
<p>可以代替 Vue2 中的 date 和 methods 属性，直接把逻辑卸载 setup 里就可以</p>
<p>ref 函数的使用，它是一个神奇的函数，我们这节只是初次相遇，要在template中使用的变量，必须用ref包装一下。</p>
<p>return出去的数据和方法，在模板中才可以使用，这样可以精准的控制暴漏的变量和方法。</p>
<h2 id="_2、reactive。"> 2、reactive。</h2>
<p>它也是一个函数(方法)，只不过里边接受的参数是一个 Object(对象)</p>
<h2 id="_3、interface"> 3、interface</h2>
<p>用来作类型注解</p>
<h2 id="_4、torefs"> 4、toRefs</h2>
<p>把 data 变成refData,这样就可以使用扩展运算符的方式了</p>
<h2 id="_5-vue3-0的生命周期包括"> 5.vue3.0的生命周期包括：</h2>
<p>setup() :开始创建组件之前，在beforeCreate和created之前执行。创建的是data和method</p>
<p>onBeforeMount() : 组件挂载到节点上之前执行的函数。</p>
<p>onMounted() : 组件挂载完成后执行的函数。</p>
<p>onBeforeUpdate(): 组件更新之前执行的函数。</p>
<p>onUpdated(): 组件更新完成之后执行的函数。</p>
<p>onBeforeUnmount(): 组件卸载之前执行的函数。</p>
<p>onUnmounted(): 组件卸载完成后执行的函数</p>
<p>onActivated(): 被包含在 keep-alive 中的组件，会多出两个生命周期钩子函数。被激活时执行。</p>
<p>onDeactivated(): 比如从 A 组件，切换到 B 组件，A 组件消失时执行。</p>
<p>onErrorCaptured(): 当捕获一个来自子孙组件的异常时激活钩子函数）。</p>
<h2 id="_6-vue3与vue2的生命周期对比"> 6.vue3与vue2的生命周期对比</h2>
<p>Vue2--------------vue3</p>
<p>beforeCreate  -&gt; setup()</p>
<p>created       -&gt; setup()</p>
<p>beforeMount   -&gt; onBeforeMount</p>
<p>mounted       -&gt; onMounted</p>
<p>beforeUpdate  -&gt; onBeforeUpdate</p>
<p>updated       -&gt; onUpdated</p>
<p>beforeDestroy -&gt; onBeforeUnmount</p>
<p>destroyed     -&gt; onUnmounted</p>
<p>activated     -&gt; onActivated</p>
<p>deactivated   -&gt; onDeactivated</p>
<p>errorCaptured -&gt; onErrorCaptured</p>
<h2 id="_7-onrendertracked和onrendertriggered"> 7.onRenderTracked和onRenderTriggered</h2>
<p>用来调试</p>
<h2 id="_8-watch"> 8.watch</h2>
<p>按需引入</p>
<h2 id="_9-直接引用模块代替mixins引入"> 9.直接引用模块代替mixins引入</h2>
<h2 id="_10-封装axios"> 10.封装axios</h2>
<h2 id="_11-teleport"> 11.teleport</h2>
<p>把组件渲染到你任意想渲染的外部Dom上</p>
<h2 id="_12-suspense"> 12.，Suspense</h2>
<p>提供两个template的位置，一个是没有请求回来时显示的内容，一个是全部请求完毕的内容。这样进行异步内容的渲染就会非常简单。返回一个promise对象</p>
<h2 id="_13-onerrorcaptured"> 13.onErrorCaptured</h2>
<p>捕获异常</p>
]]></content>
    <author>
      <name>xiechengyu</name>
    </author>
    <category term="学习"/>
    <contributor>
      <name>xiechengyu</name>
    </contributor>
    <published>2021-03-19T00:12:52.000Z</published>
    <rights>Copyright by xiechengyu</rights>
  </entry>
  <entry>
    <title type="html">css的@规则</title>
    <id>https://xiechengyu.github.io/note/css%E7%9A%84@%E8%A7%84%E5%88%99/</id>
    <link href="https://xiechengyu.github.io/note/css%E7%9A%84@%E8%A7%84%E5%88%99/"/>
    <updated>2022-02-08T07:39:18.000Z</updated>
    <summary type="html"><![CDATA[<h2 id="前言"> 前言</h2>
<p>最近看了些关于css的进阶知识，发现有一些@规则很有作用，在此借助一些资料进行总结。</p>
]]></summary>
    <content type="html"><![CDATA[<h2 id="前言"> 前言</h2>
<p>最近看了些关于css的进阶知识，发现有一些@规则很有作用，在此借助一些资料进行总结。</p>

<h2 id="规则"> @ 规则</h2>
<h3 id="charset"> @charset</h3>
<p>@charset 用于提示 CSS 文件使用的字符编码方式，它如果被使用，必须出现在最前面。这个规则只在给出语法解析阶段前使用，并不影响页面上的展示效果。</p>
<div><pre><code><span><span>@charset</span> <span>"utf-8"</span><span>;</span></span>

</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="import"> @import</h3>
<p>@import 用于引入一个 CSS 文件，除了 @charset 规则不会被引入，@import 可以引入另一个文件的全部内容。</p>
<div><pre><code><span><span>@import</span> <span>"mystyle.css"</span><span>;</span></span>
<span><span>@import</span> <span><span>url</span><span>(</span><span>"mystyle.css"</span><span>)</span></span><span>;</span></span>
<span><span>@import</span> [ &lt;url> | &lt;string> ]
[ <span>supports</span><span>(</span> [ &lt;supports-condition> | &lt;declaration> ] <span>)</span> ]?
&lt;media-query-list>? <span>;</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>通过代码，我们可以看出，import 还支持 supports 和 media query 形式。</p>
<h3 id="media"> @media</h3>
<p>media 能够对设备的类型进行一些判断，进行媒体查询。在 media 的区块内，是普通规则列表。</p>
<div><pre><code><span><span>@media</span> print</span> <span>{</span>
<span>body</span> <span>{</span> <span>font-size</span><span>:</span> 10pt <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="page"> @page</h3>
<p>page 用于分页媒体访问网页时的表现设置，页面是一种特殊的盒模型结构，除了页面本身，还可以设置它周围的盒。</p>
<div><pre><code><span><span>@page</span></span> <span>{</span>
<span>size</span><span>:</span> 8.5in 11in<span>;</span>
<span>margin</span><span>:</span> 10%<span>;</span>

<span><span>@top-left</span></span> <span>{</span>
<span>content</span><span>:</span> <span>"Hamlet"</span><span>;</span>
<span>}</span>
<span><span>@top-right</span></span> <span>{</span>
<span>content</span><span>:</span> <span>"Page "</span> <span>counter</span><span>(</span>page<span>)</span><span>;</span>
<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="counter-style"> @ counter-style</h3>
<p>counter-style 产生一种数据，用于定义列表项的表现。</p>
<div><pre><code><span><span>@counter-style</span> triangle</span> <span>{</span>
<span>system</span><span>:</span> cyclic<span>;</span>
<span>symbols</span><span>:</span> ‣<span>;</span>
<span>suffix</span><span>:</span> <span>" "</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="key-frames"> @ key-frames</h3>
<p>keyframes 产生一种数据，用于定义动画关键帧。</p>
<div><pre><code><span><span>@keyframes</span> diagonal-slide</span> <span>{</span>

<span>from</span> <span>{</span>
<span>left</span><span>:</span> 0<span>;</span>
<span>top</span><span>:</span> 0<span>;</span>
<span>}</span>

<span>to</span> <span>{</span>
<span>left</span><span>:</span> 100px<span>;</span>
<span>top</span><span>:</span> 100px<span>;</span>
<span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="fontface"> @ fontface</h3>
<p>fontface 用于定义一种字体，icon font 技术就是利用这个特性来实现的。</p>
<div><pre><code>@font-face {
font-family: Gentium;
src: url(http://example.com/fonts/Gentium.woff);
}

p { font-family: Gentium, serif; }
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="support"> @ support</h3>
<p>support 检查环境的特性，它与 media 比较类似。</p>
<h3 id="namespace"> @ namespace</h3>
<p>用于跟 XML 命名空间配合的一个规则，表示内部的 CSS 选择器全都带上特定命名空间。</p>
<h3 id="viewport"> @ viewport</h3>
<p>用于设置视口的一些特性，不过兼容性目前不是很好，多数时候被 html 的 meta 代替。</p>
]]></content>
    <author>
      <name>xiechengyu</name>
    </author>
    <category term="笔记"/>
    <contributor>
      <name>xiechengyu</name>
    </contributor>
    <published>2019-06-24T08:44:17.000Z</published>
    <rights>Copyright by xiechengyu</rights>
  </entry>
  <entry>
    <title type="html">lazysizes的用法</title>
    <id>https://xiechengyu.github.io/note/lazysizes%E7%9A%84%E7%94%A8%E6%B3%95/</id>
    <link href="https://xiechengyu.github.io/note/lazysizes%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <updated>2022-02-08T07:39:18.000Z</updated>
    <summary type="html"><![CDATA[<h1 id="lazysizes的使用"> lazysizes的使用</h1>
<h2 id="前言"> 前言</h2>
<p>最近在学习图片懒加载的时候知道了这个名教lazysizes的懒加载库，在此总结一些用法。</p>
]]></summary>
    <content type="html"><![CDATA[<h1 id="lazysizes的使用"> lazysizes的使用</h1>
<h2 id="前言"> 前言</h2>
<p>最近在学习图片懒加载的时候知道了这个名教lazysizes的懒加载库，在此总结一些用法。
</p>
<h2 id="安装"> 安装</h2>
<div><pre><code><span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>lazysizes.min.js<span>"</span></span> <span>async</span><span><span>=</span><span>"</span><span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span>&lt;!-- 放在body结尾标签处 --></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="在页面中使用"> 在页面中使用</h2>
<h3 id="不需要响应式时"> 不需要响应式时</h3>
<div><pre><code><span><span><span>&lt;</span>img</span> <span>data-src</span><span><span>=</span><span>"</span>img/1.jpg<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>lazyload<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="需要响应式时"> 需要响应式时</h3>
<div><pre><code><span><span><span>&lt;</span>img</span> <span>data-srcset</span><span><span>=</span><span>"</span>img/1.jpg 1x, img/2.jpg 2x<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>lazyload<span>"</span></span> <span>/></span></span>
<span>&lt;!--或者--></span>
<span><span><span>&lt;</span>img</span>
	<span>data-sizes</span><span><span>=</span><span>"</span>auto<span>"</span></span>
    <span>data-src</span><span><span>=</span><span>"</span>data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==<span>"</span></span>
	  <span>data-srcset</span><span><span>=</span><span>"</span>
      img/1.jpg 300w,
	    img/2.jpg 600w,
	    img/3.jpg 900w<span>"</span></span>
  <span>class</span><span><span>=</span><span>"</span>lazyload<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="使用picture标签时"> 使用picture标签时</h3>
<p>在这里要使用picture标签时在兼容ie9的时候需要引入一个js在head标签内</p>
<div><pre><code><span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>picturefill.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>接着可以使用了</p>
<div><pre><code>  <span><span><span>&lt;</span>script</span><span>></span></span><span><span>
    window<span>.</span>lazySizesConfig <span>=</span> window<span>.</span>lazySizesConfig <span>||</span> <span>{</span><span>}</span><span>;</span>
    window<span>.</span>lazySizesConfig<span>.</span>customMedia <span>=</span> <span>{</span>
      <span>'--small'</span><span>:</span> <span>'(max-width: 480px)'</span><span>,</span>
      <span>'--medium'</span><span>:</span> <span>'(max-width: 900px)'</span><span>,</span>
      <span>'--large'</span><span>:</span> <span>'(max-width: 1400px)'</span><span>,</span>
    <span>}</span><span>;</span>
  </span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
  <span><span><span>&lt;</span>picture</span><span>></span></span>
    <span>&lt;!--[if IE 9]>&lt;video style="display: none;>&lt;![endif]--></span>
    <span><span><span>&lt;</span>source</span> <span>data-srcset</span><span><span>=</span><span>"</span>img/1.jpg<span>"</span></span> <span>media</span><span><span>=</span><span>"</span>--small<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>source</span> <span>data-srcset</span><span><span>=</span><span>"</span>img/2.jpg<span>"</span></span> <span>media</span><span><span>=</span><span>"</span>--medium<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>source</span> <span>data-srcset</span><span><span>=</span><span>"</span>img/3.jpg<span>"</span></span> <span>media</span><span><span>=</span><span>"</span>--large<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>source</span> <span>data-srcset</span><span><span>=</span><span>"</span>img/4.jpg<span>"</span></span> <span>/></span></span>
    <span>&lt;!--[if IE 9]>&lt;/video>&lt;![endif]--></span>
    <span><span><span>&lt;</span>img</span> <span>data-src</span><span><span>=</span><span>"</span>img/3.jpg<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>lazyload<span>"</span></span> <span>alt</span><span><span>=</span><span>"</span>image with artdirection<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>picture</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="在需要有懒加载的不同状态时"> 在需要有懒加载的不同状态时</h3>
<div><pre><code>  <span><span><span>&lt;</span>style</span><span>></span></span><span><span>
    <span>.no-js img.lazyload</span> <span>{</span>
      <span>display</span><span>:</span> none<span>;</span>
    <span>}</span>
  </span></span><span><span><span>&lt;/</span>style</span><span>></span></span>

  <span>&lt;!-- noscript pattern --></span>
  <span><span><span>&lt;</span>noscript</span><span>></span></span>
    <span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>"</span>img/2.jpg<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>noscript</span><span>></span></span>
  <span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>"</span>img/3.jpg<span>"</span></span> <span>data-src</span><span><span>=</span><span>"</span>img/2.jpg<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>lazyload<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>lazysizes.min.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>

<span>&lt;!-- 或者还可以 --></span>
 <span>&lt;!-- 在距离底部500px时懒加载并设置一个过渡动画效果 三个类分别是图片未加载，图片加载中和图片已加载 --></span>
  <span><span><span>&lt;</span>style</span><span>></span></span><span><span>
    <span>.lazyload</span> <span>{</span>
      <span>opacity</span><span>:</span> 0<span>;</span>
    <span>}</span>

    <span>.lazyloading</span> <span>{</span>
      <span>opacity</span><span>:</span> 0.5<span>;</span>
      <span>transition</span><span>:</span> opacity 300ms<span>;</span>
      <span>background</span><span>:</span> #f7f7f7 no-repeat center<span>;</span>
    <span>}</span>

    <span>.lazyloaded</span> <span>{</span>
      <span>opacity</span><span>:</span> 1<span>;</span>
      <span>transition</span><span>:</span> opacity 300ms<span>;</span>
    <span>}</span>
  </span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>teaser lazyload<span>"</span></span> <span>data-expand</span><span><span>=</span><span>"</span>-500<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>img</span> <span>data-src</span><span><span>=</span><span>"</span>img/1.jpg<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>lazyload<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>h1</span><span>></span></span>Teaser Title<span><span><span>&lt;/</span>h1</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>...<span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div>]]></content>
    <author>
      <name>xiechengyu</name>
    </author>
    <category term="笔记"/>
    <contributor>
      <name>xiechengyu</name>
    </contributor>
    <published>2019-06-11T09:48:17.000Z</published>
    <rights>Copyright by xiechengyu</rights>
  </entry>
  <entry>
    <title type="html">slick的配置</title>
    <id>https://xiechengyu.github.io/note/sclick%E7%9A%84%E9%85%8D%E7%BD%AE/</id>
    <link href="https://xiechengyu.github.io/note/sclick%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <updated>2022-02-09T03:21:27.000Z</updated>
    <summary type="html"><![CDATA[<h1 id="前言"> 前言</h1>
<p>因为正在学习slick，但是其是外国网站并且api也比较繁多，所以在此总结。</p>
]]></summary>
    <content type="html"><![CDATA[<h1 id="前言"> 前言</h1>
<p>因为正在学习slick，但是其是外国网站并且api也比较繁多，所以在此总结。</p>

<h1 id="slick的settings属性"> slick的settings属性</h1>
<table>
<thead>
<tr>
<th>属性名</th>
<th>属性值</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>accessibility</td>
<td>boolean</td>
<td>true</td>
<td>启用Tab键和箭头键导航(键盘按键)</td>
</tr>
<tr>
<td>adaptiveHeight</td>
<td>boolean</td>
<td>false</td>
<td>为单个滑动水平转盘启用自适应高度。</td>
</tr>
<tr>
<td>autopaly</td>
<td>boolean</td>
<td>false</td>
<td>可以自动播放</td>
</tr>
<tr>
<td>autoplaySpeed</td>
<td>number(ms)</td>
<td>3000</td>
<td>自动播放速度，以毫秒为单位</td>
</tr>
<tr>
<td>arrows</td>
<td>boolean</td>
<td>true</td>
<td>前进后退箭头</td>
</tr>
<tr>
<td>asNavFor</td>
<td>string</td>
<td>null</td>
<td>将滑块设置为其他滑块的导航（类或ID名称）,适用于多个轮播图共用一个导航</td>
</tr>
<tr>
<td>appendArrows</td>
<td>string</td>
<td>$(element)</td>
<td>更改导航箭头所在的位置（Selector，htmlString，Array，Element，jQuery对象）</td>
</tr>
<tr>
<td>appendDots</td>
<td>string</td>
<td>$(element)</td>
<td>更改导航点附加的位置（Selector，htmlString，Array，Element，jQuery对象）</td>
</tr>
<tr>
<td>prevArrow</td>
<td>string</td>
<td><button type = "button">Previous</button></td>
<td>允许您选择节点或自定义“上一个”箭头的HTML。</td>
</tr>
<tr>
<td>nextArrow</td>
<td>string</td>
<td><button type = "button">Next</button></td>
<td>允许您选择节点或自定义“下一个”箭头的HTML。</td>
</tr>
<tr>
<td>centerMode</td>
<td>boolean</td>
<td>false</td>
<td>使用部分prev/next幻灯片启用居中视图。与奇数slidesToShow计数一起使用。</td>
</tr>
<tr>
<td>centerPadding</td>
<td>string</td>
<td>'50px'</td>
<td>中间模式下的边距(px或%)</td>
</tr>
<tr>
<td>cssEase</td>
<td>string</td>
<td>'ease'</td>
<td>CSS3动画速度效果</td>
</tr>
<tr>
<td>customPaging</td>
<td>function</td>
<td>n/a</td>
<td>自定义分页模板。有关使用示例，请参见源代码</td>
</tr>
<tr>
<td>dots</td>
<td>boolean</td>
<td>false</td>
<td>显示点指标</td>
</tr>
<tr>
<td>dotsClass</td>
<td>string</td>
<td>'slick-dots'</td>
<td>用于幻灯片指示器dots容器的类</td>
</tr>
<tr>
<td>draggable</td>
<td>boolean</td>
<td>true</td>
<td>支持鼠标拖拽</td>
</tr>
<tr>
<td>fade</td>
<td>booelan</td>
<td>false</td>
<td>使褪色</td>
</tr>
<tr>
<td>focusOnSelect</td>
<td>boolean</td>
<td>false</td>
<td>启用选定元素的焦点(单击)</td>
</tr>
<tr>
<td>easing</td>
<td>string</td>
<td>'linear'</td>
<td>为jQuery动画添加缓动。与缓动库或默认缓动方法一起使用</td>
</tr>
<tr>
<td>edgeFriction</td>
<td>integer</td>
<td>0.15</td>
<td>非无限传送带边缘滑动时的阻力</td>
</tr>
<tr>
<td>infinite</td>
<td>boolean</td>
<td>true</td>
<td>无限循环滑动</td>
</tr>
<tr>
<td>initialSlide</td>
<td>integer</td>
<td>0</td>
<td>幻灯片开始</td>
</tr>
<tr>
<td>lazyLoad</td>
<td>string</td>
<td>ondemand</td>
<td>设置延迟加载技术。接受“随需应变”或“渐进”（使用时只需把图片的src值换成data-lazy然后在slick配置中设置lazyLoad: 'ondemand',即可）</td>
</tr>
<tr>
<td>mobileFirst</td>
<td>boolean</td>
<td>false</td>
<td>响应设置使用移动优先计算</td>
</tr>
<tr>
<td>pauseOnFocus</td>
<td>boolean</td>
<td>true</td>
<td>在对焦时暂停自动播放</td>
</tr>
<tr>
<td>pauseOnHover</td>
<td>boolean</td>
<td>true</td>
<td>在触摸时暂停自动播放</td>
</tr>
<tr>
<td>pauseOnDotsHover</td>
<td>boolean</td>
<td>false</td>
<td>在一个导航点被触摸时暂停自动播放</td>
</tr>
<tr>
<td>respondTo</td>
<td>string</td>
<td>'window'</td>
<td>响应对象响应的宽度。可以是'window'， 'slider'或'min'(两者中较小的一个)</td>
</tr>
<tr>
<td>responsive</td>
<td>object</td>
<td>none</td>
<td>包含断点和设置对象的对象(参见演示)。启用设置设置在给定的屏幕宽度。将设置设置为“unslick”，而不是在给定断点处禁用slick的对象。</td>
</tr>
<tr>
<td>rows</td>
<td>number</td>
<td>1</td>
<td>将此值设置为1以上将初始化网格模式。使用slidesPerRow设置每行应该有多少张幻灯片。</td>
</tr>
<tr>
<td>slide</td>
<td>element</td>
<td>''</td>
<td>要用作幻灯片的元素查询</td>
</tr>
<tr>
<td>slidesPerRow</td>
<td>number</td>
<td>1</td>
<td>通过rows选项初始化网格模式，可以设置每个网格行中有多少幻灯片</td>
</tr>
<tr>
<td>slidesToShow</td>
<td>number</td>
<td>1</td>
<td>每次显示几个</td>
</tr>
<tr>
<td>slidesToScroll</td>
<td>number</td>
<td>1</td>
<td>每次滚动几个</td>
</tr>
<tr>
<td>speed</td>
<td>number(ms)</td>
<td>300</td>
<td>幻灯片/褪色动画速度</td>
</tr>
<tr>
<td>swipe</td>
<td>boolean</td>
<td>true</td>
<td>启动滑动</td>
</tr>
<tr>
<td>swipeToSlide</td>
<td>boolean</td>
<td>false</td>
<td>允许用户直接拖动或滑动到幻灯片，而不管slidesToScroll</td>
</tr>
<tr>
<td>touchMove</td>
<td>boolean</td>
<td>true</td>
<td>通过触摸启用幻灯片移动</td>
</tr>
<tr>
<td>touchThreshold</td>
<td>number</td>
<td>5</td>
<td>要推进幻灯片，用户必须滑动（1 / touchThreshold）*滑块宽度的长度</td>
</tr>
<tr>
<td>useCSS</td>
<td>boolean</td>
<td>true</td>
<td>启用/禁用CSS转换</td>
</tr>
<tr>
<td>useTransform</td>
<td>boolean</td>
<td>true</td>
<td>启用/禁用CSS变换</td>
</tr>
<tr>
<td>variableWidth</td>
<td>boolean</td>
<td>false</td>
<td>可变宽度幻灯片</td>
</tr>
<tr>
<td>vertical</td>
<td>boolean</td>
<td>false</td>
<td>垂直滑动模式</td>
</tr>
<tr>
<td>verticalSwiping</td>
<td>boolean</td>
<td>false</td>
<td>垂直</td>
</tr>
<tr>
<td>rtl</td>
<td>boolean</td>
<td>false</td>
<td>将滑块的方向更改为从右到左</td>
</tr>
<tr>
<td>waitForAnimate</td>
<td>boolean</td>
<td>true</td>
<td>在动画制作时忽略推进幻灯片的请求</td>
</tr>
<tr>
<td>zindex</td>
<td>number</td>
<td>1000</td>
<td>设置幻灯片的zIndex值，对IE9及更低版本有用</td>
</tr>
</tbody>
</table>
<h1 id="slick的events属性"> slick的events属性</h1>
<table>
<thead>
<tr>
<th>事件名</th>
<th>事件传递参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>afterChange</td>
<td>slick,currentSlicde</td>
<td>更换幻灯片后触发</td>
</tr>
<tr>
<td>beforeChange</td>
<td>slick,currentSlicde,nextSlide</td>
<td>更换幻灯片前触发</td>
</tr>
<tr>
<td>breakpoint</td>
<td>event,slick,breakpoint</td>
<td>断点后触发</td>
</tr>
<tr>
<td>destroy</td>
<td>event,slick</td>
<td>滑块被销毁或未滑动时</td>
</tr>
<tr>
<td>edge</td>
<td>slick,direction</td>
<td>边缘在非无限模式下过度滚动时触发。</td>
</tr>
<tr>
<td>init</td>
<td>slick</td>
<td>首次初始化后触发</td>
</tr>
<tr>
<td>relnit</td>
<td>slick</td>
<td>每次重新初始化后触发</td>
</tr>
<tr>
<td>setPosition</td>
<td>slick</td>
<td>位置/大小改变后触发</td>
</tr>
<tr>
<td>swipe</td>
<td>slick,direction</td>
<td>滑动/拖动后触发</td>
</tr>
<tr>
<td>lazyLoaded</td>
<td>event,slick,image,imageSourse</td>
<td>图片懒加载后触发</td>
</tr>
<tr>
<td>lazyLoadedError</td>
<td>event,slick,image,imageSourse</td>
<td>图像无法加载后触发</td>
</tr>
</tbody>
</table>
<h1 id="slick的methods属性"> slick的methods属性</h1>
<table>
<thead>
<tr>
<th>方法名</th>
<th>方法传递参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>slickCurrentSlide</td>
<td>none</td>
<td>返回当前幻灯片索引</td>
</tr>
<tr>
<td>slickGoTo</td>
<td>number(slide数)，boolean(是否动画)</td>
<td>按索引导航到幻灯片</td>
</tr>
<tr>
<td>slickNext</td>
<td>none</td>
<td>导航到下一张幻灯片</td>
</tr>
<tr>
<td>slickPrev</td>
<td>none</td>
<td>导航到上一张幻灯片</td>
</tr>
<tr>
<td>slickPause</td>
<td>none</td>
<td>停止自动播放时</td>
</tr>
<tr>
<td>slickPlay</td>
<td>none</td>
<td>开始自动播放时</td>
</tr>
<tr>
<td>slickAdd</td>
<td>html or DOM object, index, addBefore</td>
<td>添加幻灯片。 如果提供了索引，则将在该索引处添加，或者在设置addBefore之前添加。 如果未提供索引，则在设置addBefore时添加到结尾或开头。 接受HTML字符串|| 对象</td>
</tr>
<tr>
<td>slickRemove</td>
<td>index,removeBefore</td>
<td>按索引删除幻灯片。 如果removeBefore设置为true，则删除前面的索引，如果未指定索引，则删除第一张幻灯片。 如果removeBefore设置为false，则删除索引后的幻灯片，如果未设置索引，则删除最后一张幻灯片。</td>
</tr>
<tr>
<td>slickFilter</td>
<td>Selector or Function</td>
<td>使用jQuery .filter（）过滤幻灯片</td>
</tr>
<tr>
<td>slickUnfilter</td>
<td>index</td>
<td>删除应用的过滤</td>
</tr>
<tr>
<td>slickGetOption</td>
<td>option(string)</td>
<td>获取单个选项值。</td>
</tr>
<tr>
<td>slickSetOption</td>
<td>option : string, value : depends on option, refresh : boolean</td>
<td>实时设置单个值。 如果是UI更新，请将refresh设置为true。</td>
</tr>
<tr>
<td>unslick</td>
<td>none</td>
<td>解除slick</td>
</tr>
<tr>
<td>getSlick</td>
<td>none</td>
<td>获取slick对象</td>
</tr>
</tbody>
</table>
<h1 id="slick的例子"> slick的例子</h1>
<div><pre><code><span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>

<span><span><span>&lt;</span>head</span><span>></span></span>

    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>

​    <span><span><span>&lt;</span>title</span><span>></span></span>Title<span><span><span>&lt;/</span>title</span><span>></span></span>

​    <span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>"</span>stylesheet<span>"</span></span> <span>type</span><span><span>=</span><span>"</span>text/css<span>"</span></span> <span>href</span><span><span>=</span><span>"</span>slick-1.8.1/slick/slick.css<span>"</span></span><span>/></span></span>

​    <span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>"</span>stylesheet<span>"</span></span> <span>type</span><span><span>=</span><span>"</span>text/css<span>"</span></span> <span>href</span><span><span>=</span><span>"</span>slick-1.8.1/slick/slick-theme.css<span>"</span></span><span>/></span></span>

    <span><span><span>&lt;</span>style</span><span>></span></span><span><span>

<span>​        *,body,html</span><span>{</span>

​            <span>margin</span><span>:</span> 0<span>;</span>

​            <span>padding</span><span>:</span> 0<span>;</span>

​        <span>}</span>

<span>​        .one</span><span>{</span>

​            <span>margin</span><span>:</span> 50px auto<span>;</span>

​            <span>width</span><span>:</span> 200px<span>;</span>

​            <span>height</span><span>:</span> 600px<span>;</span>

​        <span>}</span>

<span>​        .one .slick-slide</span><span>{</span>

​            <span>width</span><span>:</span> 200px<span>;</span>

​            <span>height</span><span>:</span> 200px<span>;</span>

​            <span>background</span><span>:</span> aqua<span>;</span>

​            <span>margin</span><span>:</span> 0 auto<span>;</span>

​            <span>text-align</span><span>:</span> center<span>;</span>

​        <span>}</span>

<span>​        .slick-arrow::before</span><span>{</span>

​            <span>color</span><span>:</span> black <span>!important</span><span>;</span>

​        <span>}</span>

​    </span></span><span><span><span>&lt;/</span>style</span><span>></span></span>

<span><span><span>&lt;/</span>head</span><span>></span></span>

<span><span><span>&lt;</span>body</span><span>></span></span>

    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>one<span>"</span></span><span>></span></span>

        <span><span><span>&lt;</span>div</span><span>></span></span>1<span><span><span>&lt;/</span>div</span><span>></span></span>

        <span><span><span>&lt;</span>div</span><span>></span></span>2<span><span><span>&lt;/</span>div</span><span>></span></span>

        <span><span><span>&lt;</span>div</span><span>></span></span>3<span><span><span>&lt;/</span>div</span><span>></span></span>

        <span><span><span>&lt;</span>div</span><span>></span></span>4<span><span><span>&lt;/</span>div</span><span>></span></span>

​    <span><span><span>&lt;/</span>div</span><span>></span></span>

​    <span><span><span>&lt;</span>button</span> <span>type</span><span><span>=</span><span>"</span>button<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>slick-prev<span>"</span></span><span>></span></span>Previous<span><span><span>&lt;/</span>button</span><span>></span></span>

    <span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>"</span>text/javascript<span>"</span></span> <span>src</span><span><span>=</span><span>"</span>//code.jquery.com/jquery-1.11.0.min.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>

    <span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>"</span>text/javascript<span>"</span></span> <span>src</span><span><span>=</span><span>"</span>//code.jquery.com/jquery-migrate-1.2.1.min.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>

    <span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>"</span>text/javascript<span>"</span></span> <span>src</span><span><span>=</span><span>"</span>./slick-1.8.1/slick/slick.min.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>

    <span><span><span>&lt;</span>script</span><span>></span></span><span><span>

​        <span>const</span> di <span>=</span> <span>$</span><span>(</span><span>'.slick-slide'</span><span>)</span>

​        <span>$</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>

​            <span>$</span><span>(</span><span>'.one'</span><span>)</span>

​                <span>.</span><span>slick</span><span>(</span><span>{</span>

​                arrows<span>:</span><span>true</span><span>,</span>

​                dots<span>:</span><span>true</span><span>,</span>

​                <span>// centerMode:true,</span>

​                centerPadding<span>:</span><span>'80px'</span><span>,</span>

​                cssEase<span>:</span><span>'linear'</span><span>,</span>

​                easing<span>:</span><span>'ease'</span><span>,</span>

​                edgeFriction<span>:</span><span>0.9</span><span>,</span>

​                <span>// initialSlide:2,</span>

​                autoplay<span>:</span><span>true</span><span>,</span>

​                <span>// pauseOnHover:false,</span>

​                slidesToShow<span>:</span> <span>3</span><span>,</span>

​                swipeToSlide<span>:</span><span>true</span><span>,</span>

​                vertical<span>:</span><span>true</span><span>,</span>

​                verticalSwiping<span>:</span><span>true</span>

​            <span>}</span><span>)</span>

​                <span>.</span><span>on</span><span>(</span><span>'swipe'</span><span>,</span> <span>(</span><span>slick<span>,</span>direction</span><span>)</span> <span>=></span> <span>{</span>

​                    console<span>.</span><span>log</span><span>(</span><span>'11111 = '</span> <span>+</span>slick<span>,</span><span>'22222 = '</span> <span>+</span>direction<span>)</span><span>;</span>

​                <span>}</span><span>)</span>

​            console<span>.</span><span>log</span><span>(</span><span>$</span><span>(</span><span>'.one'</span><span>)</span><span>.</span><span>slick</span><span>(</span><span>'slickCurrentSlide'</span><span>)</span><span>)</span>

​        <span>}</span><span>)</span>

​    </span></span><span><span><span>&lt;/</span>script</span><span>></span></span>

<span><span><span>&lt;/</span>body</span><span>></span></span>

<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br></div></div>]]></content>
    <author>
      <name>xiechengyu</name>
    </author>
    <category term="笔记"/>
    <contributor>
      <name>xiechengyu</name>
    </contributor>
    <published>2019-05-29T09:35:17.000Z</published>
    <rights>Copyright by xiechengyu</rights>
  </entry>
  <entry>
    <title type="html">swiper的配置</title>
    <id>https://xiechengyu.github.io/note/swiper%E7%9A%84%E9%85%8D%E7%BD%AE/</id>
    <link href="https://xiechengyu.github.io/note/swiper%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <updated>2022-02-09T03:21:27.000Z</updated>
    <summary type="html"><![CDATA[<h1 id="swiper的配置选项-包括swiper4-x的全部配置选项-方法-函数"> swiper的配置选项（包括swiper4.x的全部配置选项，方法，函数）</h1>
<p>之前一直有用到swiper去制作轮播图，但是api总是有些难记，就把他们都总结出来。</p>
]]></summary>
    <content type="html"><![CDATA[<h1 id="swiper的配置选项-包括swiper4-x的全部配置选项-方法-函数"> swiper的配置选项（包括swiper4.x的全部配置选项，方法，函数）</h1>
<p>之前一直有用到swiper去制作轮播图，但是api总是有些难记，就把他们都总结出来。</p>

<h2 id="basic-swiper一般选项"> basic(swiper一般选项)</h2>
<table>
<thead>
<tr>
<th>属性名</th>
<th>属性值</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>initialSlide</td>
<td>number</td>
<td>0</td>
<td>设定初始化时slide的索引。</td>
</tr>
<tr>
<td>diretion</td>
<td>string</td>
<td>' horizontal'</td>
<td>Slides的滑动方向，可设置水平(horizontal)或垂直(vertical)。</td>
</tr>
<tr>
<td>speed</td>
<td>number</td>
<td>300</td>
<td>切换速度，即slider自动滑动开始到结束的时间（单位ms），也是触摸滑动时释放至贴合的时间。</td>
</tr>
<tr>
<td>grabCursor</td>
<td>boolean</td>
<td>false</td>
<td>设置为true时，鼠标覆盖Swiper时指针会变成手掌形状，拖动时指针会变成抓手形状。（根据浏览器形状有所不同）</td>
</tr>
<tr>
<td>parallax</td>
<td>boolean</td>
<td>false</td>
<td>设置为true开启视差效果。效果可以应用于container或slide的子元素。当应用于container的子元素（常用于视差背景图），每次切换时视差效果仅有设定值的slide个数-1分之1 1.视差位移变化在所需要的元素上增加data-swiper-parallax属性（与Swiper切换方向相同）或data-swiper-parallax-x （x方向） data-swiper-parallax-y（y方向） data-swiper-parallax接受两种类型的参数。          number（单位：px），如-300，从右边300px进入左边出去。          percentage（百分比），移动距离=该元素宽度 * percentage。 2.视差透明度变化在所需要的元素上增加data-swiper-parallax-opacity属性。可选值0-1，如0.5，从半透明进入半透明出去 3.视差缩放变化在所需要的元素上增加data-swiper-parallax-scale属性。可选值如0.5，从一半大小进入一半大小出去 还可通过data-swiper-parallax-duration设定视差动画持续时间（ms）。默认值是Swiper的speed，与切换时间同步。 *设定透明度或缩放必须同时设定位移，否则无效(4.0.5) <div data-swiper-parallax="0" data-swiper-parallax-opacity="0.5" >透明度变化</div></td>
</tr>
<tr>
<td>setWrapperSize</td>
<td>boolean</td>
<td>false</td>
<td>Swiper使用flexbox布局(display: flex)，开启这个设定会在Wrapper上添加等于slides相加的宽或高，在对flexbox布局的支持不是很好的浏览器中可能需要用到。</td>
</tr>
<tr>
<td>vitualTranslate</td>
<td>boolean</td>
<td>false</td>
<td>虚拟的位移。当你启用这个参数，Slide不会移动，但是Swiper还是在运行，例如progress，active-slide，各种回调等。当你想自定义一些slide切换效果时可以用。例如配合上progress。启用这个选项时slideChange和transition等事件有效（与Swiper3.x不同）。 还可以用来使Swiper的滑动停止（锁定）。*可能会使鼠标滚动失效。</td>
</tr>
<tr>
<td>width</td>
<td>number</td>
<td>undefined</td>
<td>强制Swiper的宽度(px)，当你的Swiper在隐藏状态下初始化时用得上。这个参数会使自适应失效。可设置为undefined使这个参数无效。</td>
</tr>
<tr>
<td>height</td>
<td>number</td>
<td>undefined</td>
<td>强制Swiper的高度(px)，当你的Swiper在隐藏状态下初始化时且切换方向为垂直才用得上。这个参数会使自适应失效。</td>
</tr>
<tr>
<td>roundLengths</td>
<td>boolean</td>
<td>false</td>
<td>如果设置为true，则将slide的宽和高取整(四舍五入)，以防止某些分辨率的屏幕上文字或边界(border)模糊。例如当你设定slidesPerView : 3时，则可能出现slide的宽度为341.33px，开启roundLengths后宽度取整数341px。</td>
</tr>
<tr>
<td>breakpoints</td>
<td>object</td>
<td>undefined</td>
<td>断点设定：根据屏幕宽度设置某参数为不同的值，类似于响应式布局的media only screen and (max-width: 480px)只有部分不需要变换布局方式和逻辑结构的参数支持断点设定，如slidesPerView、slidesPerGroup、 spaceBetween，而像slidesPerColumn、loop、direction、effect等则无效。</td>
</tr>
<tr>
<td>breakpointsInverse</td>
<td>boolean</td>
<td>false</td>
<td>开启后，breakpoints将以反方向计算，类似于media only screen and (min-width: 480px)</td>
</tr>
<tr>
<td>autoHeight</td>
<td>boolean</td>
<td>false</td>
<td>自动高度。设置为true时，wrapper和container会随着当前slide的高度而发生变化。</td>
</tr>
<tr>
<td>uniqueNavElements</td>
<td>boolean</td>
<td>true</td>
<td>独立分页元素，当启用（默认）并且分页元素的传入值为字符串时，swiper会优先查找子元素匹配这些元素。可应用于分页器，按钮和滚动条（pagination, prev/next buttons and scrollbar elements）。当你的控制组件放在container外面的时候，需要用到。</td>
</tr>
<tr>
<td>nested</td>
<td>boolean</td>
<td>false</td>
<td>用于嵌套相同方向的swiper时，当切换到子swiper时停止父swiper的切换。请将子swiper的nested设置为true。由于需要在slideChangeEnd时判断作用块，因此快速滑动时这个选项无效。</td>
</tr>
<tr>
<td>runCallbacksOnInit</td>
<td>boolean</td>
<td>true</td>
<td>如果你的初始化slide不是第一个(例initialSlide:2)或者设置了loop: true，那么初始化时会触发一次 [Transition/SlideChange] [Start/End] 回调函数，如果不想触发，设置为false。</td>
</tr>
<tr>
<td>watchOverflow</td>
<td>boolean</td>
<td>false</td>
<td>当没有足够的slide切换时，例如只有1个slide，swiper会失效且隐藏导航等。默认不开启这个功能。loop模式无效，因为会复制slide。</td>
</tr>
<tr>
<td>on</td>
<td>object</td>
<td>undefined</td>
<td>注册事件，Swiper4.0开始使用关键词this指代Swiper实例。</td>
</tr>
<tr>
<td>init</td>
<td>boolean</td>
<td>true</td>
<td>当你创建一个Swiper实例时是否立即初始化。如果禁止了，可以稍后使用mySwiper.init()来初始化。</td>
</tr>
<tr>
<td>preloadImages</td>
<td>boolean</td>
<td>true</td>
<td>默认为true，Swiper会强制加载所有图片。</td>
</tr>
<tr>
<td>updateOnImagesReady</td>
<td>boolean</td>
<td>true</td>
<td>当所有的内嵌图像（img标签）加载完成后Swiper会重新初始化。使用此选项需要先开启preloadImages: true</td>
</tr>
</tbody>
</table>
<h2 id="slides-grid-网格分布"> slides grid(网格分布)</h2>
<table>
<thead>
<tr>
<th>属性名</th>
<th>属性值</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>centeredSlides</td>
<td>boolean</td>
<td>false</td>
<td>设定为true时，active slide会居中，而不是默认状态下的居左。</td>
</tr>
<tr>
<td>slidesPerView</td>
<td>numober or auto</td>
<td>1</td>
<td>设置slider容器能够同时显示的slides数量(carousel模式)。可以设置为数字（可为小数，小数不可loop），或者 'auto'则自动根据slides的宽度来设定数量。loop模式下如果设置为'auto'还需要设置另外一个参数<a href="https://www.swiper.com.cn/api/loop/loopedSlides.html" target="_blank" rel="noopener noreferrer">loopedSlides</a>。slidesPerView: 'auto'目前还不支持多行模式（当slidesPerColumn &gt; 1）</td>
</tr>
<tr>
<td>slidesPerGroup</td>
<td>number</td>
<td>1</td>
<td>在carousel mode下定义slides的数量多少为一组</td>
</tr>
<tr>
<td>spaceBetween</td>
<td>number</td>
<td>0</td>
<td>在slide之间设置距离（单位px）。</td>
</tr>
<tr>
<td>slidesPerColumn</td>
<td>number</td>
<td>1</td>
<td>多行布局里面每列的slide数量。slidesPerColumn目前还不兼容loop模式（loop: true）。</td>
</tr>
<tr>
<td>slidesPerColumnFill</td>
<td>string</td>
<td>' column'</td>
<td>多行布局中以什么形式填充</td>
</tr>
<tr>
<td>sldiesOffetBefore</td>
<td>number</td>
<td>0</td>
<td>设定slide与左边框的预设偏移量（单位px）。</td>
</tr>
<tr>
<td>sldiesOffetAfter</td>
<td>number</td>
<td>0</td>
<td>设定slide与右边框的预设偏移量（单位px）。</td>
</tr>
<tr>
<td>nomalizeSlideIndex</td>
<td>boolean</td>
<td>true</td>
<td>使你的活动块指示为最左边的那个slide（没开启<a href="https://www.swiper.com.cn/api/Slides_grid/2014/1217/50.html" target="_blank" rel="noopener noreferrer">centeredSlides</a>时）</td>
</tr>
<tr>
<td>centerInsufficientSlides</td>
<td>boolean</td>
<td>false</td>
<td>开启这个参数，当slides的总数小于slidesPerView时，slides居中。不适用于loop模式和slidesPerColumn</td>
</tr>
</tbody>
</table>
<h2 id="free-mode-free模式-抵抗反弹"> free mode(free模式/抵抗反弹)</h2>
<table>
<thead>
<tr>
<th>属性名</th>
<th>属性值</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>freeMode</td>
<td>boolean</td>
<td>false</td>
<td>默认为false，普通模式：slide滑动时只滑动一格，并自动贴合wrapper，设置为true则变为free模式，slide会根据惯性滑动可能不止一格且不会贴合</td>
</tr>
<tr>
<td>freeModeMomentum</td>
<td>boolean</td>
<td>true</td>
<td>free模式动量。free模式下，若设置为false则关闭动量，释放slide之后立即停止不会滑动。</td>
</tr>
<tr>
<td>freeModeMomentumRatio</td>
<td>number</td>
<td>1</td>
<td>free模式动量值（移动惯量）。设置的值越大，当释放slide时的滑动时间越长。默认1s。</td>
</tr>
<tr>
<td>freeModeMomentumVelocityRatio</td>
<td>number</td>
<td>1</td>
<td>free模式惯性速度，设置越大，释放后滑得越快。</td>
</tr>
<tr>
<td>freeModeMomentumBounce</td>
<td>boolean</td>
<td>true</td>
<td>动量反弹。false时禁用free模式下的动量反弹，slides通过惯性滑动到边缘时，无法反弹。注意与<a href="https://www.swiper.com.cn/api/touch/resistance.html" target="_blank" rel="noopener noreferrer">resistance</a>（手动抵抗）区分。</td>
</tr>
<tr>
<td>freeModeMomentumBounceRatio</td>
<td>number</td>
<td>1</td>
<td>值越大产生的边界反弹效果越明显，反弹距离越大。</td>
</tr>
<tr>
<td>freeModeSticky</td>
<td>boolean</td>
<td>false</td>
<td>使得freeMode也能自动贴合。</td>
</tr>
<tr>
<td>freeModeMinimumVelocity</td>
<td>number</td>
<td>0.02</td>
<td>触发FreeMode惯性的最小触摸速度（px/ms），低于这个值不会惯性滑动</td>
</tr>
</tbody>
</table>
<h2 id="loop-环路"> loop(环路)</h2>
<table>
<thead>
<tr>
<th>属性名</th>
<th>属性值</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>loop</td>
<td>boolean</td>
<td>false</td>
<td>设置为true 则开启loop模式。loop模式：会在原本slide前后复制若干个slide(默认一个)并在合适的时候切换，让Swiper看起来是循环的。 loop模式在与free模式同用时会产生抖动，因为free模式下没有复制slide的时间点。</td>
</tr>
<tr>
<td>looAdditionalSlides</td>
<td>number</td>
<td>0</td>
<td>loop模式下会在slides前后复制若干个slide,，前后复制的个数不会大于原总个数。默认为0，前后各复制1个。0,1,2 --&gt; 2,0,1,2,0例：取值为1，0,1,2 --&gt; 1,2,0,1,2,0,1例：取值为2或以上，0,1,2 --&gt; 0,1,2,0,1,2,0,1,2</td>
</tr>
<tr>
<td>loopSlides</td>
<td>number</td>
<td>1</td>
<td>在loop模式下使用slidesPerview:'auto'，还需使用该参数设置所要用到的loop个数(一般设置大于可视slide个数2个即可)。</td>
</tr>
<tr>
<td>loopFillGroupWithBlank</td>
<td>boolean</td>
<td>false</td>
<td>在loop模式下，为group填充空白slide</td>
</tr>
</tbody>
</table>
<p>preogress(进度)</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>属性值</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>watchSlidesProgress</td>
<td>boolean</td>
<td>false</td>
<td>开启这个参数来计算每个slide的progress(进度、进程)，Swiper的progress无需设置即开启。 对于slide的progress属性，活动的那个为0，其他的依次减1。例：如果一共有6个slide，活动的是第三个，从第一个到第六个的progress属性分别是：2、1、0、-1、-2、-3。对于swiper的progress属性，活动的slide在最左（上）边时为0，活动的slide在最右（下）边时为1，其他情况平分。例：有6个slide，当活动的是第三个时swiper的progress属性是0.4，当活动的是第五个时swiper的progress属性是0.8。 swiper的progress其实就是wrapper的translate值的百分值，与activeIndex等属性不同，progress是随着swiper的切换而不停的变化，而不是在某个时间点突变。</td>
</tr>
<tr>
<td>watchSlidesVisibility</td>
<td>boolean</td>
<td>false</td>
<td>开启watchSlidesVisibility选项前需要先开启watchSlidesProgress，如果开启了watchSlidesVisibility，则会在每个可见slide增加一个classname，默认为'swiper-slide-visible'。</td>
</tr>
</tbody>
</table>
<h2 id="clicks-点击"> clicks(点击)</h2>
<table>
<thead>
<tr>
<th>属性名</th>
<th>属性值</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>preventClicks</td>
<td>boolean</td>
<td>true</td>
<td>当swiper在触摸时阻止默认事件（preventDefault），用于防止触摸时触发链接跳转。</td>
</tr>
<tr>
<td>preventClicksPropagation</td>
<td>boolean</td>
<td>true</td>
<td>阻止click冒泡。拖动Swiper时阻止click事件</td>
</tr>
<tr>
<td>slideToClickedSlide</td>
<td>boolean</td>
<td>false</td>
<td>设置为true则点击slide会过渡到这个slide</td>
</tr>
</tbody>
</table>
<h2 id="touches-触发条件"> touches(触发条件)</h2>
<table>
<thead>
<tr>
<th>属性名</th>
<th>属性值</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>touchRatio</td>
<td>number</td>
<td>1</td>
<td>触摸比例。触摸距离与slide滑动距离的比率。默认为1，按照1:1的触摸比例滑动。设置为0时，完全无法滑动</td>
</tr>
<tr>
<td>simulateTouch</td>
<td>boolean</td>
<td>true</td>
<td>鼠标模拟手机触摸。默认为true，Swiper接受鼠标点击、拖动。</td>
</tr>
<tr>
<td>allowTouchMove</td>
<td>boolean</td>
<td>true</td>
<td>允许触摸滑动。设为false时，slide无法滑动，只能使用扩展API函数例如<a href="https://www.swiper.com.cn/api/methods/107.html" target="_blank" rel="noopener noreferrer">slideNext()</a><a href="https://www.swiper.com.cn/api/methods/107.html" target="_blank" rel="noopener noreferrer"> </a>或<a href="https://www.swiper.com.cn/api/methods/108.html" target="_blank" rel="noopener noreferrer">slidePrev()</a>或<a href="https://www.swiper.com.cn/api/methods/109.html" target="_blank" rel="noopener noreferrer">slideTo()</a>等改变slides滑动。等同于Swiper3.x 的 onlyExternal。 有时在PC端制作图片切换会选择关闭。</td>
</tr>
<tr>
<td>followFinger</td>
<td>boolean</td>
<td>true</td>
<td>跟随手指。如设置为false，手指滑动时slide不会动，当你释放时slide才会切换。</td>
</tr>
<tr>
<td>shortSwipes</td>
<td>boolean</td>
<td>true</td>
<td>默认允许短切换。设置为false时，只能长切换，进行快速且短距离的滑动无法触发切换。</td>
</tr>
<tr>
<td>longSwipes</td>
<td>boolean</td>
<td>true</td>
<td>设置为false时，进行长时间长距离的拖动无法触发Swiper。*某些版本无效(4.0.7)</td>
</tr>
<tr>
<td>longSwipesMs</td>
<td>number</td>
<td>300</td>
<td>定义longSwipes的时间（单位ms），超过则属于longSwipes</td>
</tr>
<tr>
<td>longSwipesRatio</td>
<td>number</td>
<td>0.5</td>
<td>进行longSwipes时触发swiper所需要的最小拖动距离比例，即定义longSwipes距离比例。值越大触发Swiper所需距离越大。最大值0.5。</td>
</tr>
</tbody>
</table>
<h2 id="swiper例子"> swiper例子</h2>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
​    <span><span><span>&lt;</span>title</span><span>></span></span>Title<span><span><span>&lt;/</span>title</span><span>></span></span>
​    <span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>"</span>stylesheet<span>"</span></span> <span>href</span><span><span>=</span><span>"</span>https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.0.2/css/swiper.min.css<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>node_modules/jquery/dist/jquery.min.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
    <span><span><span>&lt;</span>style</span><span>></span></span><span><span>
<span>​        .swiper-container</span> <span>{</span>
​            <span>width</span><span>:</span> 400px<span>;</span>
​            <span>height</span><span>:</span> 200px<span>;</span>
​        <span>}</span>
<span>​        .swiper-slide</span><span>{</span>
​            <span>background</span><span>:</span> aqua<span>;</span>
​        <span>}</span>
​    </span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>swiper-container<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>swiper-wrapper<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>swiper-slide<span>"</span></span><span>></span></span>Slide 1<span><span><span>&lt;/</span>div</span><span>></span></span>
        <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>swiper-slide<span>"</span></span><span>></span></span>Slide 2<span><span><span>&lt;/</span>div</span><span>></span></span>
        <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>swiper-slide<span>"</span></span><span>></span></span>Slide 3<span><span><span>&lt;/</span>div</span><span>></span></span>
​    <span><span><span>&lt;/</span>div</span><span>></span></span>
​    <span>&lt;!-- 如果需要分页器 --></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>swiper-pagination<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
​    <span>&lt;!-- 如果需要导航按钮 --></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>swiper-button-prev<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>swiper-button-next<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
​    <span>&lt;!-- 如果需要滚动条 --></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>swiper-scrollbar<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>

<span><span><span>&lt;/</span>div</span><span>></span></span>

<span>&lt;!--导航等组件可以放在container之外--></span>

<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.0.2/js/swiper.min.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span><span>

​    <span>$</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>

​        <span>var</span> mySwiper <span>=</span> <span>new</span> <span>Swiper</span> <span>(</span><span>'.swiper-container'</span><span>,</span> <span>{</span>
​            direction<span>:</span> <span>'vertical'</span><span>,</span> <span>// 垂直切换选项</span>
​            loop<span>:</span> <span>true</span><span>,</span> <span>// 循环模式选项</span>
​            <span>// 如果需要分页器</span>

​            pagination<span>:</span> <span>{</span>

​                el<span>:</span> <span>'.swiper-pagination'</span><span>,</span>

​            <span>}</span><span>,</span>
​            <span>// 如果需要前进后退按钮</span>
​            navigation<span>:</span> <span>{</span>

​                nextEl<span>:</span> <span>'.swiper-button-next'</span><span>,</span>

​                prevEl<span>:</span> <span>'.swiper-button-prev'</span><span>,</span>
​            <span>}</span><span>,</span>
​            <span>// 如果需要滚动条</span>
​            scrollbar<span>:</span> <span>{</span>
​                el<span>:</span> <span>'.swiper-scrollbar'</span><span>,</span>
​            <span>}</span><span>,</span>
​        <span>}</span><span>)</span>
​    <span>}</span><span>)</span>

</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>

<span><span><span>&lt;/</span>body</span><span>></span></span>

<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br></div></div>]]></content>
    <author>
      <name>xiechengyu</name>
    </author>
    <category term="笔记"/>
    <contributor>
      <name>xiechengyu</name>
    </contributor>
    <published>2019-05-26T20:48:17.000Z</published>
    <rights>Copyright by xiechengyu</rights>
  </entry>
  <entry>
    <title type="html">小tip</title>
    <id>https://xiechengyu.github.io/note/%E5%B0%8Ftip/</id>
    <link href="https://xiechengyu.github.io/note/%E5%B0%8Ftip/"/>
    <updated>2022-02-09T03:49:27.000Z</updated>
    <summary type="html"><![CDATA[<h2 id="前言"> 前言</h2>
<p>一些js小tip</p>
]]></summary>
    <content type="html"><![CDATA[<h2 id="前言"> 前言</h2>
<p>一些js小tip</p>

<div><pre><code><span>function</span> <span>getPersonInfo</span><span>(</span><span>one<span>,</span> two<span>,</span> three</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>one<span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>two<span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>three<span>)</span><span>;</span>
<span>}</span>

<span>const</span> person <span>=</span> <span>'Lydia'</span><span>;</span>
<span>const</span> age <span>=</span> <span>21</span><span>;</span>

getPersonInfo<span><span>`</span><span><span>${</span>person<span>}</span></span><span> is </span><span><span>${</span>age<span>}</span></span><span> years old</span><span>`</span></span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>输出是[&quot;&quot;, &quot; is &quot;, &quot; years old&quot;]<code></code>&quot;Lydia&quot;<code></code>21</p>
<p>如果使用带标签的模板文字，则第一个参数的值始终是字符串值的数组。 其余参数获取传递的表达式的值！</p>
<div><pre><code><span>const</span> sum <span>=</span> <span>eval</span><span>(</span><span>'10*10+5'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>输出105</p>
<p>eval评估以字符串形式传递的代码。 如果是表达式（如本例所示），它将对表达式求值。 表达式是10 * 10 +5。这将返回数字105。</p>
<p>continue是跳出本次循环，break是跳出整个循环，return是停止函数</p>
<div><pre><code><span>const</span> a <span>=</span> <span>{</span><span>}</span><span>;</span>
<span>const</span> b <span>=</span> <span>{</span> <span>key</span><span>:</span> <span>'b'</span> <span>}</span><span>;</span>
<span>const</span> c <span>=</span> <span>{</span> <span>key</span><span>:</span> <span>'c'</span> <span>}</span><span>;</span>

a<span>[</span>b<span>]</span> <span>=</span> <span>123</span><span>;</span>
a<span>[</span>c<span>]</span> <span>=</span> <span>456</span><span>;</span>

console<span>.</span><span>log</span><span>(</span>a<span>[</span>b<span>]</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>a[b]和a[c]都将变成a[&quot;[object Object]&quot;]，所以是给同一属性[object Object]赋值</p>
<div><pre><code><span>const</span> person <span>=</span> <span>{</span> <span>name</span><span>:</span> <span>'Lydia'</span> <span>}</span><span>;</span>

<span>function</span> <span>sayHi</span><span>(</span><span>age</span><span>)</span> <span>{</span>
  <span>return</span> <span><span>`</span><span><span>${</span><span>this</span><span>.</span>name<span>}</span></span><span> is </span><span><span>${</span>age<span>}</span></span><span>`</span></span><span>;</span>
<span>}</span>

console<span>.</span><span>log</span><span>(</span><span>sayHi</span><span>.</span><span>call</span><span>(</span>person<span>,</span> <span>21</span><span>)</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>sayHi</span><span>.</span><span>bind</span><span>(</span>person<span>,</span> <span>21</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>输出Lydia is 21<code></code>function</p>
<p>call改变了上下文环境，bind不改变相当于复制了这个方法</p>
<div><pre><code><span>function</span> <span>sayHi</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span><span>(</span><span>)</span> <span>=></span> <span>0</span><span>)</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

console<span>.</span><span>log</span><span>(</span><span>typeof</span> <span>sayHi</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>输出number</p>
<p>调用sayHi()返回立即执行函数的值0，所以是number类型</p>
<p>以下值为假</p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>NaN</code></li>
<li><code>false</code></li>
<li><code>''</code> (empty string)</li>
<li><code>0</code></li>
<li><code>-0</code></li>
<li><code>0n</code> (BigInt(0))</li>
</ul>
<div><pre><code><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>let</span> x<span>,</span> y<span>;</span>
  <span>try</span> <span>{</span>
    <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>)</span><span>;</span>
  <span>}</span> <span>catch</span> <span>(</span>x<span>)</span> <span>{</span>
    <span>(</span>x <span>=</span> <span>1</span><span>)</span><span>,</span> <span>(</span>y <span>=</span> <span>2</span><span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>x<span>)</span><span>;</span>
  <span>}</span>
  console<span>.</span><span>log</span><span>(</span>x<span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>y<span>)</span><span>;</span>
<span>}</span><span>)</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>1 undefined 2</p>
<p>赋值的x是catch块级作用域里的x，y是立即执行函数里的y</p>
<div><pre><code><span>[</span><span>[</span><span>0</span><span>,</span> <span>1</span><span>]</span><span>,</span> <span>[</span><span>2</span><span>,</span> <span>3</span><span>]</span><span>]</span><span>.</span><span>reduce</span><span>(</span>
  <span>(</span><span>acc<span>,</span> cur</span><span>)</span> <span>=></span> <span>{</span>
    <span>return</span> acc<span>.</span><span>concat</span><span>(</span>cur<span>)</span><span>;</span>
  <span>}</span><span>,</span>
  <span>[</span><span>1</span><span>,</span> <span>2</span><span>]</span><span>,</span>
<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code>array<span>.</span><span>reduce</span><span>(</span><span>function</span><span>(</span><span>total<span>,</span> currentValue<span>,</span> currentIndex<span>,</span> arr</span><span>)</span><span>,</span> initialValue<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><em>function(total,currentValue, index,arr)</em></td>
<td style="text-align:left">必需。用于执行每个数组元素的函数。 函数参数:参数描述<em>total</em>必需。<em>初始值</em>, 或者计算结束后的返回值。<em>currentValue</em>必需。当前元素<em>currentIndex</em>可选。当前元素的索引<em>arr</em>可选。当前元素所属的数组对象。</td>
</tr>
<tr>
<td style="text-align:left"><em>initialValue</em></td>
<td style="text-align:left">可选。传递给函数的初始值</td>
</tr>
</tbody>
</table>
<p>输出[1, 2, 0, 1, 2, 3]</p>
<p>初始值为[1, 2]，第一个cur是[0,1]，concat之后是[1,2,0,1]，第二个cur是[2,3]，concat之后是[1,2,0,1,2,3]</p>
<p>Map对象</p>
<p>一组键值对的结构，具有极快的查找速度。</p>
<p>初始化<code>Map</code>需要一个二维数组，或者直接初始化一个空<code>Map</code>  new Map()或new Map([[],[]])</p>
<p>内置方法：set(&quot;a&quot;,&quot;b&quot;)设置对应的键值对，has(&quot;a&quot;)检查是否存在对应key，get(&quot;a&quot;)获取对应key的value值，delete(&quot;a&quot;)删除对应的key的键值对。</p>
<p>每一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值重新赋值。</p>
<p>Set对象</p>
<p><code>Set</code>和<code>Map</code>类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在<code>Set</code>中，没有重复的key。</p>
<p>创建一个<code>Set</code>，需要提供一个<code>Array</code>作为输入，或者直接创建一个空<code>Set</code> new Set() 或 new Set([])</p>
<p>重复元素在<code>Set</code>中自动被过滤</p>
<p>内置方法有：add(&quot;a&quot;)增加对应key，可重复添加但只存在一个，delete(&quot;a&quot;)删除对应的key值，has(&quot;a&quot;)检查是否存在该key值，clear()清除所有项。</p>
<p>flat()扁平化数组</p>
<div><pre><code><span>//方法的传参是要扁平化几层</span>
<span>//使用 Infinity，可展开任意深度的嵌套数组</span>
arr4<span>.</span><span>flat</span><span>(</span><span>Infinity</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>稀疏数组 对于没有内容的数组项, array 上的操作会跳过这些未初始化的'坑'.如：[&quot;1&quot;, empty × 2]</p>
<p>子函数被外部使用父级环境将被保留</p>
<p>promise的链式操作：</p>
<p>每一个then都返回一个promise状态是fulfulied；当return一个promise时需等待改promise执行状态变为fulfulied或rejected</p>
<p>如果是 <code>thenable</code> 对象，会将对象包装成promise处理，这与其他promise处理方式一样的</p>
]]></content>
    <author>
      <name>xiechengyu</name>
    </author>
    <category term="笔记"/>
    <contributor>
      <name>xiechengyu</name>
    </contributor>
    <published>2021-06-24T12:21:42.000Z</published>
    <rights>Copyright by xiechengyu</rights>
  </entry>
  <entry>
    <title type="html">使容器具有透明度</title>
    <id>https://xiechengyu.github.io/note/%E4%BD%BF%E5%AE%B9%E5%99%A8%E6%9C%89%E9%80%8F%E6%98%8E%E5%BA%A6/</id>
    <link href="https://xiechengyu.github.io/note/%E4%BD%BF%E5%AE%B9%E5%99%A8%E6%9C%89%E9%80%8F%E6%98%8E%E5%BA%A6/"/>
    <updated>2022-02-08T07:39:18.000Z</updated>
    <summary type="html"><![CDATA[<h1 id="前言"> 前言</h1>
<p>需要在点击某个按钮之后出现弹层，但是我在一开始写弹层的时候是直接使包裹外部的弹层具有opcity属性，但是结果发现里面本该显示的弹层的内容也继承了其opcity属性，由此我就自己找出了几个解决方法。</p>
]]></summary>
    <content type="html"><![CDATA[<h1 id="前言"> 前言</h1>
<p>需要在点击某个按钮之后出现弹层，但是我在一开始写弹层的时候是直接使包裹外部的弹层具有opcity属性，但是结果发现里面本该显示的弹层的内容也继承了其opcity属性，由此我就自己找出了几个解决方法。</p>

<h1 id="遇到的问题"> 遇到的问题</h1>
<div><pre><code><span>&lt;!-- html部分 --></span>
<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>div1<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>div2<span>"</span></span><span>></span></span>haha<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span>// css部分
 body</span><span>{</span>
     <span>background</span><span>:</span> #00f<span>;</span>
 <span>}</span>
<span>.div1</span> <span>{</span>
     <span>width</span><span>:</span> 500px<span>;</span>
     <span>height</span><span>:</span> 500px<span>;</span>
     <span>background</span><span>:</span> #000<span>;</span>
     <span>opacity</span><span>:</span> 0.4<span>;</span>
     <span>position</span><span>:</span> relative<span>;</span>
 <span>}</span>
 <span>.div1 .div2</span> <span>{</span>
            <span>background</span><span>:</span> #f00<span>;</span>
            <span>width</span><span>:</span> 200px<span>;</span>
            <span>height</span><span>:</span> 200px<span>;</span>
            <span>position</span><span>:</span> absolute<span>;</span>
            <span>left</span><span>:</span> 50%<span>;</span>
            <span>top</span><span>:</span> 50%<span>;</span>
            <span>margin-left</span><span>:</span> -100px<span>;</span>
            <span>margin-top</span><span>:</span> -100px<span>;</span>
            <span>opacity</span><span>:</span> 1<span>;</span>
 <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>最后显示的样式是这样的，里面的颜色明显受到其父容器opcity元素的影响。</p>
<p><img src="/assets/img/tou/t1.png" alt="t1" loading="lazy"></p>
<p>那我们应该怎么解决呢。</p>
<h1 id="解决方法"> 解决方法</h1>
<h2 id="使用一张透明的图片做背景可以达成效果"> 使用一张透明的图片做背景可以达成效果</h2>
<p>就是说把div1直接用一张透明的图片作为背景。</p>
<p>改过后的css代码如下：</p>
<div><pre><code><span>body</span><span>{</span>
   <span>background</span><span>:</span> #00f<span>;</span>
<span>}</span>
<span>.div1</span> <span>{</span>
     <span>width</span><span>:</span> 500px<span>;</span>
     <span>height</span><span>:</span> 500px<span>;</span>
     <span>background</span><span>:</span> <span><span>url</span><span>(</span><span>"/assets/img/tou/t2.png"</span><span>)</span></span><span>;</span>
     <span>position</span><span>:</span> relative<span>;</span>
<span>}</span>
<span>.div1 .div2</span> <span>{</span>
          <span>background</span><span>:</span> #f00<span>;</span>
          <span>width</span><span>:</span> 200px<span>;</span>
          <span>height</span><span>:</span> 200px<span>;</span>
          <span>position</span><span>:</span> absolute<span>;</span>
          <span>left</span><span>:</span> 50%<span>;</span>
          <span>top</span><span>:</span> 50%<span>;</span>
          <span>margin-left</span><span>:</span> -100px<span>;</span>
          <span>margin-top</span><span>:</span> -100px<span>;</span>
          <span>opacity</span><span>:</span> 1<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>最后的显示如下：</p>
<p><img src="/assets/img/tou/t3.png" alt="t3" loading="lazy"></p>
<h2 id="使用rgba属性来完成"> 使用rgba属性来完成</h2>
<p>我们知道<strong>RGBA</strong>是代表<strong>R</strong>ed（<a href="https://baike.baidu.com/item/%E7%BA%A2%E8%89%B2" target="_blank" rel="noopener noreferrer">红色</a>）<strong>G</strong>reen（<a href="https://baike.baidu.com/item/%E7%BB%BF%E8%89%B2" target="_blank" rel="noopener noreferrer">绿色</a>）<strong>B</strong>lue（<a href="https://baike.baidu.com/item/%E8%93%9D%E8%89%B2" target="_blank" rel="noopener noreferrer">蓝色</a>）和<strong>A</strong>lpha的<a href="https://baike.baidu.com/item/%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4" target="_blank" rel="noopener noreferrer">色彩空间</a>。而其中的Alpha的用法和opcity的用法很相似，所以我们所期望的效果背景为黑，且透明度为0.4可以这样来实现。</p>
<p>其改后的css代码如下：</p>
<div><pre><code><span>body</span><span>{</span>
   <span>background</span><span>:</span> #00f<span>;</span>
<span>}</span>
<span>.div1</span> <span>{</span>
     <span>width</span><span>:</span> 500px<span>;</span>
     <span>height</span><span>:</span> 500px<span>;</span>
     <span>background</span><span>:</span> <span><span>url</span><span>(</span><span>"/assets/img/tou/t2.png"</span><span>)</span></span><span>;</span>
     <span>position</span><span>:</span> relative<span>;</span>
<span>}</span>
<span>.div1 .div2</span> <span>{</span>
          <span>background</span><span>:</span> #f00<span>;</span>
          <span>width</span><span>:</span> 200px<span>;</span>
          <span>height</span><span>:</span> 200px<span>;</span>
          <span>position</span><span>:</span> absolute<span>;</span>
          <span>left</span><span>:</span> 50%<span>;</span>
          <span>top</span><span>:</span> 50%<span>;</span>
          <span>margin-left</span><span>:</span> -100px<span>;</span>
          <span>margin-top</span><span>:</span> -100px<span>;</span>
          <span>opacity</span><span>:</span> 1<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p><img src="/assets/img/tou/t4.png" alt="t4" loading="lazy"></p>
<p>我们看到也能实现其效果。</p>
<p>大概就是这样了，希望日后再遇到能够有更多方法解决！！！</p>
]]></content>
    <author>
      <name>xiechengyu</name>
    </author>
    <category term="笔记"/>
    <contributor>
      <name>xiechengyu</name>
    </contributor>
    <published>2018-11-20T14:56:01.000Z</published>
    <rights>Copyright by xiechengyu</rights>
  </entry>
  <entry>
    <title type="html">箭头函数</title>
    <id>https://xiechengyu.github.io/note/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</id>
    <link href="https://xiechengyu.github.io/note/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <updated>2022-02-08T07:39:18.000Z</updated>
    <summary type="html"><![CDATA[<h1 id="前言"> 前言</h1>
<p>这是我在学习es6时学习到的知识，最近看到之前写的就把它放到博客上。</p>
]]></summary>
    <content type="html"><![CDATA[<h1 id="前言"> 前言</h1>
<p>这是我在学习es6时学习到的知识，最近看到之前写的就把它放到博客上。</p>

<h1 id="es6箭头函数-arrow-functions"> ES6箭头函数（Arrow Functions）</h1>
<p>ES6可以使用“箭头”（=&gt;）定义函数，注意是函数，不要使用这种方式定义类（构造器）。</p>
<h2 id="_1-语法"> 1. 语法</h2>
<ol>
<li>具有一个参数的简单函数</li>
</ol>
<div><pre><code><span>var</span> <span>single</span> <span>=</span> <span>a</span> <span>=></span> a
<span>single</span><span>(</span><span>'hello, world'</span><span>)</span> <span>// 'hello, world'</span>
　　
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol start="2">
<li>没有参数的需要用在箭头前加上小括号</li>
</ol>
<div><pre><code><span>var</span> <span>log</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>alert</span><span>(</span><span>'no param'</span><span>)</span>
<span>}</span>
　　
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ol start="3">
<li>多个参数需要用到小括号，参数间逗号间隔，例如两个数字相加</li>
</ol>
<div><pre><code><span>var</span> <span>add</span> <span>=</span> <span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a <span>+</span> b
<span>add</span><span>(</span><span>3</span><span>,</span> <span>8</span><span>)</span> <span>// 11</span>
　　
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol start="4">
<li>函数体多条语句需要用到大括号</li>
</ol>
<div><pre><code><span>var</span> <span>add</span> <span>=</span> <span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span><span>typeof</span> a <span>==</span> <span>'number'</span> <span>&amp;&amp;</span> <span>typeof</span> b <span>==</span> <span>'number'</span><span>)</span> <span>{</span>
        <span>return</span> a <span>+</span> b
    <span>}</span> <span>else</span> <span>{</span>
        <span>return</span> <span>0</span>
    <span>}</span>
<span>}</span>
　　
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ol start="5">
<li>返回对象时需要用小括号包起来，因为大括号被占用解释为代码块了</li>
</ol>
<div><pre><code><span>var</span> <span>getHash</span> <span>=</span> <span>arr</span> <span>=></span> <span>{</span>
    <span>// ...</span>
    <span>return</span> <span>(</span><span>{</span>
        <span>name</span><span>:</span> <span>'Jack'</span><span>,</span>
        <span>age</span><span>:</span> <span>33</span>
    <span>}</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p></p>
<ol start="6">
<li>直接作为事件handler</li>
</ol>
<div><pre><code>document<span>.</span><span>addEventListener</span><span>(</span><span>'click'</span><span>,</span> <span>ev</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>ev<span>)</span>
<span>}</span><span>)</span>
　　
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ol start="7">
<li>作为数组排序回调</li>
</ol>
<div><pre><code><span>var</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span> <span>9</span> <span>,</span> <span>2</span><span>,</span> <span>4</span><span>,</span> <span>3</span><span>,</span> <span>8</span><span>]</span><span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span>a <span>-</span> b <span>></span> <span>0</span> <span>)</span> <span>{</span>
        <span>return</span> <span>1</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>return</span> <span>-</span><span>1</span>
    <span>}</span>
<span>}</span><span>)</span>
arr <span>// [1, 2, 3, 4, 8, 9]</span>
　　
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="_2-注意点"> 2. 注意点</h2>
<ol>
<li>typeof运算符和普通的function一样</li>
</ol>
<div><pre><code><span>var</span> <span>func</span> <span>=</span> <span>a</span> <span>=></span> a
console<span>.</span><span>log</span><span>(</span><span>typeof</span> func<span>)</span><span>;</span> <span>// "function"</span>
　　
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol start="2">
<li>instanceof也返回true，表明也是Function的实例</li>
</ol>
<div><pre><code>console<span>.</span><span>log</span><span>(</span>func <span>instanceof</span> <span>Function</span><span>)</span><span>;</span> <span>// true</span>
　　
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol start="3">
<li>this固定，不再善变</li>
</ol>
<div><pre><code>obj <span>=</span> <span>{</span>
    <span>data</span><span>:</span> <span>[</span><span>'John Backus'</span><span>,</span> <span>'John Hopcroft'</span><span>]</span><span>,</span>
    <span>init</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
        document<span>.</span><span>onclick</span> <span>=</span> <span>ev</span> <span>=></span> <span>{</span>
            <span>alert</span><span>(</span><span>this</span><span>.</span>data<span>)</span> <span>// ['John Backus', 'John Hopcroft']</span>
        <span>}</span>
        <span>// 非箭头函数</span>
        <span>// document.onclick = function(ev) {</span>
        <span>//     alert(this.data) // undefined</span>
        <span>// }</span>
    <span>}</span>
<span>}</span>
obj<span>.</span><span>init</span><span>(</span><span>)</span>
<span>//这个很有用，再不用写me，self，_this了，或者bind。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><ol start="4">
<li>箭头函数不能用new</li>
</ol>
<div><pre><code><span>var</span> <span>Person</span> <span>=</span> <span>(</span><span>name<span>,</span> age</span><span>)</span> <span>=></span> <span>{</span>
    <span>this</span><span>.</span>name <span>=</span> name
    <span>this</span><span>.</span>age <span>=</span> age
<span>}</span>
<span>var</span> p <span>=</span> <span>new</span> <span>Func</span><span>(</span><span>'John'</span><span>,</span> <span>33</span><span>)</span> <span>// error</span>
　　
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ol start="5">
<li>不能使用argument</li>
</ol>
<div><pre><code><span>var</span> <span>func</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>arguments<span>)</span>
<span>}</span>
<span>func</span><span>(</span><span>55</span><span>)</span> <span>//</span>
　　
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>总结了一些之前查询的关于箭头函数的知识，大部分是通过复制粘贴下来的，为的是方便日后的查询</p>
]]></content>
    <author>
      <name>xiechengyu</name>
    </author>
    <category term="笔记"/>
    <contributor>
      <name>xiechengyu</name>
    </contributor>
    <published>2019-06-03T09:07:17.000Z</published>
    <rights>Copyright by xiechengyu</rights>
  </entry>
  <entry>
    <title type="html">Home</title>
    <id>https://xiechengyu.github.io/</id>
    <link href="https://xiechengyu.github.io/"/>
    <updated>2022-06-23T07:08:21.000Z</updated>
    <author>
      <name>xiechengyu</name>
    </author>
    <contributor>
      <name>xiechengyu</name>
    </contributor>
    <published>2022-02-08T07:39:18.000Z</published>
    <rights>Copyright by xiechengyu</rights>
  </entry>
  <entry>
    <title type="html">sass语法总结</title>
    <id>https://xiechengyu.github.io/reprint/sass%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <link href="https://xiechengyu.github.io/reprint/sass%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <updated>2022-02-08T07:39:18.000Z</updated>
    <summary type="html"><![CDATA[<h1 id="前言"> 前言</h1>
<p>文章相关内容转载自：<a href="https://www.jianshu.com/p/e139d449f5bb" target="_blank" rel="noopener noreferrer">sass语法总结</a></p>
<p>作者：xoyoz</p>
<p>來源：简书</p>
]]></summary>
    <content type="html"><![CDATA[<h1 id="前言"> 前言</h1>
<p>文章相关内容转载自：<a href="https://www.jianshu.com/p/e139d449f5bb" target="_blank" rel="noopener noreferrer">sass语法总结</a></p>
<p>作者：xoyoz</p>
<p>來源：简书</p>

<h2 id="scss-和-sass语法的相互转换"> scss 和 sass语法的相互转换</h2>
<div><pre><code># Convert Sass to SCSS
$ sass-convert style.sass style.scss

# Convert SCSS to Sass
$ sass-convert style.scss style.sass
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h1 id="编译"> 编译</h1>
<h2 id="命令行编译"> 命令行编译</h2>
<div><pre><code>#单文件
sass --watch input.<span>scss</span><span>:</span>output.css
#多文件
sass --watch app/<span>sass</span><span>:</span>public/stylesheets

# --wacth 自动编译
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="gui-界面工具编译"> GUI 界面工具编译</h2>
<p><a href="https://github.com/xiechengyu" target="_blank" rel="noopener noreferrer">Koala</a></p>
<p><a href="https://link.jianshu.com/?t=http://compass.kkbox.com/" target="_blank" rel="noopener noreferrer">Compass.app</a></p>
<p><a href="https://link.jianshu.com/?t=http://mhs.github.io/scout-app/" target="_blank" rel="noopener noreferrer">Scout</a></p>
<p><a href="https://link.jianshu.com/?t=https://incident57.com/codekit/index.html" target="_blank" rel="noopener noreferrer">CodeKit</a></p>
<p><a href="https://link.jianshu.com/?t=https://prepros.io/" target="_blank" rel="noopener noreferrer">Prepros</a></p>
<h2 id="自动化编译"> 自动化编译</h2>
<p>Grunt 配置 Sass 编译的示例代码</p>
<div><pre><code>module<span>.</span><span>exports</span> <span>=</span> <span>function</span><span>(</span><span>grunt</span><span>)</span> <span>{</span>
    grunt<span>.</span><span>initConfig</span><span>(</span><span>{</span>
        <span>pkg</span><span>:</span> grunt<span>.</span>file<span>.</span><span>readJSON</span><span>(</span><span>'package.json'</span><span>)</span><span>,</span>
        <span>sass</span><span>:</span> <span>{</span>
            <span>dist</span><span>:</span> <span>{</span>
                <span>files</span><span>:</span> <span>{</span>
                    <span>'style/style.css'</span> <span>:</span> <span>'sass/style.scss'</span>
                <span>}</span>
            <span>}</span>
        <span>}</span><span>,</span>
        <span>watch</span><span>:</span> <span>{</span>
            <span>css</span><span>:</span> <span>{</span>
                <span>files</span><span>:</span> <span>'**/*.scss'</span><span>,</span>
                <span>tasks</span><span>:</span> <span>[</span><span>'sass'</span><span>]</span>
            <span>}</span>
        <span>}</span>
    <span>}</span><span>)</span><span>;</span>
    grunt<span>.</span><span>loadNpmTasks</span><span>(</span><span>'grunt-contrib-sass'</span><span>)</span><span>;</span>
    grunt<span>.</span><span>loadNpmTasks</span><span>(</span><span>'grunt-contrib-watch'</span><span>)</span><span>;</span>
    grunt<span>.</span><span>registerTask</span><span>(</span><span>'default'</span><span>,</span><span>[</span><span>'watch'</span><span>]</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>Gulp 配置 Sass 编译的示例代码</p>
<div><pre><code><span>var</span> gulp <span>=</span> <span>require</span><span>(</span><span>'gulp'</span><span>)</span><span>;</span>
<span>var</span> sass <span>=</span> <span>require</span><span>(</span><span>'gulp-sass'</span><span>)</span><span>;</span>

gulp<span>.</span><span>task</span><span>(</span><span>'sass'</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    gulp<span>.</span><span>src</span><span>(</span><span>'./scss/*.scss'</span><span>)</span>
        <span>.</span><span>pipe</span><span>(</span><span>sass</span><span>(</span><span>)</span><span>)</span>
        <span>.</span><span>pipe</span><span>(</span>gulp<span>.</span><span>dest</span><span>(</span><span>'./css'</span><span>)</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

gulp<span>.</span><span>task</span><span>(</span><span>'watch'</span><span>,</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
    gulp<span>.</span><span>watch</span><span>(</span><span>'scss/*.scss'</span><span>,</span> <span>[</span><span>'sass'</span><span>]</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

gulp<span>.</span><span>task</span><span>(</span><span>'default'</span><span>,</span> <span>[</span><span>'sass'</span><span>,</span><span>'watch'</span><span>]</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="编译错误"> 编译错误</h2>
<p>1.要用UTF-8
2.文件路径及文件名不要用中文</p>
<h2 id="输出方式"> 输出方式</h2>
<p>1.嵌套输出方式 nested</p>
<div><pre><code>$ sass --watch test.<span>scss</span><span>:</span>test.css --style nested
</code></pre>
<div><span>1</span><br></div></div><p>编译出来的CSS风格</p>
<div><pre><code> <span>nav ul</span> <span>{</span>
  <span>margin</span><span>:</span> 0<span>;</span>
  <span>padding</span><span>:</span> 0<span>;</span>
  <span>list-style</span><span>:</span> none<span>;</span> <span>}</span>
<span>nav li</span> <span>{</span>
  <span>display</span><span>:</span> inline-block<span>;</span> <span>}</span>
<span>nav a</span> <span>{</span>
  <span>display</span><span>:</span> block<span>;</span>
  <span>padding</span><span>:</span> 6px 12px<span>;</span>
  <span>text-decoration</span><span>:</span> none<span>;</span> <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>2.展开输出方式 expanded（默认样式）</p>
<div><pre><code>$ sass --watch test.<span>scss</span><span>:</span>test.css --style expanded
</code></pre>
<div><span>1</span><br></div></div><p>编译出来的CSS风格</p>
<div><pre><code><span>nav ul</span> <span>{</span>
  <span>margin</span><span>:</span> 0<span>;</span>
  <span>padding</span><span>:</span> 0<span>;</span>
  <span>list-style</span><span>:</span> none<span>;</span>
<span>}</span>
<span>nav li</span> <span>{</span>
  <span>display</span><span>:</span> inline-block<span>;</span>
<span>}</span>
<span>nav a</span> <span>{</span>
  <span>display</span><span>:</span> block<span>;</span>
  <span>padding</span><span>:</span> 6px 12px<span>;</span>
  <span>text-decoration</span><span>:</span> none<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>3.紧凑输出方式 compact</p>
<div><pre><code>sass --watch test.<span>scss</span><span>:</span>test.css --style compact
</code></pre>
<div><span>1</span><br></div></div><p>编译出来的CSS风格</p>
<div><pre><code><span>nav ul</span> <span>{</span> <span>margin</span><span>:</span> 0<span>;</span> <span>padding</span><span>:</span> 0<span>;</span> <span>list-style</span><span>:</span> none<span>;</span> <span>}</span>
<span>nav li</span> <span>{</span> <span>display</span><span>:</span> inline-block<span>;</span> <span>}</span>
<span>nav a</span> <span>{</span> <span>display</span><span>:</span> block<span>;</span> <span>padding</span><span>:</span> 6px 12px<span>;</span> <span>text-decoration</span><span>:</span> none<span>;</span> <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>4.压缩输出方式 compressed</p>
<div><pre><code>sass --watch test.<span>scss</span><span>:</span>test.css --style compressed
</code></pre>
<div><span>1</span><br></div></div><p>编译出来的CSS风格</p>
<div><pre><code><span>nav ul</span><span>{</span><span>margin</span><span>:</span>0<span>;</span><span>padding</span><span>:</span>0<span>;</span><span>list-style</span><span>:</span>none<span>}</span><span>nav li</span><span>{</span><span>display</span><span>:</span>inline-block<span>}</span><span>nav a</span><span>{</span><span>display</span><span>:</span>block<span>;</span><span>padding</span><span>:</span>6px 12px<span>;</span><span>text-decoration</span><span>:</span>none<span>}</span>
</code></pre>
<div><span>1</span><br></div></div><h1 id="基础"> 基础</h1>
<h2 id="变量"> 变量</h2>
<h3 id="声明变量"> 声明变量</h3>
<p>sass离不开$</p>
<div><pre><code>$<span>width</span> <span>:</span> 300px<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="普通变量-默认变量"> 普通变量 &amp; 默认变量</h3>
<div><pre><code>$<span>fontSize</span><span>:</span> 12px<span>;</span>
<span>body</span><span>{</span>
    <span>font-size</span><span>:</span>$fontSize<span>;</span>
<span>}</span>
$<span>baseLineHeight</span><span>:</span>1.5 !default<span>;</span>
<span>body</span><span>{</span>
    <span>line-height</span><span>:</span> $baseLineHeight<span>;</span> 
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="局部变量-全局变量-3-4"> 局部变量 &amp; 全局变量（3.4+）</h3>
<div><pre><code>//SCSS
$<span>color</span><span>:</span> orange !default<span>;</span>//定义全局变量
<span>.block</span> <span>{</span>
  <span>color</span><span>:</span> $color<span>;</span>//调用全局变量
<span>}</span>
<span>em</span> <span>{</span>
  $<span>color</span><span>:</span> red<span>;</span>//定义局部变量（全局变量 <span>$color 的影子）
  a</span> <span>{</span>
    <span>color</span><span>:</span> $color<span>;</span>//调用局部变量
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="嵌套"> 嵌套</h2>
<h3 id="选择器嵌套"> 选择器嵌套</h3>
<div><pre><code><span>nav</span> <span>{</span>
  <span>a</span> <span>{</span>
    <span>color</span><span>:</span> red<span>;</span>

    <span>header &amp;</span> <span>{</span>
      <span>color</span><span>:</span>green<span>;</span>
    <span>}</span>
  <span>}</span>  
<span>}</span>
<span>nav a</span> <span>{</span>
  <span>color</span><span>:</span>red<span>;</span>
<span>}</span>

<span>header nav a</span> <span>{</span>
  <span>color</span><span>:</span>green<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>其中<code>&amp;</code>代表其所在位置的所有长辈元素</p>
<h3 id="属性嵌套"> 属性嵌套</h3>
<p>主要用于padding ，margin，font等属性</p>
<div><pre><code><span>.box</span> <span>{</span>
  <span>border:</span> <span>{</span>
   <span>top</span><span>:</span> 1px solid red<span>;</span>
   <span>bottom</span><span>:</span> 1px solid green<span>;</span>
  <span>}</span>
<span>}</span>
<span>.box</span> <span>{</span>
    <span>border-top</span><span>:</span> 1px solid red<span>;</span>
    <span>border-bottom</span><span>:</span> 1px solid green<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="伪类嵌套"> 伪类嵌套</h3>
<div><pre><code><span>.clearfix</span><span>{</span>
<span>&amp;:before,
&amp;:after</span> <span>{</span>
    <span>content</span><span>:</span><span>""</span><span>;</span>
    <span>display</span><span>:</span> table<span>;</span>
  <span>}</span>
<span>}</span>
<span>clearfix:before, .clearfix:after</span> <span>{</span>
  <span>content</span><span>:</span> <span>""</span><span>;</span>
  <span>display</span><span>:</span> table<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="混合宏"> 混合宏</h2>
<h3 id="声明混合宏-mixin"> 声明混合宏@mixin</h3>
<p>1.不带参数的混合宏</p>
<div><pre><code><span><span>@mixin</span> border-radius</span><span>{</span>
    <span>-webkit-border-radius</span><span>:</span> 5px<span>;</span>
    <span>border-radius</span><span>:</span> 5px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>2.带参数的混合宏</p>
<div><pre><code>//一个参数时，可以指定默认值
<span><span>@mixin</span> <span>border-radius</span><span>(</span>$<span>radius</span><span>:</span>5px<span>)</span></span><span>{</span>//此时的5px为默认参数，传入其他值时覆盖该值
    <span>-webkit-border-radius</span><span>:</span> $radius<span>;</span>
    <span>border-radius</span><span>:</span> $radius<span>;</span>
<span>}</span>
//传2个参数
<span><span>@mixin</span> <span>center</span><span>(</span>$width<span>,</span> $height<span>)</span></span><span>{</span>
...
<span>}</span>
//参数过多 ，一个特别的参数 （...）
<span><span>@mixin</span> <span>box-shadow</span><span>(</span>$shadows...<span>)</span></span><span>{</span>
  <span><span>@if</span> <span>length</span><span>(</span>$shadows<span>)</span> >= 1</span> <span>{</span>
    <span>-webkit-box-shadow</span><span>:</span> $shadows<span>;</span>
    <span>box-shadow</span><span>:</span> $shadows<span>;</span>
  <span>}</span> <span><span>@else</span></span> <span>{</span>
    $<span>shadows</span><span>:</span> 0 0 2px <span>rgba</span><span>(</span>#000<span>,</span>.25<span>)</span><span>;</span>
    <span>-webkit-box-shadow</span><span>:</span> $shadow<span>;</span>
    <span>box-shadow</span><span>:</span> $shadow<span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>3.复杂的混合宏</p>
<div><pre><code><span><span>@maxin</span> <span>box-shadow</span><span>(</span>$shadow..<span>)</span></span><span>{</span>
    <span><span>@if</span> <span>length</span><span>(</span>$shadow<span>)</span> >= 1</span><span>{</span>
        <span><span>@include</span> <span>prefixer</span><span>(</span>box-shadow<span>,</span> $shadow<span>)</span><span>;</span></span>
    <span>}</span> <span><span>@else</span></span> <span>{</span>
        $<span>shadow</span><span>:</span>0 0 4px <span>rgba</span><span>(</span>0<span>,</span>0<span>,</span>0<span>,</span>.3<span>)</span><span>;</span>
        <span><span>@include</span> <span>prefixer</span><span>(</span>box-shadow<span>,</span> $shadow<span>)</span><span>;</span></span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="调用混合宏-include"> 调用混合宏@include</h3>
<div><pre><code><span>button</span><span>{</span>
    <span><span>@include</span> border-radius<span>;</span></span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="不足之处"> 不足之处</h3>
<p>会产生冗余的代码块，如：</p>
<div><pre><code><span><span>@mixin</span> border-radius</span><span>{</span>
  <span>-webkit-border-radius</span><span>:</span> 3px<span>;</span>
  <span>border-radius</span><span>:</span> 3px<span>;</span>
<span>}</span>

<span>.box</span> <span>{</span>
  <span><span>@include</span> border-radius<span>;</span></span>
  <span>margin-bottom</span><span>:</span> 5px<span>;</span>
<span>}</span>

<span>.btn</span> <span>{</span>
  <span><span>@include</span> border-radius<span>;</span></span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>编译生成的CSS为</p>
<div><pre><code><span>.box</span> <span>{</span>
  <span>-webkit-border-radius</span><span>:</span> 3px<span>;</span>
  <span>border-radius</span><span>:</span> 3px<span>;</span>
  <span>margin-bottom</span><span>:</span> 5px<span>;</span>
<span>}</span>

<span>.btn</span> <span>{</span>
  <span>-webkit-border-radius</span><span>:</span> 3px<span>;</span>
  <span>border-radius</span><span>:</span> 3px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>而理想的CSS为</p>
<div><pre><code><span>.box, .btn</span><span>{</span>
    <span>-webkit-border-radius</span><span>:</span> 3px<span>;</span>
    <span>border-radius</span><span>:</span> 3px<span>;</span>
<span>}</span>
<span>.box</span><span>{</span>
    <span>margin-bottom</span><span>:</span> 5px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="占位符-placeholder"> 占位符%placeholder</h2>
<p>通过%placeholder声明的代码，如果不被@extend调用的话，不会产生任何代码</p>
<div><pre><code><span>%mt5</span> <span>{</span>
  <span>margin-top</span><span>:</span> 5px<span>;</span>
<span>}</span>
<span>%pt5</span><span>{</span>
  <span>padding-top</span><span>:</span> 5px<span>;</span>
<span>}</span>

<span>.btn</span> <span>{</span>
  <span><span>@extend</span> %mt5<span>;</span></span>
  <span><span>@extend</span> %pt5<span>;</span></span>
<span>}</span>

<span>.block</span> <span>{</span>
  <span><span>@extend</span> %mt5<span>;</span></span>

  <span>span</span> <span>{</span>
    <span><span>@extend</span> %pt5<span>;</span></span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>编译出来的CSS</p>
<div><pre><code><span>.btn, .block</span> <span>{</span>
  <span>margin-top</span><span>:</span> 5px<span>;</span>
<span>}</span>

<span>.btn, .block span</span> <span>{</span>
  <span>padding-top</span><span>:</span> 5px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="拓展-继承-extend"> <a name="extend">拓展/继承@extend</a></h2>
<p>通过关键词 <code>@extend</code>来继承已经存在的样式块</p>
<div><pre><code><span>.btn</span> <span>{</span>
  <span>border</span><span>:</span> 1px solid #ccc<span>;</span>
  <span>padding</span><span>:</span> 6px 10px<span>;</span>
  <span>font-size</span><span>:</span> 14px<span>;</span>
<span>}</span>

<span>.btn-primary</span> <span>{</span>
  <span>background-color</span><span>:</span> #f36<span>;</span>
  <span>color</span><span>:</span> #fff<span>;</span>
  <span><span>@extend</span> .btn<span>;</span></span>
<span>}</span>

<span>.btn-second</span> <span>{</span>
  <span>background-color</span><span>:</span> orange<span>;</span>
  <span>color</span><span>:</span> #fff<span>;</span>
  <span><span>@extend</span> .btn<span>;</span></span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>生成的CSS</p>
<div><pre><code><span>.btn, .btn-primary, .btn-second</span> <span>{</span>
  <span>border</span><span>:</span> 1px solid #ccc<span>;</span>
  <span>padding</span><span>:</span> 6px 10px<span>;</span>
  <span>font-size</span><span>:</span> 14px<span>;</span>
<span>}</span>
<span>//代码进行了合并

.btn-primary</span> <span>{</span>
  <span>background-color</span><span>:</span> #f36<span>;</span>
  <span>color</span><span>:</span> #fff<span>;</span>
<span>}</span>

<span>.btn-second</span> <span>{</span>
  <span>background-clor</span><span>:</span> orange<span>;</span>
  <span>color</span><span>:</span> #fff<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="中途小结"> 中途小结</h2>
<table>
<thead>
<tr>
<th>-</th>
<th>混合宏</th>
<th>占位符</th>
<th>继承</th>
</tr>
</thead>
<tbody>
<tr>
<td>声明方式</td>
<td>@mixin</td>
<td>%placeholder</td>
<td>.class</td>
</tr>
<tr>
<td>调用方式</td>
<td>@include</td>
<td>@extend</td>
<td>@extend</td>
</tr>
<tr>
<td>特色</td>
<td>可以传参</td>
<td>合并代码</td>
<td>不调用，不产生代码</td>
</tr>
</tbody>
</table>
<h2 id="插值"> 插值#{}</h2>
<p>少废话，先看例子</p>
<div><pre><code>$<span>properties</span><span>:</span> <span>(</span>margin<span>,</span> padding<span>)</span><span>;</span>
<span><span>@mixin</span> <span>set-value</span><span>(</span>$side<span>,</span> $value<span>)</span></span> <span>{</span>
    <span><span>@each</span> $prop in $properties</span> <span>{</span>
        <span>#</span><span>{</span>$prop<span>}</span><span>-#</span><span>{</span>$side<span>}</span><span>:</span> $value<span>;</span>
    <span>}</span>
<span>}</span>
<span>.login-box</span> <span>{</span>
    <span><span>@include</span> <span>set-value</span><span>(</span>top<span>,</span> 14px<span>)</span><span>;</span></span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>编译出的CSS</p>
<div><pre><code><span>.login-box</span> <span>{</span>
    <span>margin-top</span><span>:</span> 14px<span>;</span>
    <span>padding-top</span><span>:</span> 14px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>不对的例子</p>
<div><pre><code>$<span>margin-big</span><span>:</span> 40px<span>;</span>
$<span>margin-medium</span><span>:</span> 20px<span>;</span>
$<span>margin-small</span><span>:</span> 12px<span>;</span>
<span><span>@mixin</span> <span>set-value</span><span>(</span>$size<span>)</span></span> <span>{</span>
    <span>margin-top: $margin-#</span><span>{</span>$size<span>}</span><span>;</span>
<span>}</span>
<span>.login-box</span> <span>{</span>
    <span><span>@include</span> <span>set-value</span><span>(</span>big<span>)</span><span>;</span></span>
<span>}</span>
<span><span>@mixin</span> updated-status</span> <span>{</span>
    <span>margin-top</span><span>:</span> 20px<span>;</span>
    <span>background</span><span>:</span> #F00<span>;</span>
<span>}</span>
$<span>flag</span><span>:</span> <span>"status"</span><span>;</span>
<span>.navigation</span> <span>{</span>
    <span><span>@include</span> updated-#</span><span>{</span>$flag<span>}</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="注释"> 注释</h2>
<table>
<thead>
<tr>
<th>注释类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/*...*/</code></td>
<td>这样的注释可以在CSS文件中显示出来</td>
</tr>
<tr>
<td><code>//...</code></td>
<td>这样的注释只在sass文件中可见</td>
</tr>
</tbody>
</table>
<h2 id="数据类型"> 数据类型</h2>
<h3 id="数字"> 数字</h3>
<div><pre><code>1，10px
</code></pre>
<div><span>1</span><br></div></div><h3 id="字符串"> 字符串</h3>
<ul>
<li>有引号字符串 (quoted strings)，如 &quot;Lucida Grande&quot; 、'<a href="https://link.jianshu.com?t=http://sass-lang.com'" target="_blank" rel="noopener noreferrer">http://sass-lang.com'</a>；</li>
<li>无引号字符串 (unquoted strings)，如 sans-serifbold。</li>
</ul>
<blockquote>
<p>在编译 CSS 文件时不会改变其类型。只有一种情况例外，使用 #{ }插值语句 (interpolation) 时，有引号字符串将被编译为无引号字符串，这样方便了在混合指令 (mixin) 中引用选择器名。</p>
</blockquote>
<div><pre><code><span><span>@mixin</span> <span>firefox-message</span><span>(</span>$selector<span>)</span></span> <span>{</span>
    <span>body.firefox #</span><span>{</span>$selector<span>}</span><span>:before</span> <span>{</span>
        <span>content</span><span>:</span> <span>"Hi, Firefox users!"</span><span>;</span>
    <span>}</span>
<span>}</span>
<span><span>@include</span> <span>firefox-message</span><span>(</span><span>".header"</span><span>)</span><span>;</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>编译出来的CSS为</p>
<div><pre><code><span>body.firefox .header:before</span> <span>{</span>
    <span>content</span><span>:</span> <span>"Hi, Firefox users!"</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>另外</strong> 当 deprecated = property syntax 时 （暂时不理解是怎样的情况），所有的字符串都将被编译为无引号字符串，不论是否使用了引号。</p>
<h3 id="颜色"> 颜色</h3>
<p>blue、 #04a3f9、 rgba(255,0,0,0.5)；</p>
<h3 id="布尔"> 布尔</h3>
<p>true,false</p>
<h3 id="空值"> 空值</h3>
<p>null；</p>
<h3 id="值列表"> 值列表</h3>
<p>用空格或者逗号分开，如，1.5em 1em 0 2em 、 Helvetica, Arial, sans-serif
更多用法：</p>
<div><pre><code>nth函数（nth function） 可以直接访问值列表中的某一项；
join函数（join function） 可以将多个值列表连结在一起；
append函数（append function） 可以在值列表中添加值；
@each规则（@each rule） 则能够给值列表中的每个项目添加样式。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="运算"> 运算</h2>
<h3 id="加、减、乘、除"> 加、减、乘、除</h3>
<ul>
<li>加减注意单位一致，</li>
<li>乘除注意单位不能同时存在，</li>
<li>运算符和变量，数值中间用空格分开</li>
</ul>
<h3 id="变量计算"> 变量计算</h3>
<h3 id="数字运算"> 数字运算</h3>
<h3 id="颜色计算"> 颜色计算</h3>
<p>每两位进行运算</p>
<h3 id="字符运算"> 字符运算</h3>
<p>用 + 串联</p>
<blockquote>
<p>如果有引号的字符串被添加了一个没有引号的字符串 （也就是，带引号的字符串在 + 符号左侧）， 结果会是一个有引号的字符串。 同样的，如果一个没有引号的字符串被添加了一个有引号的字符串 （没有引号的字符串在 + 符号左侧）， 结果将是一个没有引号的字符串。<strong>以等号左边的为准</strong></p>
</blockquote>
<div><pre><code><span>p:before</span> <span>{</span>
  <span>content</span><span>:</span> <span>"Foo "</span> + Bar<span>;</span>
  <span>font-family</span><span>:</span> sans- + <span>"serif"</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>编译结果</p>
<div><pre><code><span>p:before</span> <span>{</span>
  <span>content</span><span>:</span> <span>"Foo Bar"</span><span>;</span>
  <span>font-family</span><span>:</span> sans-serif<span>;</span> 
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h1 id="进阶"> 进阶</h1>
<h2 id="控制命令"> 控制命令</h2>
<h3 id="if-else-else-if"> @if @else @else if</h3>
<div><pre><code><span><span>@mixin</span> <span>blockOrHidden</span><span>(</span>$<span>boolean</span><span>:</span>true<span>)</span></span> <span>{</span>
  <span><span>@if</span> $boolean</span> <span>{</span>
      <span><span>@debug</span> "$boolean is #</span><span>{</span>$boolean<span>}</span>"<span>;</span>
      <span>display</span><span>:</span> block<span>;</span>
    <span>}</span>
  <span><span>@else</span></span> <span>{</span>
      <span><span>@debug</span> "$boolean is #</span><span>{</span>$boolean<span>}</span>"<span>;</span>
      <span>display</span><span>:</span> none<span>;</span>
    <span>}</span>
<span>}</span>

<span>.block</span> <span>{</span>
  <span><span>@include</span> blockOrHidden<span>;</span></span>
<span>}</span>

<span>.hidden</span><span>{</span>
  <span><span>@include</span> <span>blockOrHidden</span><span>(</span>false<span>)</span><span>;</span></span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>编译出来的CSS</p>
<div><pre><code><span>.block</span> <span>{</span>
  <span>display</span><span>:</span> block<span>;</span>
<span>}</span>

<span>.hidden</span> <span>{</span>
  <span>display</span><span>:</span> none<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="for"> @for</h3>
<div><pre><code>//2种方式
@for $i from &lt;start> through &lt;end> //包括 end 这个值
@for $i from &lt;start> to &lt;end> //不包括 end 这个数

//$i 表示变量
//start 表示起始值
//end 表示结束值
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>看个例子</p>
<div><pre><code>$<span>grid-prefix</span><span>:</span> span !default<span>;</span>
$<span>grid-width</span><span>:</span> 60px !default<span>;</span>
$<span>grid-gutter</span><span>:</span> 20px !default<span>;</span>

<span>%grid</span> <span>{</span>
  <span>float</span><span>:</span> left<span>;</span>
  <span>margin-left</span><span>:</span> $grid-gutter / 2<span>;</span>
  <span>margin-right</span><span>:</span> $grid-gutter / 2<span>;</span>
<span>}</span>
<span><span>@for</span> $i from 1 through 12</span> <span>{</span>
  <span>.#</span><span>{</span>$grid-prefix<span>}</span><span>#</span><span>{</span>$i<span>}</span><span>{</span>
    <span>width</span><span>:</span> $grid-width * $i + $grid-gutter * <span>(</span>$i - 1<span>)</span><span>;</span>
    <span><span>@extend</span> %grid<span>;</span></span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>编译出来的CSS</p>
<div><pre><code><span>.span1, .span2, .span3, .span4, .span5, .span6, .span7, .span8, .span9, .span10, .span11, .span12</span> <span>{</span>
  <span>float</span><span>:</span> left<span>;</span>
  <span>margin-left</span><span>:</span> 10px<span>;</span>
  <span>margin-right</span><span>:</span> 10px<span>;</span>
<span>}</span>

<span>.span1</span> <span>{</span>
  <span>width</span><span>:</span> 60px<span>;</span>
<span>}</span>
.
.
.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="while"> @while</h3>
<div><pre><code>$<span>types</span><span>:</span> 4<span>;</span>
$<span>type-width</span><span>:</span> 20px<span>;</span>

<span><span>@while</span> $types > 0</span> <span>{</span>
    <span>.while-#</span><span>{</span>$types<span>}</span> <span>{</span>
        <span>width</span><span>:</span> $type-width + $types<span>;</span>
    <span>}</span>
    $<span>types</span><span>:</span> $types - 1<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>编译出来的CSS</p>
<div><pre><code><span>.while-4</span> <span>{</span>
  <span>width</span><span>:</span> 24px<span>;</span>
<span>}</span>

<span>.while-3</span> <span>{</span>
  <span>width</span><span>:</span> 23px<span>;</span>
<span>}</span>

<span>.while-2</span> <span>{</span>
  <span>width</span><span>:</span> 22px<span>;</span>
<span>}</span>

<span>.while-1</span> <span>{</span>
  <span>width</span><span>:</span> 21px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="each"> @each</h3>
<div><pre><code>@each $var in &lt;list>

//$var 就是一个变量名，
//&lt;list> 是一个 SassScript 表达式，他将返回一个列表值。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>举个例子</p>
<div><pre><code>$<span>list</span><span>:</span> adam john wynn mason kuroir<span>;</span>//$list 就是一个列表

<span><span>@mixin</span> author-images</span> <span>{</span>
    <span><span>@each</span> $author in $list</span> <span>{</span>
        <span>.photo-#</span><span>{</span>$author<span>}</span> <span>{</span>
            <span>background</span><span>:</span> <span><span>url</span><span>(</span><span>"/images/avatars/#{$author}.png"</span><span>)</span></span> no-repeat<span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>.author-bio</span> <span>{</span>
    <span><span>@include</span> author-images<span>;</span></span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>编译出来的CSS</p>
<div><pre><code><span>.author-bio .photo-adam</span> <span>{</span>
  <span>background</span><span>:</span> <span><span>url</span><span>(</span><span>"/images/avatars/adam.png"</span><span>)</span></span> no-repeat<span>;</span> <span>}</span>
<span>.author-bio .photo-john</span> <span>{</span>
  <span>background</span><span>:</span> <span><span>url</span><span>(</span><span>"/images/avatars/john.png"</span><span>)</span></span> no-repeat<span>;</span> <span>}</span>
<span>.author-bio .photo-wynn</span> <span>{</span>
  <span>background</span><span>:</span> <span><span>url</span><span>(</span><span>"/images/avatars/wynn.png"</span><span>)</span></span> no-repeat<span>;</span> <span>}</span>
<span>.author-bio .photo-mason</span> <span>{</span>
  <span>background</span><span>:</span> <span><span>url</span><span>(</span><span>"/images/avatars/mason.png"</span><span>)</span></span> no-repeat<span>;</span> <span>}</span>
<span>.author-bio .photo-kuroir</span> <span>{</span>
  <span>background</span><span>:</span> <span><span>url</span><span>(</span><span>"/images/avatars/kuroir.png"</span><span>)</span></span> no-repeat<span>;</span> <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="字符串函数"> 字符串函数</h2>
<h3 id="unquote-string-删除字符串中的引号"> <strong>unquote($string)</strong>：删除字符串中的引号</h3>
<p>unquote() 函数主要是用来删除一个字符串中的引号，如果这个字符串没有带有引号，将返回原始的字符串。
只能删除字符串最前和最后的引号（双引号或单引号），而无法删除字符串中间的引号</p>
<h3 id="quote-string-给字符串添加引号"> <strong>quote($string)</strong>：给字符串添加引号</h3>
<p>使用 quote() 函数只能给字符串增加双引号，而且字符串中间有单引号或者空格时，需要用单引号或双引号括起，否则编译的时候将会报错。
同时 quote() 碰到特殊符号，比如： !、?、&gt; 等，除中折号 - 和 下划线_ 都需要使用双引号括起，否则编译器在进行编译的时候同样会报错</p>
<h3 id="to-upper-case"> <strong>To-upper-case()</strong></h3>
<h3 id="to-lower-case"> <strong>To-lower-case()</strong></h3>
<h2 id="数字函数"> 数字函数</h2>
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>percentage($value)</td>
<td>将一个不带单位的数转换成百分比值</td>
</tr>
<tr>
<td>round($value)</td>
<td>将数值四舍五入，转换成一个最接近的整数</td>
</tr>
<tr>
<td>ceil($value)</td>
<td>将大于自己的小数转换成下一位整数</td>
</tr>
<tr>
<td>floor($value)</td>
<td>将一个数去除他的小数部分</td>
</tr>
<tr>
<td>abs($value)</td>
<td>返回一个数的绝对值</td>
</tr>
<tr>
<td>min($numbers…)</td>
<td>找出几个数值之间的最小值</td>
</tr>
<tr>
<td>max($numbers…)</td>
<td>找出几个数值之间的最大值</td>
</tr>
<tr>
<td>random()</td>
<td>获取随机</td>
</tr>
</tbody>
</table>
<h2 id="列表函数"> 列表函数</h2>
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
<th>注意</th>
</tr>
</thead>
<tbody>
<tr>
<td>length($list)</td>
<td>返回一个列表的长度值</td>
<td>length() 函数中的列表参数之间使用空格隔开，不能使用逗号</td>
</tr>
<tr>
<td>nth($list, $n)</td>
<td>返回一个列表中指定的某个标签值</td>
<td>$n 必须是大于 0 的整数</td>
</tr>
<tr>
<td>join($list1, <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.01968em;">l</span><span>i</span><span>s</span><span>t</span><span>2</span><span>,</span><span style="margin-right:0.1667em;"></span><span>[</span></span></span></span>separator])</td>
<td>将两个列给连接在一起，变成一个列表</td>
<td>只能将两个列表连接成一个列表，合并多个时嵌套join()，join() 函数中 $separator 除了默认值 auto 之外，还有 comma 和 space 两个值</td>
</tr>
<tr>
<td>append($list1, <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.03588em;">v</span><span>a</span><span style="margin-right:0.01968em;">l</span><span>,</span><span style="margin-right:0.1667em;"></span><span>[</span></span></span></span>separator])</td>
<td>将某个值放在列表的最后</td>
<td>可选参数同上</td>
</tr>
<tr>
<td>zip($lists…)</td>
<td>将几个列表结合成一个多维的列表</td>
<td>-</td>
</tr>
<tr>
<td>index($list, $value)</td>
<td>返回一个值在列表中的位置值</td>
<td>在 Sass 中，值是从1开始，没有则返回false</td>
</tr>
</tbody>
</table>
<h2 id="introspection函数"> Introspection函数</h2>
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>type-of($value)</td>
<td>返回一个值的类型</td>
<td>number，string，color，bool</td>
</tr>
<tr>
<td>unit($number)</td>
<td>返回一个值的单位</td>
<td>单位</td>
</tr>
<tr>
<td>unitless($number)</td>
<td>判断一个值是否带有带位</td>
<td>true/false</td>
</tr>
<tr>
<td>comparable($number-1, $number-2)</td>
<td>判断两个值是否可以做加、减和合并</td>
<td>true/false</td>
</tr>
</tbody>
</table>
<h2 id="miscellaneous函数"> Miscellaneous函数</h2>
<p>在这里把 Miscellaneous 函数称为三元条件函数，主要因为他和 JavaScript 中的三元判断非常的相似。他有两个值，当条件成立返回一种值，当条件不成立时返回另一种值：</p>
<div><pre><code><span>if</span><span>(</span>$condition<span>,</span>$if-true<span>,</span>$if-false<span>)</span>
>> <span>if</span><span>(</span>true<span>,</span>1px<span>,</span>2px<span>)</span>
1px
>> <span>if</span><span>(</span>false<span>,</span>1px<span>,</span>2px<span>)</span>
2px
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="map函数"> Map函数</h2>
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>map-get(<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.625em;vertical-align:-0.1944em;"></span><span>ma</span><span>p</span><span>,</span></span></span></span>key)</td>
<td>根据给定的 key 值，返回 map 中相关的值</td>
<td>如果不存在，返回null</td>
</tr>
<tr>
<td>map-merge(<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8389em;vertical-align:-0.1944em;"></span><span>ma</span><span>p</span><span>1</span><span>,</span></span></span></span>map2)</td>
<td>将两个 map 合并成一个新的 map</td>
<td>合并后的map，如果有相同的值，以<strong>后面</strong>的为主</td>
</tr>
<tr>
<td>map-remove(<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.625em;vertical-align:-0.1944em;"></span><span>ma</span><span>p</span><span>,</span></span></span></span>key)</td>
<td>从 map 中删除一个 key</td>
<td>返回一个新 map</td>
</tr>
<tr>
<td>map-keys($map)</td>
<td>返回 map 中所有的 key</td>
<td>返回 map 中所有的 key</td>
</tr>
<tr>
<td>map-values($map)</td>
<td>返回 map 中所有的 value</td>
<td>返回 map 中所有的 value</td>
</tr>
<tr>
<td>map-has-key(<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.625em;vertical-align:-0.1944em;"></span><span>ma</span><span>p</span><span>,</span></span></span></span>key)</td>
<td>根据给定的 key 值判断 map 是否有对应的 value 值</td>
<td>如果有返回 true，否则返回 false</td>
</tr>
<tr>
<td>keywords($args)</td>
<td>返回一个函数的参数，这个参数可以动态的设置 key 和 value</td>
<td>-</td>
</tr>
</tbody>
</table>
<h2 id="颜色函数"> 颜色函数</h2>
<h3 id="rgb颜色函数"> RGB颜色函数</h3>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>rgb(<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span>re</span><span>d</span><span>,</span></span></span></span>green,$blue)</td>
<td>根据红、绿、蓝三个值创建一个颜色</td>
<td>-</td>
</tr>
<tr>
<td>rgba(<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span>re</span><span>d</span><span>,</span></span></span></span>green,<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span>b</span><span style="margin-right:0.01968em;">l</span><span>u</span><span>e</span><span>,</span></span></span></span>alpha)</td>
<td>根据红、绿、蓝和透明度值创建一个颜色</td>
<td>-</td>
</tr>
<tr>
<td>red($color)</td>
<td>从一个颜色中获取其中红色值</td>
<td>-</td>
</tr>
<tr>
<td>green($color)</td>
<td>从一个颜色中获取其中绿色值</td>
<td>-</td>
</tr>
<tr>
<td>blue($color)</td>
<td>从一个颜色中获取其中蓝色值</td>
<td>-</td>
</tr>
<tr>
<td>mix(<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.7778em;vertical-align:-0.0833em;"></span><span>co</span><span style="margin-right:0.01968em;">l</span><span style="margin-right:0.02778em;">or</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.8389em;vertical-align:-0.1944em;"></span><span>1</span><span>,</span></span></span></span>color-2,[$weight])</td>
<td>把两种颜色混合在一起</td>
<td>$weight 为合并权重，默认50%，值为第一个颜色所占权重</td>
</tr>
</tbody>
</table>
<h3 id="hsl函数"> HSL函数</h3>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>hsl(<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span>h</span><span>u</span><span>e</span><span>,</span></span></span></span>saturation,$lightness)</td>
<td>通过色相（hue）、饱和度(saturation)和亮度（lightness）的值创建一个颜色</td>
</tr>
<tr>
<td>hsla(<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span>h</span><span>u</span><span>e</span><span>,</span></span></span></span>saturation,<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span style="margin-right:0.01968em;">l</span><span>i</span><span style="margin-right:0.03588em;">g</span><span>h</span><span>t</span><span>n</span><span>ess</span><span>,</span></span></span></span>alpha)</td>
<td>通过色相（hue）、饱和度(saturation)、亮度（lightness）和透明（alpha）的值创建一个颜色</td>
</tr>
<tr>
<td>hue($color)</td>
<td>从一个颜色中获取色相（hue）值</td>
</tr>
<tr>
<td>saturation($color)</td>
<td>从一个颜色中获取饱和度（saturation）值</td>
</tr>
<tr>
<td>lightness($color)</td>
<td>从一个颜色中获取亮度（lightness）值</td>
</tr>
<tr>
<td>adjust-hue(<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span>co</span><span style="margin-right:0.01968em;">l</span><span style="margin-right:0.02778em;">or</span><span>,</span></span></span></span>degrees)</td>
<td>通过改变一个颜色的色相值，创建一个新的颜色</td>
</tr>
<tr>
<td>lighten(<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span>co</span><span style="margin-right:0.01968em;">l</span><span style="margin-right:0.02778em;">or</span><span>,</span></span></span></span>amount)</td>
<td>通过改变颜色的亮度值，让颜色变亮，创建一个新的颜色</td>
</tr>
<tr>
<td>darken(<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span>co</span><span style="margin-right:0.01968em;">l</span><span style="margin-right:0.02778em;">or</span><span>,</span></span></span></span>amount)</td>
<td>通过改变颜色的亮度值，让颜色变暗，创建一个新的颜色</td>
</tr>
<tr>
<td>saturate(<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span>co</span><span style="margin-right:0.01968em;">l</span><span style="margin-right:0.02778em;">or</span><span>,</span></span></span></span>amount)</td>
<td>通过改变颜色的饱和度值，让颜色更饱和，从而创建一个新的颜色</td>
</tr>
<tr>
<td>desaturate(<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span>co</span><span style="margin-right:0.01968em;">l</span><span style="margin-right:0.02778em;">or</span><span>,</span></span></span></span>amount)</td>
<td>通过改变颜色的饱和度值，让颜色更少的饱和，从而创建出一个新的颜色</td>
</tr>
<tr>
<td>grayscale($color)</td>
<td>将一个颜色变成灰色，相当于desaturate($color,100%)</td>
</tr>
<tr>
<td>complement($color)</td>
<td>返回一个补充色，相当于adjust-hue($color,180deg)</td>
</tr>
<tr>
<td>invert($color)</td>
<td>反回一个反相色，红、绿、蓝色值倒过来，而透明度不变</td>
</tr>
</tbody>
</table>
<h3 id="opacity函数"> Opacity函数</h3>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>alpha(<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>co</span><span style="margin-right:0.01968em;">l</span><span style="margin-right:0.02778em;">or</span><span>)</span><span>/</span><span>o</span><span>p</span><span>a</span><span>c</span><span>i</span><span>t</span><span style="margin-right:0.03588em;">y</span><span>(</span></span></span></span>color)</td>
<td>获取颜色透明度值</td>
</tr>
<tr>
<td>rgba($color, $alpha)</td>
<td>改变颜色的透明度值</td>
</tr>
<tr>
<td>pacify($color, <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>am</span><span>o</span><span>u</span><span>n</span><span>t</span><span>)</span><span>/</span><span style="margin-right:0.10764em;">f</span><span>a</span><span>d</span><span>e</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>in</span><span>(</span></span></span></span>color, $amount)</td>
<td>使颜色更不透明</td>
</tr>
<tr>
<td>transparentize($color, <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>am</span><span>o</span><span>u</span><span>n</span><span>t</span><span>)</span><span>/</span><span style="margin-right:0.10764em;">f</span><span>a</span><span>d</span><span>e</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>o</span><span>u</span><span>t</span><span>(</span></span></span></span>color, $amount)</td>
<td>使颜色更加透明</td>
</tr>
</tbody>
</table>
<h2 id="规则-指令-directive"> @规则/指令(directive)</h2>
<h3 id="import"> @import</h3>
<blockquote>
<p>默认情况是sass的@import，以下情况会用CSS的@import</p>
</blockquote>
<ul>
<li>如果文件的扩展名是 .css。</li>
<li>如果文件名以 http:// 开头。</li>
<li>如果文件名是 url()。</li>
<li>如果 @import 包含了任何媒体查询（media queries）</li>
</ul>
<div><pre><code><span><span>@import</span> <span>"foo.scss"</span><span>;</span></span>
<span><span>@import</span> <span>"foo"</span>
//都会引入foo.scss文件
<span><span>@import</span> <span>"rounded-corners"</span><span>,</span> <span>"text-shadow"</span><span>;</span></span></span>
//引入多个文件
//如果你有一个 SCSS 或 Sass 文件需要引入， 但是你又不希望它被编译为一个 CSS 文件， 这时，你就可以在文件名前面加一个下划线，就能避免被编译。你就可以像往常一样引入这个文件了，而且还可以省略掉文件名前面的下划线
在同一个目录不能同时存在带下划线和不带下划线的同名文件。 例如， _colors.scss 不能与 colors.scss 并存
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>嵌套 @import</strong>
虽然大部分时间只需在顶层文件使用 @import 就行了， 但是，你还可以把他们包含在 CSS 规则 和 @media 规则中。</p>
<h3 id="media"> @media</h3>
<p>Sass 中的 @media 指令和 CSS 的使用规则一样的简单，但它有另外一个功能，可以嵌套在 CSS 规则中。有点类似 JS 的冒泡功能一样，如果在样式中使用 @media 指令，它将冒泡到外面。</p>
<div><pre><code><span>.sidebar</span> <span>{</span>
  <span>width</span><span>:</span> 300px<span>;</span>
  <span><span>@media</span> screen <span>and</span> <span>(</span><span>orientation</span><span>:</span> landscape<span>)</span></span> <span>{</span>
    <span>width</span><span>:</span> 500px<span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>编译出来的CSS</p>
<div><pre><code><span>.sidebar</span> <span>{</span>
    <span>width</span><span>:</span> 300px<span>;</span>
<span>}</span>
<span><span>@media</span> screen <span>and</span> <span>(</span><span>orientation</span><span>:</span> landscape<span>)</span></span> <span>{</span>
    <span>.sidebar</span> <span>{</span>
        <span>width</span><span>:</span> 500px<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>支持嵌套</strong></p>
<h3 id="extend"> </h3>
<h3 id="at-root"> @at-root</h3>
<p>@at-root 从字面上解释就是跳出根元素。当你选择器嵌套多层之后，想让某个选择器跳出，此时就可以使用 @at-root。</p>
<div><pre><code><span>.a</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>

  <span>.b</span> <span>{</span>
    <span>color</span><span>:</span> orange<span>;</span>

    <span>.c</span> <span>{</span>
      <span>color</span><span>:</span> yellow<span>;</span>

      <span><span>@at-root</span> .d</span> <span>{</span>
        <span>color</span><span>:</span> green<span>;</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>编译出来的CSS</p>
<div><pre><code><span>.a</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span>

<span>.a .b</span> <span>{</span>
  <span>color</span><span>:</span> orange<span>;</span>
<span>}</span>

<span>.a .b .c</span> <span>{</span>
  <span>color</span><span>:</span> yellow<span>;</span>
<span>}</span>

<span>.d</span> <span>{</span>
  <span>color</span><span>:</span> green<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="debug"> @debug</h3>
<p>@debug 在 Sass 中是用来调试的，当你的在 Sass 的源码中使用了 @debug 指令之后，Sass 代码在编译出错时，在命令终端会输出你设置的提示 Bug:</p>
<div><pre><code><span><span>@debug</span> 10em + 12em<span>;</span></span>
</code></pre>
<div><span>1</span><br></div></div><p>输出</p>
<div><pre><code>Line 1 <span>DEBUG</span><span>:</span> 22em
</code></pre>
<div><span>1</span><br></div></div><h3 id="warn"> @warn</h3>
<p>@warn 和 @debug 功能类似，用来帮助我们更好的调试 Sass。如：</p>
<div><pre><code><span><span>@mixin</span> <span>adjust-location</span><span>(</span>$x<span>,</span> $y<span>)</span></span> <span>{</span>
  <span><span>@if</span> <span>unitless</span><span>(</span>$x<span>)</span></span> <span>{</span>
    <span><span>@warn</span> "Assuming #</span><span>{</span>$x<span>}</span> to be in pixels"<span>;</span>
    $<span>x</span><span>:</span> 1px * $x<span>;</span>
  <span>}</span>
  <span><span>@if</span> <span>unitless</span><span>(</span>$y<span>)</span></span> <span>{</span>
    <span><span>@warn</span> "Assuming #</span><span>{</span>$y<span>}</span> to be in pixels"<span>;</span>
    $<span>y</span><span>:</span> 1px * $y<span>;</span>
  <span>}</span>
  <span>position</span><span>:</span> relative<span>;</span> <span>left</span><span>:</span> $x<span>;</span> <span>top</span><span>:</span> $y<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="error"> @error</h3>
<p>@error 和 @warn、@debug 功能是如出一辙。</p>
<div><pre><code><span><span>@mixin</span> <span>error</span><span>(</span>$x<span>)</span></span><span>{</span>
  <span><span>@if</span> $x &lt; 10</span> <span>{</span>
    <span>width</span><span>:</span> $x * 10px<span>;</span>
  <span>}</span> <span><span>@else</span> if $x == 10</span> <span>{</span>
    <span>width</span><span>:</span> $x<span>;</span>
  <span>}</span> <span><span>@else</span></span> <span>{</span>
    <span><span>@error</span> "你需要将#</span><span>{</span>$x<span>}</span>值设置在10以内的数"<span>;</span>
  <span>}</span>

<span>}</span>

<span>.test</span> <span>{</span>
  <span><span>@include</span> <span>error</span><span>(</span>15<span>)</span><span>;</span></span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>编译时</p>
<div><pre><code>你需要将<span>15</span>值设置在<span>10</span>以内的数 on line <span>7</span> at column <span>5</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>xiechengyu</name>
    </author>
    <category term="转载"/>
    <contributor>
      <name>xiechengyu</name>
    </contributor>
    <published>2018-11-17T15:04:17.000Z</published>
    <rights>Copyright by xiechengyu</rights>
  </entry>
  <entry>
    <title type="html">搭建起个人博客</title>
    <id>https://xiechengyu.github.io/reprint/%E6%90%AD%E5%BB%BA%E8%B5%B7%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</id>
    <link href="https://xiechengyu.github.io/reprint/%E6%90%AD%E5%BB%BA%E8%B5%B7%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <updated>2022-02-08T07:39:18.000Z</updated>
    <summary type="html"><![CDATA[<h1 id="_1、前言"> 1、前言</h1>
<p>我一直想要制作个人博客，但是一直没有找到合适的教程，直到前几天我找到了一片很好的文章<a href="http://www.cnblogs.com/jackyroc/p/7681938.html" target="_blank" rel="noopener noreferrer">我是如何利用Github Pages搭建起我的博客，细数一路的坑</a> ，我通过这篇文章里所说成功搭建起我的个人博客，现在我就把文章的内容分享在我个人博客中。
<strong>文章相关内容转载自：<a href="http://www.cnblogs.com/jackyroc/p/7681938.html" target="_blank" rel="noopener noreferrer">我是如何利用Github Pages搭建起我的博客，细数一路的坑</a></strong></p>
]]></summary>
    <content type="html"><![CDATA[<h1 id="_1、前言"> 1、前言</h1>
<p>我一直想要制作个人博客，但是一直没有找到合适的教程，直到前几天我找到了一片很好的文章<a href="http://www.cnblogs.com/jackyroc/p/7681938.html" target="_blank" rel="noopener noreferrer">我是如何利用Github Pages搭建起我的博客，细数一路的坑</a> ，我通过这篇文章里所说成功搭建起我的个人博客，现在我就把文章的内容分享在我个人博客中。
<strong>文章相关内容转载自：<a href="http://www.cnblogs.com/jackyroc/p/7681938.html" target="_blank" rel="noopener noreferrer">我是如何利用Github Pages搭建起我的博客，细数一路的坑</a></strong></p>

<h2 id="那么我为什么要建立自己的博客-引自-为什么你要写博客-陈素封"> 那么我为什么要建立自己的博客？<em>——<a href="https://zhuanlan.zhihu.com/p/19743861?columnSlug=cnfeat" target="_blank" rel="noopener noreferrer">引自:为什么你要写博客？—陈素封</a></em></h2>
<h3 id="_1-提高将事情讲清楚的能力"> 1.“提高将事情讲清楚的能力”.</h3>
<blockquote>
<p>在写博客之前你需要花更多的时间来表达出你的想法，表达你想法之前你得先对你要表达的东西充分理解并理清思路和逻辑。</p>
<blockquote>
<p>很多东西你以为懂了，但当你在写下来的时候，你就觉得无从下手了。</p>
</blockquote>
</blockquote>
<h3 id="_2-分享带来的连锁反应"> 2.分享带来的连锁反应</h3>
<blockquote>
<p>“通过分享，你获得了直接而快速的回报，你最终或许会发现你已将版权和“保留所有权利”抛诸脑后。新的经济学准则是：参与你作品的人越多，回报越高。在分享主义里，如果你愿意你可以保留所有权，但是我乐于分享。” by 毛向辉 《分享主义：一场思维革命》</p>
</blockquote>
<h3 id="_3-记录成长"> 3.记录成长</h3>
<blockquote>
<p>我们每个人都应该有这样的经历:隔了很久我们回头看看以前的自己会发现特别傻x,但正是因为这些傻x的岁月让我们不断成长,你在成长的过程中不断的修正自己的错误。</p>
</blockquote>
<h3 id="_4-探索未知的世界"> 4.探索未知的世界</h3>
<blockquote>
<p>世界不止是你的家，你的公司，你的朋友圈，你应该去发现一个更大的世界，通过写博客，你会知道世界上还有很多人像你一样在写博客，这些人和知识正在世界的某个角落在等着你。</p>
</blockquote>
<h3 id="_5-帮助更多想要获取帮助的人"> 5.帮助更多想要获取帮助的人</h3>
<blockquote>
<p>这点我相信大家由为感触,在你探索一个未知的知识领域的时候,往往被撞的一鼻子灰.幸运的人很快就能找到一个“师傅”或一篇很好的文章,但大多数往往在找“教程”的过程中就已经放弃了.因为他们没能够找到刚好理解的文章.</p>
</blockquote>
<h1 id="一、开始搭建github-pages"> 一、开始搭建Github Pages</h1>
<p>参考:<a href="http://cyzus.github.io/2015/06/21/github-build-blog/" target="_blank" rel="noopener noreferrer">傻瓜都可以利用github pages建博客</a><br>
参考:<a href="https://segmentfault.com/a/1190000004947261" target="_blank" rel="noopener noreferrer">手把手教你使用Hexo + Github Pages搭建个人独立博客</a><br>
<em>可以选择阅读完以上两篇教程后倒回来看不懂的地方.</em></p>
<h2 id="_1-使用前了解github"> 1.使用前了解Github</h2>
<blockquote>
<p>GitHub是一个共享虚拟主机服务，用于存放使用Git版本控制的软件代码和内容项目(引自维基百科）</p>
</blockquote>
<h2 id="_2-为什么选择github"> 2.为什么选择Github?</h2>
<blockquote>
<p>github有一个很有爱的项目，叫做github pages，这个项目是给开发者建立一个私人页面，上面用来分享新颖的想法和自己写的代码.</p>
</blockquote>
<h2 id="_3-注册属于你自己的github账号"> 3.注册属于你自己的Github账号</h2>
<p>首先进入<a href="https://github.com/" target="_blank" rel="noopener noreferrer">Github</a>站点,然后进行注册(此处不做详细说明可自行阅读<a href="http://jingyan.baidu.com/article/455a9950abe0ada167277864.html" target="_blank" rel="noopener noreferrer">github教程：[1]注册github</a>)</p>
<p>注册完毕后你就拥有了自己的代码仓库了.</p>
<h2 id="_4-创建仓库"> 4.创建仓库</h2>
<p>在Github首页右上角头像左侧加号点选择 New repositor(新存储库)或<a href="https://github.com/new" target="_blank" rel="noopener noreferrer">点击这里</a>进行创建一个仓库.</p>
<p><img src="/assets/img/blog/create1.png" alt="创建一个仓库" loading="lazy"></p>
<h2 id="_5-开启github-pages"> 5.开启Github Pages</h2>
<p>进入设置<br>
<img src="/assets/img/blog/create2.png" alt="设置" loading="lazy"></p>
<p>找到这一块</p>
<p><img src="/assets/img/blog/create3.png" alt="设置" loading="lazy"></p>
<p>当你的仓库名为：用户名.github.io 之后默认开启Github Pages</p>
<p>现在随便选择一个主题,选择上图的 Choose a theme 之后会跳转到下面这个页面</p>
<p><img src="/assets/img/blog/create4.png" alt="设置" loading="lazy"></p>
<p>设置完毕后你就可以通过  username.github.io(username为你的用户名访问你的博客了)</p>
<h2 id="_6-下载github-客户端"> 6.下载Github 客户端</h2>
<p>根据自己的系统自行选择下载安装</p>
<p><a href="https://desktop.github.com/" target="_blank" rel="noopener noreferrer">点击前往Github下载</a></p>
<p>下载安装好之后登陆你的github.</p>
<p>从你的仓库添加到本地</p>
<p><img src="/assets/img/blog/create5.png" alt="设置" loading="lazy"></p>
<p>接下来就需要搭建Hexo了</p>
<h1 id="二、hexo"> 二、Hexo</h1>
<p>要使用Hexo,需要安装Nodejs以及Git</p>
<h2 id="安装node-js"> 安装Node.js</h2>
<p><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener noreferrer">下载Node.js</a><br>
参考:<a href="http://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener noreferrer">安装Node.js</a></p>
<h2 id="安装git"> 安装Git</h2>
<p><a href="https://git-scm.com/download/" target="_blank" rel="noopener noreferrer">下载Git</a></p>
<p>一路点击Next就行了.</p>
<h2 id="安装hexo"> 安装Hexo</h2>
<p>在你需要安装Hexo的目录下(新建一个文件夹)右键选择 Git Bash</p>
<div><pre><code>npm install hexo-cli -g   
hexo init #初始化网站   
npm install   
hexo g #生成或 hexo generate   
hexo s #启动本地服务器 或者 hexo server,这一步之后就可以通过http://localhost:4000  查看了
</code></pre>
</div><p><em>详细命令请参考<a href="https://hexo.io/docs/commands.html" target="_blank" rel="noopener noreferrer">Hexo文档</a></em></p>
<p>这里介绍一下怎么创建一篇文章</p>
<div><pre><code>hexo new &quot;文章名&quot; #新建文章
hexo new page &quot;页面名&quot; #新建页面   
</code></pre>
</div><p>常用简写</p>
<div><pre><code>hexo n == hexo new
hexo g == hexo generate
hexo s == hexo server
hexo d == hexo deploy
</code></pre>
</div><p>新建一篇文章后就可以<a href="http://localhost:4000/" target="_blank" rel="noopener noreferrer">预览</a>了,在hexo new之后执行一次生成hexo g再执行hexo s启动本地服务器,如果之前还在hexo s 按Ctrl + C 结束.</p>
<h2 id="添加主题"> 添加主题</h2>
<h3 id="安装主题-yilia主题"> 安装主题(yilia主题):</h3>
<div><pre><code>hexo clean
git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia   
</code></pre>
</div><h3 id="启动主题"> 启动主题</h3>
<p>找到目录下的_config.yml 文件,打开找到 theme：属性并设置为yilia</p>
<h3 id="更新主题"> 更新主题</h3>
<div><pre><code>cd themes/yilia
git pull
hexo g
hexo s
</code></pre>
</div><p>此时刷新<a href="http://localhost:4000/" target="_blank" rel="noopener noreferrer">http://localhost:4000/</a>页面就能看到新的主题了.</p>
<h2 id="使用hexo-deploy部署到github"> 使用Hexo deploy部署到github</h2>
<p>还是编辑根目录下_config.yml文件</p>
<div><pre><code>deploy:
	type: git
	repo: git@github.com:cczeng/cczeng.github.io.git  #这里的网址填你自己的
	branch: master   
</code></pre>
</div><p>**此处感谢有网友帮忙指出错误,原文自第二行起由于疏忽没有缩进 **</p>
<p>具体配置可参考<a href="https://github.com/cczeng/BlogBackup" target="_blank" rel="noopener noreferrer">我的博客备份</a></p>
<p>保存后需要提前安装一个扩展：</p>
<div><pre><code>npm install hexo-deployer-git --save   
</code></pre>
</div><p>接下来就是将Hexo部署到我们的Github仓库上</p>
<h1 id="三、部署到github"> 三、部署到Github</h1>
<h2 id="_1-检查ssh-keys的设置"> 1.检查SSH keys的设置</h2>
<p>以下命令均是在Git bash里输入</p>
<div><pre><code>cd ~/.ssh
ls
#此时会显示一些文件
mkdir key_backup
cp id_rsa* key_backup
rm id_rsa*  
#以上三步为备份和移除原来的SSH key设置
ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot; #生成新的key文件,邮箱地址填你的Github地址
#Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;
#接下来会让你输入密码
</code></pre>
</div><p>之后就可以看到成功的界面。</p>
<h2 id="_2-添加ssh-key到github"> 2.添加SSH Key到Github</h2>
<p>进入<a href="https://github.com/" target="_blank" rel="noopener noreferrer">github首页</a></p>
<p><img src="/assets/img/blog/create6.png" alt="设置" loading="lazy"></p>
<p>添加SSH Key。</p>
<p><img src="/assets/img/blog/create7.png" alt="设置" loading="lazy"></p>
<p>找到 系统当前用户目录下(开启查看隐藏文件) <strong>C:\Users\用户名\ .ssh</strong> id_rsa.pub文件以文本方式打开。打开之后全部复制到key中</p>
<p><img src="/assets/img/blog/create8.png" alt="设置" loading="lazy"></p>
<p>到了这就可以测试一下是否成功了:</p>
<div><pre><code>ssh -T git@github.com
#之后会要你输入yes/no,输入yes就好了。
</code></pre>
</div><p>设置你的账号信息:</p>
<div><pre><code>git config --global user.name &quot;你的名字&quot;     #真实名字不是github用户名
git config --global user.email &quot;邮箱@邮箱.com&quot;	#github邮箱
</code></pre>
</div><h2 id="_3-部署到github"> 3.部署到github</h2>
<div><pre><code>hexo d
</code></pre>
</div><p>这时再刷新  username.github.io 就可以看到你的博客了。</p>
<p>到了这你以为就结束了吗？没有，还有坑没有给你们填好。</p>
<h1 id="四、最后的填坑"> 四、最后的填坑</h1>
<ol>
<li>不知道怎么修改yilia主题?(修改<em>themes/yilia/_config.yml</em>)请参考<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener noreferrer">一个简洁优雅的hexo主题 </a></li>
<li>Hexo主题配置(根目录**_config.yml**文件)</li>
<li>电脑重装了系统/多台电脑写博客？那就赶紧戳这里<a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener noreferrer">使用hexo，如果换了电脑怎么更新博客？</a></li>
<li>不知道如何编写Markdown语法？<a href="http://www.jianshu.com/p/1e402922ee32/" target="_blank" rel="noopener noreferrer">Markdown——入门指南</a></li>
<li>想要给网站添加图片？请把图片放入根目录 *source\ * 下建立一个文件夹，当你执行hexo g的时候此文件夹自动生成到public中。</li>
</ol>
<h1 id="最后"> 最后</h1>
<p>可能有部分细节疏漏，请参考：<br>
<em>全文参考:<a href="http://cyzus.github.io/2015/06/21/github-build-blog/" target="_blank" rel="noopener noreferrer">傻瓜都可以利用github pages建博客</a></em>
<em>全文参考:<a href="https://segmentfault.com/a/1190000004947261" target="_blank" rel="noopener noreferrer">手把手教你使用Hexo + Github Pages搭建个人独立博客</a></em></p>
]]></content>
    <author>
      <name>xiechengyu</name>
    </author>
    <category term="转载"/>
    <contributor>
      <name>xiechengyu</name>
    </contributor>
    <published>2018-11-16T16:07:22.000Z</published>
    <rights>Copyright by xiechengyu</rights>
  </entry>
  <entry>
    <title type="html">leetcode题解</title>
    <id>https://xiechengyu.github.io/learn/leetcode%E9%A2%98%E8%A7%A3/</id>
    <link href="https://xiechengyu.github.io/learn/leetcode%E9%A2%98%E8%A7%A3/"/>
    <updated>2023-03-22T03:48:15.000Z</updated>
    <summary type="html"><![CDATA[<h2 id="前言"> 前言</h2>
<p>leetcode刷题题解</p>
]]></summary>
    <content type="html"><![CDATA[<h2 id="前言"> 前言</h2>
<p>leetcode刷题题解
</p>
<p>把在leetcode上刷过的题目记录一二</p>
<h2 id="_1-两数之和"> 1.两数之和</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1 lang=javascript
 *
 * [1] 两数之和
 * 
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

 

示例 1：

输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：

输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：

输入：nums = [3,3], target = 6
输出：[0,1]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */</span>
<span>var</span> <span>twoSum</span> <span>=</span> <span>function</span> <span>(</span><span>nums<span>,</span> target</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> i <span>+</span> <span>1</span><span>;</span> j <span>&lt;</span> nums<span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>+</span> nums<span>[</span>j<span>]</span> <span>===</span> target<span>)</span> <span>return</span> <span>[</span>i<span>,</span> j<span>]</span>
    <span>}</span>
  <span>}</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><h2 id="_2-两数相加"> 2.两数相加</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=2 lang=javascript
 *
 * [2] 两数相加
 * 
 * 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

 

示例 1：


输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
示例 2：

输入：l1 = [0], l2 = [0]
输出：[0]
示例 3：

输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
 


 */</span>

<span>// @lc code=start</span>
<span>/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */</span>
<span>/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */</span>
<span>var</span> <span>addTwoNumbers</span> <span>=</span> <span>function</span> <span>(</span><span>l1<span>,</span> l2</span><span>)</span> <span>{</span>
    <span>let</span> out <span>=</span> <span>new</span> <span>ListNode</span><span>(</span><span>)</span>
    <span>while</span> <span>(</span>l1 <span>||</span> l2<span>)</span> <span>{</span>
        <span>const</span> value <span>=</span> l1 <span>?</span> l1<span>.</span>value <span>:</span> <span>0</span> <span>+</span> l2 <span>?</span> l2<span>.</span>value <span>:</span> <span>0</span>
        <span>if</span> <span>(</span>value <span>></span> <span>10</span><span>)</span> <span>{</span>
            out<span>.</span>value <span>=</span> value
            l1<span>.</span>next<span>.</span>value <span>+=</span> <span>1</span>
        <span>}</span> <span>else</span> <span>{</span>
            out<span>.</span>value <span>=</span> value <span>-</span> <span>10</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> out
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br></div></div><h2 id="_4-寻找两个正序数组的中位数"> 4.寻找两个正序数组的中位数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=4 lang=javascript
 *
 * [4] 寻找两个正序数组的中位数
 * 
 * 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

算法的时间复杂度应该为 O(log (m+n)) 。

 

示例 1：

输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
示例 2：

输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */</span>
<span>var</span> <span>findMedianSortedArrays</span> <span>=</span> <span>function</span> <span>(</span><span>nums1<span>,</span> nums2</span><span>)</span> <span>{</span>
    <span>const</span> nums <span>=</span> <span>[</span><span>...</span>nums1<span>,</span> <span>...</span>nums2<span>]</span><span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> b <span>-</span> a<span>)</span>
    <span>if</span> <span>(</span>nums<span>.</span>length <span>%</span> <span>2</span> <span>===</span> <span>0</span><span>)</span> <span>{</span>
        <span>const</span> end <span>=</span> nums<span>.</span>length <span>/</span> <span>2</span>
        <span>return</span> <span>(</span><span>(</span>nums<span>[</span>end <span>-</span> <span>1</span><span>]</span> <span>+</span> nums<span>[</span>end<span>]</span><span>)</span> <span>/</span> <span>2</span><span>)</span><span>.</span><span>toFixed</span><span>(</span><span>5</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span><span>padEnd</span><span>(</span><span>5</span><span>,</span> <span>"0"</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>return</span> nums<span>[</span><span>(</span>nums<span>.</span>length <span>-</span> <span>1</span><span>)</span> <span>/</span> <span>2</span><span>]</span> <span>+</span> <span>".00000"</span>
    <span>}</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h2 id="_9-回文数"> 9.回文数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=9 lang=javascript
 *
 * [9] 回文数
 * 
给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

例如，121 是回文，而 123 不是。
 

示例 1：

输入：x = 121
输出：true
示例 2：

输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
示例 3：

输入：x = 10
输出：false
解释：从右向左读, 为 01 。因此它不是一个回文数。
 


 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} x
 * @return {boolean}
 */</span>
<span>var</span> <span>isPalindrome</span> <span>=</span> <span>function</span> <span>(</span><span>x</span><span>)</span> <span>{</span>
  x <span>=</span> x<span>.</span><span>toString</span><span>(</span><span>)</span>
  <span>return</span> x <span>===</span> x<span>.</span><span>split</span><span>(</span><span>""</span><span>)</span><span>.</span><span>reverse</span><span>(</span><span>)</span><span>.</span><span>join</span><span>(</span><span>""</span><span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><h2 id="_13-罗马数字转整数"> 13.罗马数字转整数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=13 lang=javascript
 *
 * [13] 罗马数字转整数
 * 
 * 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。

示例 1:

输入: s = "III"
输出: 3
示例 2:

输入: s = "IV"
输出: 4
示例 3:

输入: s = "IX"
输出: 9
示例 4:

输入: s = "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.
示例 5:

输入: s = "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @return {number}
 */</span>
<span>var</span> <span>romanToInt</span> <span>=</span> <span>function</span> <span>(</span><span>s</span><span>)</span> <span>{</span>
    <span>const</span> map1 <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>[</span>
        <span>[</span><span>'I'</span><span>,</span> <span>1</span><span>]</span><span>,</span>
        <span>[</span><span>'V'</span><span>,</span> <span>5</span><span>]</span><span>,</span>
        <span>[</span><span>'X'</span><span>,</span> <span>10</span><span>]</span><span>,</span>
        <span>[</span><span>'L'</span><span>,</span> <span>50</span><span>]</span><span>,</span>
        <span>[</span><span>'C'</span><span>,</span> <span>100</span><span>]</span><span>,</span>
        <span>[</span><span>'D'</span><span>,</span> <span>500</span><span>]</span><span>,</span>
        <span>[</span><span>'M'</span><span>,</span> <span>1000</span><span>]</span><span>,</span>
    <span>]</span><span>)</span><span>;</span>
    <span>const</span> map2 <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>[</span>
        <span>[</span><span>'IV'</span><span>,</span> <span>4</span><span>]</span><span>,</span>
        <span>[</span><span>'IX'</span><span>,</span> <span>9</span><span>]</span><span>,</span>
        <span>[</span><span>'XL'</span><span>,</span> <span>40</span><span>]</span><span>,</span>
        <span>[</span><span>'XC'</span><span>,</span> <span>90</span><span>]</span><span>,</span>
        <span>[</span><span>'CD'</span><span>,</span> <span>400</span><span>]</span><span>,</span>
        <span>[</span><span>'CM'</span><span>,</span> <span>900</span><span>]</span><span>,</span>
    <span>]</span><span>)</span><span>;</span>
    <span>let</span> count <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>const</span> <span>[</span>key<span>,</span> value<span>]</span> <span>of</span> map2<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>s<span>.</span><span>includes</span><span>(</span>key<span>)</span><span>)</span> <span>{</span>
            s <span>=</span> s<span>.</span><span>replace</span><span>(</span>key<span>,</span> <span>''</span><span>)</span><span>;</span>
            count <span>+=</span> value<span>;</span>
        <span>}</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        count <span>+=</span> map1<span>.</span><span>get</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> count
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br></div></div><h2 id="_14-最长公共前缀"> 14.最长公共前缀</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=14 lang=javascript
 *
 * [14] 最长公共前缀
 * 
 * 编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

 

示例 1：

输入：strs = ["flower","flow","flight"]
输出："fl"
示例 2：

输入：strs = ["dog","racecar","car"]
输出：""
解释：输入不存在公共前缀。
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string[]} strs
 * @return {string}
 */</span>
<span>var</span> <span>longestCommonPrefix</span> <span>=</span> <span>function</span> <span>(</span><span>strs</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>strs<span>.</span>length <span>===</span> <span>1</span><span>)</span> <span>return</span> strs<span>[</span><span>0</span><span>]</span>
    <span>let</span> s <span>=</span> <span>""</span>
    <span>let</span> f <span>=</span> <span>true</span>
    <span>let</span> r <span>=</span> <span>0</span>
    <span>while</span> <span>(</span>f<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span>strs<span>[</span><span>0</span><span>]</span><span>[</span>r<span>]</span><span>)</span> <span>{</span>
            f <span>=</span> <span>false</span>
            <span>return</span> s
        <span>}</span>
        <span>let</span> l <span>=</span> strs<span>[</span><span>0</span><span>]</span><span>[</span>r<span>]</span>
        <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> strs<span>.</span>length <span>-</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>!</span>strs<span>[</span>i<span>]</span><span>[</span>r<span>]</span> <span>||</span> l <span>!==</span> strs<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>[</span>r<span>]</span><span>)</span> <span>{</span>
                f <span>=</span> <span>false</span>
                l <span>=</span> <span>""</span>
                <span>return</span> s
            <span>}</span>
        <span>}</span>
        s <span>+=</span> l
        r<span>++</span>
    <span>}</span>
    <span>return</span> s
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><h2 id="_20-有效的括号"> 20.有效的括号</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=20 lang=javascript
 *
 * [20] 有效的括号
 * 
 * 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
 

示例 1：

输入：s = "()"
输出：true
示例 2：

输入：s = "()[]{}"
输出：true
示例 3：

输入：s = "(]"
输出：false
示例 4：

输入：s = "([)]"
输出：false
示例 5：

输入：s = "{[]}"
输出：true
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @return {boolean}
 */</span>
<span>var</span> <span>isValid</span> <span>=</span> <span>function</span> <span>(</span><span>s</span><span>)</span> <span>{</span>
  <span>const</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>[</span><span>[</span><span>")"</span><span>,</span> <span>"("</span><span>]</span><span>,</span> <span>[</span><span>"}"</span><span>,</span> <span>"{"</span><span>]</span><span>,</span> <span>[</span><span>"]"</span><span>,</span> <span>"["</span><span>]</span><span>]</span><span>)</span><span>,</span> stack <span>=</span> <span>[</span><span>]</span>
  stack<span>.</span><span>push</span><span>(</span>s<span>[</span><span>0</span><span>]</span><span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> s<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>map<span>.</span><span>get</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span> <span>&amp;&amp;</span> stack<span>[</span>stack<span>.</span>length <span>-</span> <span>1</span><span>]</span> <span>&amp;&amp;</span> map<span>.</span><span>get</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span> <span>===</span> stack<span>[</span>stack<span>.</span>length <span>-</span> <span>1</span><span>]</span><span>)</span> stack<span>.</span><span>pop</span><span>(</span><span>)</span>
    <span>else</span> stack<span>.</span><span>push</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span>
  <span>}</span>
  <span>return</span> stack<span>.</span>length <span>===</span> <span>0</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><h2 id="_21-合并两个有序链表"> 21.合并两个有序链表</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=21 lang=javascript
 *
 * [21] 合并两个有序链表
 * 
 * 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

 

示例 1：

输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
示例 2：

输入：l1 = [], l2 = []
输出：[]
示例 3：

输入：l1 = [], l2 = [0]
输出：[0]

 */</span>

<span>// @lc code=start</span>
<span>/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */</span>
<span>/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */</span>
<span>var</span> <span>mergeTwoLists</span> <span>=</span> <span>function</span> <span>(</span><span>l1<span>,</span> l2</span><span>)</span> <span>{</span>
    <span>let</span> headnode <span>=</span> <span>new</span> <span>ListNode</span><span>(</span><span>)</span><span>,</span> node <span>=</span> headnode<span>;</span>
    <span>while</span> <span>(</span>l1 <span>&amp;&amp;</span> l2<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>l1<span>.</span>val <span>&lt;</span> l2<span>.</span>val<span>)</span> <span>{</span>
            node<span>.</span>next <span>=</span> l1
            l1 <span>=</span> l1<span>.</span>next
        <span>}</span> <span>else</span> <span>{</span>
            node<span>.</span>next <span>=</span> l2
            l2 <span>=</span> l2<span>.</span>next
        <span>}</span>
        node <span>=</span> node<span>.</span>next
    <span>}</span>
    node<span>.</span>next <span>=</span> l1 <span>||</span> l2
    <span>return</span> headnode<span>.</span>next
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><h2 id="_26-删除有序数组中的重复项"> 26.删除有序数组中的重复项</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=26 lang=javascript
 *
 * [26] 删除有序数组中的重复项
 * 
 * 给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。

由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。

将最终结果插入 nums 的前 k 个位置后返回 k 。

不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

判题标准:

系统会用下面的代码来测试你的题解:

int[] nums = [...]; // 输入数组
int[] expectedNums = [...]; // 长度正确的期望答案

int k = removeDuplicates(nums); // 调用

assert k == expectedNums.length;
for (int i = 0; i &lt; k; i++) {
    assert nums[i] == expectedNums[i];
}
如果所有断言都通过，那么您的题解将被 通过。

 

示例 1：

输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
示例 2：

输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number}
 */</span>
<span>var</span> <span>removeDuplicates</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>===</span> nums<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span> <span>{</span>
            nums<span>.</span><span>splice</span><span>(</span>i <span>-</span> <span>1</span><span>,</span> <span>1</span><span>)</span>
        <span>}</span> <span>else</span> <span>{</span>
            i<span>++</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> nums<span>.</span>length
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br></div></div><h2 id="_27-移除元素"> 27.移除元素</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=27 lang=javascript
 *
 * [27] 移除元素
 * 
 * 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

 

说明:

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}
 

示例 1：

输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
示例 2：

输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
 


 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */</span>
<span>var</span> <span>removeElement</span> <span>=</span> <span>function</span> <span>(</span><span>nums<span>,</span> val</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>===</span> val<span>)</span> <span>{</span>
            nums<span>.</span><span>splice</span><span>(</span>i<span>,</span> <span>1</span><span>)</span>
        <span>}</span> <span>else</span> <span>{</span>
            i<span>++</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> nums<span>.</span>length
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br></div></div><h2 id="_28-实现-str-str"> 28.实现-str-str</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=28 lang=javascript
 *
 * [28] 实现 strStr()
 * 
 * 实现 strStr() 函数。

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。

说明：

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。

 

示例 1：

输入：haystack = "hello", needle = "ll"
输出：2
示例 2：

输入：haystack = "aaaaa", needle = "bba"
输出：-1
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */</span>
<span>var</span> <span>strStr</span> <span>=</span> <span>function</span> <span>(</span><span>haystack<span>,</span> needle</span><span>)</span> <span>{</span>
  <span>return</span> haystack<span>.</span><span>indexOf</span><span>(</span>needle<span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><h2 id="_35-搜索插入位置"> 35.搜索插入位置</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=35 lang=javascript
 *
 * [35] 搜索插入位置
 * 
 * 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。

 

示例 1:

输入: nums = [1,3,5,6], target = 5
输出: 2
示例 2:

输入: nums = [1,3,5,6], target = 2
输出: 1
示例 3:

输入: nums = [1,3,5,6], target = 7
输出: 4
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */</span>
<span>var</span> <span>searchInsert</span> <span>=</span> <span>function</span> <span>(</span><span>nums<span>,</span> target</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>target <span>&lt;=</span> nums<span>[</span><span>0</span><span>]</span><span>)</span> <span>return</span> <span>0</span>
    <span>if</span> <span>(</span>target <span>></span> nums<span>[</span>nums<span>.</span>length <span>-</span> <span>1</span><span>]</span><span>)</span> <span>return</span> nums<span>.</span>length
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>nums<span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>&lt;=</span> target <span>&amp;&amp;</span> nums<span>[</span>i<span>]</span> <span>>=</span> target<span>)</span> <span>return</span> i
    <span>}</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h2 id="_36-有效的数独"> 36.有效的数独</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=36 lang=javascript
 *
 * [36] 有效的数独
 * 
 * 请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
 

注意：

一个有效的数独（部分已被填充）不一定是可解的。
只需要根据以上规则，验证已经填入的数字是否有效即可。
空白格用 '.' 表示。
 

示例 1：


输入：board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：true
示例 2：

输入：board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：false
解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {character[][]} board
 * @return {boolean}
 */</span>
<span>var</span> <span>isValidSudoku</span> <span>=</span> <span>function</span> <span>(</span><span>board</span><span>)</span> <span>{</span>
  <span>let</span> c <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>9</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> set1 <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>)</span><span>,</span> set2 <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>)</span><span>,</span> set3 <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>)</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> <span>9</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>board<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>!==</span> <span>'.'</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>set1<span>.</span><span>has</span><span>(</span>board<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>)</span><span>)</span> <span>return</span> <span>false</span>
        set1<span>.</span><span>add</span><span>(</span>board<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>)</span>
      <span>}</span>
      <span>if</span> <span>(</span>board<span>[</span>j<span>]</span><span>[</span>i<span>]</span> <span>!==</span> <span>'.'</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>set2<span>.</span><span>has</span><span>(</span>board<span>[</span>j<span>]</span><span>[</span>i<span>]</span><span>)</span><span>)</span> <span>return</span> <span>false</span>
        set2<span>.</span><span>add</span><span>(</span>board<span>[</span>j<span>]</span><span>[</span>i<span>]</span><span>)</span>
      <span>}</span>
      <span>const</span> <span>[</span>x<span>,</span> y<span>]</span> <span>=</span> <span>getXY</span><span>(</span>c<span>)</span>
      <span>const</span> n <span>=</span> j <span>%</span> <span>3</span> <span>+</span> y<span>,</span> m <span>=</span> Math<span>.</span><span>floor</span><span>(</span>j <span>/</span> <span>3</span><span>)</span> <span>+</span> x
      <span>if</span> <span>(</span>board<span>[</span>m<span>]</span><span>[</span>n<span>]</span> <span>!==</span> <span>'.'</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>set3<span>.</span><span>has</span><span>(</span>board<span>[</span>m<span>]</span><span>[</span>n<span>]</span><span>)</span><span>)</span> <span>return</span> <span>false</span>
        set3<span>.</span><span>add</span><span>(</span>board<span>[</span>m<span>]</span><span>[</span>n<span>]</span><span>)</span>
      <span>}</span>
    <span>}</span>
    c<span>++</span>
  <span>}</span>
  <span>return</span> <span>true</span>
<span>}</span><span>;</span>

<span>/**
 * @param {number} board
 * @return {array}
 */</span>
<span>var</span> <span>getXY</span> <span>=</span> <span>function</span> <span>(</span><span>num</span><span>)</span> <span>{</span>
  <span>switch</span> <span>(</span>num<span>)</span> <span>{</span>
    <span>case</span> <span>0</span><span>:</span>
      <span>return</span> <span>[</span><span>0</span><span>,</span> <span>0</span><span>]</span>
    <span>case</span> <span>1</span><span>:</span>
      <span>return</span> <span>[</span><span>3</span><span>,</span> <span>0</span><span>]</span>
    <span>case</span> <span>2</span><span>:</span>
      <span>return</span> <span>[</span><span>6</span><span>,</span> <span>0</span><span>]</span>
    <span>case</span> <span>3</span><span>:</span>
      <span>return</span> <span>[</span><span>0</span><span>,</span> <span>3</span><span>]</span>
    <span>case</span> <span>4</span><span>:</span>
      <span>return</span> <span>[</span><span>3</span><span>,</span> <span>3</span><span>]</span>
    <span>case</span> <span>5</span><span>:</span>
      <span>return</span> <span>[</span><span>6</span><span>,</span> <span>3</span><span>]</span>
    <span>case</span> <span>6</span><span>:</span>
      <span>return</span> <span>[</span><span>0</span><span>,</span> <span>6</span><span>]</span>
    <span>case</span> <span>7</span><span>:</span>
      <span>return</span> <span>[</span><span>3</span><span>,</span> <span>6</span><span>]</span>
    <span>case</span> <span>8</span><span>:</span>
      <span>return</span> <span>[</span><span>6</span><span>,</span> <span>6</span><span>]</span>
  <span>}</span>
<span>}</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br></div></div><h2 id="_53-最大子序和"> 53.最大子序和</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=53 lang=javascript
 *
 * [53] 最大子序和
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number}
 */</span>
<span>var</span> <span>maxSubArray</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
    <span>let</span> prev <span>=</span> <span>0</span><span>,</span> max <span>=</span> <span>-</span>Number<span>.</span><span>MAX_VALUE</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        prev <span>=</span> Math<span>.</span><span>max</span><span>(</span>prev <span>+</span> nums<span>[</span>i<span>]</span><span>,</span> nums<span>[</span>i<span>]</span><span>)</span>
        max <span>=</span> Math<span>.</span><span>max</span><span>(</span>max<span>,</span> prev<span>)</span>
    <span>}</span>
    <span>return</span> max
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id="_53-最大子数组和"> 53.最大子数组和</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=53 lang=javascript
 *
 * [53] 最大子数组和
 * 
 * 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组 是数组中的一个连续部分。

 

示例 1：

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
示例 2：

输入：nums = [1]
输出：1
示例 3：

输入：nums = [5,4,-1,7,8]
输出：23
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number}
 */</span>
<span>var</span> <span>maxSubArray</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
  <span>let</span> res <span>=</span> nums<span>[</span><span>0</span><span>]</span><span>,</span> count <span>=</span> nums<span>[</span><span>0</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>count <span>+</span> nums<span>[</span>i<span>]</span> <span>></span> nums<span>[</span>i<span>]</span><span>)</span> count <span>+=</span> nums<span>[</span>i<span>]</span><span>;</span>
    <span>else</span> count <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
    <span>if</span> <span>(</span>count <span>></span> res<span>)</span> res <span>=</span> count<span>;</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h2 id="_58-最后一个单词的长度"> 58.最后一个单词的长度</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=58 lang=javascript
 *
 * [58] 最后一个单词的长度
 * 
 * 给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。

单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。

 

示例 1：

输入：s = "Hello World"
输出：5
解释：最后一个单词是“World”，长度为5。
示例 2：

输入：s = "   fly me   to   the moon  "
输出：4
解释：最后一个单词是“moon”，长度为4。
示例 3：

输入：s = "luffy is still joyboy"
输出：6
解释：最后一个单词是长度为6的“joyboy”。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @return {number}
 */</span>
<span>var</span> <span>lengthOfLastWord</span> <span>=</span> <span>function</span> <span>(</span><span>s</span><span>)</span> <span>{</span>
    <span>const</span> arr <span>=</span> s<span>.</span><span>trim</span><span>(</span><span>)</span><span>.</span><span>split</span><span>(</span><span>" "</span><span>)</span>
    <span>return</span> arr<span>[</span>arr<span>.</span>length <span>-</span> <span>1</span><span>]</span><span>.</span>length
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id="_66-加一"> 66.加一</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=66 lang=javascript
 *
 * [66] 加一
 * 
 * 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

 

示例 1：

输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
示例 2：

输入：digits = [4,3,2,1]
输出：[4,3,2,2]
解释：输入数组表示数字 4321。
示例 3：

输入：digits = [0]
输出：[1]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} digits
 * @return {number[]}
 */</span>
<span>var</span> <span>plusOne</span> <span>=</span> <span>function</span> <span>(</span><span>digits</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> digits<span>.</span>length <span>-</span> <span>1</span><span>;</span> i <span>></span> <span>-</span><span>1</span><span>;</span> i<span>--</span><span>)</span> <span>{</span>
        digits<span>[</span>i<span>]</span><span>++</span>
        <span>if</span> <span>(</span>digits<span>[</span>i<span>]</span> <span>></span> <span>9</span><span>)</span> <span>{</span>
            digits<span>[</span>i<span>]</span> <span>=</span> <span>0</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>return</span> digits
        <span>}</span>
    <span>}</span>
    digits<span>.</span><span>unshift</span><span>(</span><span>1</span><span>)</span>
    <span>return</span> digits
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><h2 id="_67-二进制求和"> 67.二进制求和</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=67 lang=javascript
 *
 * [67] 二进制求和
 * 
 * 给你两个二进制字符串，返回它们的和（用二进制表示）。

输入为 非空 字符串且只包含数字 1 和 0。

 

示例 1:

输入: a = "11", b = "1"
输出: "100"
示例 2:

输入: a = "1010", b = "1011"
输出: "10101"
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */</span>
<span>var</span> <span>addBinary</span> <span>=</span> <span>function</span> <span>(</span><span>a<span>,</span> b</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span><span>BigInt</span><span>(</span><span>"0b"</span> <span>+</span> a<span>)</span> <span>+</span> <span>BigInt</span><span>(</span><span>"0b"</span> <span>+</span> b<span>)</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>2</span><span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><h2 id="_69-x-的平方根"> 69.x-的平方根</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=69 lang=javascript
 *
 * [69] x 的平方根 
 * 
 * 给你一个非负整数 x ，计算并返回 x 的 算术平方根 。

由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。

注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。

 

示例 1：

输入：x = 4
输出：2
示例 2：

输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} x
 * @return {number}
 */</span>
<span>var</span> <span>mySqrt</span> <span>=</span> <span>function</span> <span>(</span><span>x</span><span>)</span> <span>{</span>
  <span>let</span> l <span>=</span> <span>1</span><span>,</span> r <span>=</span> Math<span>.</span><span>floor</span><span>(</span>x <span>/</span> <span>2</span><span>)</span> <span>+</span> <span>1</span><span>,</span> mid
  <span>while</span> <span>(</span>l <span>&lt;=</span> r<span>)</span> <span>{</span>
    mid <span>=</span> Math<span>.</span><span>floor</span><span>(</span><span>(</span>l <span>+</span> r<span>)</span> <span>/</span> <span>2</span><span>)</span>
    <span>if</span> <span>(</span>mid <span>*</span> mid <span>></span> x<span>)</span> r <span>=</span> mid <span>-</span> <span>1</span>
    <span>else</span> <span>if</span> <span>(</span>mid <span>*</span> mid <span>&lt;</span> x<span>)</span> l <span>=</span> mid <span>+</span> <span>1</span>
    <span>else</span> <span>return</span> mid
  <span>}</span>
  <span>return</span> r
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><h2 id="_70-爬楼梯"> 70.爬楼梯</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=70 lang=javascript
 *
 * [70] 爬楼梯
 * 
 * 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

 

示例 1：

输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
示例 2：

输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
 


 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} n
 * @return {number}
 */</span>
<span>var</span> <span>climbStairs</span> <span>=</span> <span>function</span> <span>(</span><span>n</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>n <span>&lt;</span> <span>4</span><span>)</span> <span>return</span> n
  <span>let</span> i <span>=</span> <span>2</span><span>,</span> j <span>=</span> <span>3</span>
  <span>for</span> <span>(</span><span>let</span> k <span>=</span> <span>4</span><span>;</span> k <span>&lt;</span> n<span>;</span> k<span>++</span><span>)</span> <span>[</span>j<span>,</span> i<span>]</span> <span>=</span> <span>[</span>j <span>+</span> i<span>,</span> j<span>]</span>
  <span>return</span> i <span>+</span> j
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><h2 id="_83-删除排序链表中的重复元素"> 83.删除排序链表中的重复元素</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=83 lang=javascript
 *
 * [83] 删除排序链表中的重复元素
 * 
 * 给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。

 

示例 1：


输入：head = [1,1,2]
输出：[1,2]
示例 2：


输入：head = [1,1,2,3,3]
输出：[1,2,3]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */</span>
<span>/**
 * @param {ListNode} head
 * @return {ListNode}
 */</span>
<span>var</span> <span>deleteDuplicates</span> <span>=</span> <span>function</span> <span>(</span><span>head</span><span>)</span> <span>{</span>
    <span>let</span> node <span>=</span> head
    <span>while</span> <span>(</span>node<span>)</span> <span>{</span>
        <span>const</span> next <span>=</span> node<span>.</span>next
        <span>if</span> <span>(</span>next <span>&amp;&amp;</span> <span>(</span>next<span>.</span>val <span>===</span> node<span>.</span>val<span>)</span><span>)</span> <span>{</span>
            node<span>.</span>next <span>=</span> next<span>.</span>next
        <span>}</span> <span>else</span> <span>{</span>
            node <span>=</span> node<span>.</span>next
        <span>}</span>
    <span>}</span>
    <span>return</span> head
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><h2 id="_88-合并两个有序数组"> 88.合并两个有序数组</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=88 lang=javascript
 *
 * [88] 合并两个有序数组
 * 
 * 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

 

示例 1：

输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
示例 2：

输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 [] 。
合并结果是 [1] 。
示例 3：

输入：nums1 = [0], m = 0, nums2 = [1], n = 1
输出：[1]
解释：需要合并的数组是 [] 和 [1] 。
合并结果是 [1] 。
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */</span>
<span>var</span> <span>merge</span> <span>=</span> <span>function</span> <span>(</span><span>nums1<span>,</span> m<span>,</span> nums2<span>,</span> n</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> m <span>+</span> n <span>-</span> <span>1</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>n <span>===</span> <span>0</span><span>)</span> <span>break</span>
        <span>if</span> <span>(</span>nums1<span>[</span>m <span>-</span> <span>1</span><span>]</span> <span>></span> nums2<span>[</span>n <span>-</span> <span>1</span><span>]</span><span>)</span> <span>{</span>
            nums1<span>[</span>i<span>]</span> <span>=</span> nums1<span>[</span>m <span>-</span> <span>1</span><span>]</span><span>;</span>
            m<span>--</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            nums1<span>[</span>i<span>]</span> <span>=</span> nums2<span>[</span>n <span>-</span> <span>1</span><span>]</span>
            n<span>--</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div><h2 id="_94-二叉树的中序遍历"> 94.二叉树的中序遍历</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=94 lang=javascript
 *
 * [94] 二叉树的中序遍历
 * 
 * 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。

 

示例 1：


输入：root = [1,null,2,3]
输出：[1,3,2]
示例 2：

输入：root = []
输出：[]
示例 3：

输入：root = [1]
输出：[1]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span>/**
 * @param {TreeNode} root
 * @return {number[]}
 */</span>
<span>var</span> <span>inorderTraversal</span> <span>=</span> <span>function</span> <span>(</span><span>root</span><span>)</span> <span>{</span>
    <span>let</span> res <span>=</span> <span>[</span><span>]</span><span>,</span> stack <span>=</span> <span>[</span><span>]</span>
    <span>while</span> <span>(</span>root <span>||</span> stack<span>.</span>length <span>></span> <span>0</span><span>)</span> <span>{</span>
        <span>if</span><span>(</span>root<span>)</span><span>{</span>
            stack<span>.</span><span>push</span><span>(</span>root<span>)</span>
            root <span>=</span> root<span>.</span>left
        <span>}</span><span>else</span><span>{</span>
            root <span>=</span> stack<span>.</span><span>pop</span><span>(</span><span>)</span>
            res<span>.</span><span>push</span><span>(</span>root<span>.</span>val<span>)</span>
            root <span>=</span> root<span>.</span>right
        <span>}</span>
    <span>}</span>
    <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><h2 id="_100-相同的树"> 100.相同的树</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=100 lang=javascript
 *
 * [100] 相同的树
 * 
 * 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

 

示例 1：


输入：p = [1,2,3], q = [1,2,3]
输出：true
示例 2：


输入：p = [1,2], q = [1,null,2]
输出：false
示例 3：


输入：p = [1,2,1], q = [1,1,2]
输出：false
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span>/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */</span>
<span>var</span> <span>isSameTree</span> <span>=</span> <span>function</span> <span>(</span><span>p<span>,</span> q</span><span>)</span> <span>{</span>
    <span>let</span> stackP <span>=</span> <span>[</span><span>]</span><span>,</span> stackQ <span>=</span> <span>[</span><span>]</span>
    <span>while</span> <span>(</span>p <span>||</span> stackP<span>.</span>length <span>||</span> q <span>||</span> stackQ<span>.</span>length<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>p <span>||</span> q<span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>(</span><span>!</span>p <span>||</span> <span>!</span>q<span>)</span> <span>||</span> p<span>.</span>val <span>!==</span> q<span>.</span>val<span>)</span> <span>return</span> <span>false</span>
            stackP<span>.</span><span>push</span><span>(</span>p<span>)</span>
            stackQ<span>.</span><span>push</span><span>(</span>q<span>)</span>
            p <span>=</span> p<span>.</span>left
            q <span>=</span> q<span>.</span>left
        <span>}</span> <span>else</span> <span>{</span>
            p <span>=</span> stackP<span>.</span><span>pop</span><span>(</span><span>)</span>
            q <span>=</span> stackQ<span>.</span><span>pop</span><span>(</span><span>)</span>
            <span>if</span> <span>(</span>p<span>.</span>val <span>!==</span> q<span>.</span>val<span>)</span> <span>return</span> <span>false</span>
            p <span>=</span> p<span>.</span>right
            q <span>=</span> q<span>.</span>right
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>true</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br></div></div><h2 id="_101-对称二叉树"> 101.对称二叉树</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=101 lang=javascript
 *
 * [101] 对称二叉树
 * 
 * 给你一个二叉树的根节点 root ， 检查它是否轴对称。

 

示例 1：


输入：root = [1,2,2,3,4,4,3]
输出：true
示例 2：


输入：root = [1,2,2,null,3,null,3]
输出：false
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span>/**
 * @param {TreeNode} root
 * @return {boolean}
 */</span>
<span>var</span> <span>isSymmetric</span> <span>=</span> <span>function</span> <span>(</span><span>root</span><span>)</span> <span>{</span>
    <span>let</span> stackP <span>=</span> <span>[</span><span>]</span><span>,</span> stackQ <span>=</span> <span>[</span><span>]</span><span>,</span> p <span>=</span> root<span>.</span>left<span>,</span> q <span>=</span> root<span>.</span>right
    <span>while</span> <span>(</span>p <span>||</span> stackP<span>.</span>length <span>||</span> q <span>||</span> stackQ<span>.</span>length<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>p <span>||</span> q<span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>(</span><span>!</span>p <span>||</span> <span>!</span>q<span>)</span> <span>||</span> p<span>.</span>val <span>!==</span> q<span>.</span>val<span>)</span> <span>return</span> <span>false</span>
            stackP<span>.</span><span>push</span><span>(</span>p<span>)</span>
            stackQ<span>.</span><span>push</span><span>(</span>q<span>)</span>
            p <span>=</span> p<span>.</span>left
            q <span>=</span> q<span>.</span>right
        <span>}</span> <span>else</span> <span>{</span>
            p <span>=</span> stackP<span>.</span><span>pop</span><span>(</span><span>)</span>
            q <span>=</span> stackQ<span>.</span><span>pop</span><span>(</span><span>)</span>
            <span>if</span> <span>(</span>p<span>.</span>val <span>!==</span> q<span>.</span>val<span>)</span> <span>return</span> <span>false</span>
            p <span>=</span> p<span>.</span>right
            q <span>=</span> q<span>.</span>left
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>true</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div><h2 id="_104-二叉树的最大深度"> 104.二叉树的最大深度</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=104 lang=javascript
 *
 * [104] 二叉树的最大深度
 * 
 * 给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
给定二叉树 [3,9,20,null,null,15,7]，

    3
   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。
 */</span>

<span>// @lc code=start</span>
<span>/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span>/**
 * @param {TreeNode} root
 * @return {number}
 */</span>
<span>var</span> <span>maxDepth</span> <span>=</span> <span>function</span> <span>(</span><span>root</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>root<span>)</span> <span>return</span> <span>0</span>
    <span>return</span> Math<span>.</span><span>max</span><span>(</span><span>maxDepth</span><span>(</span>root<span>.</span>left<span>)</span><span>,</span> <span>maxDepth</span><span>(</span>root<span>.</span>right<span>)</span><span>)</span> <span>+</span> <span>1</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h2 id="_108-将有序数组转换为二叉搜索树"> 108.将有序数组转换为二叉搜索树</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=108 lang=typescript
 *
 * [108] 将有序数组转换为二叉搜索树
 * 
 * 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。

高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

 

示例 1：


输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：

示例 2：


输入：nums = [1,3]
输出：[3,1]
解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */</span>

<span>function</span> <span>sortedArrayToBST</span><span>(</span>nums<span>:</span> <span>number</span><span>[</span><span>]</span><span>)</span><span>:</span> TreeNode <span>|</span> <span>null</span> <span>{</span>
  <span>if</span><span>(</span><span>!</span>nums <span>||</span> nums<span>.</span>length <span>===</span><span>0</span><span>)</span> <span>return</span> <span>null</span>
  <span>let</span> mid <span>=</span> Math<span>.</span><span>ceil</span><span>(</span>nums<span>.</span>length<span>/</span><span>2</span><span>)</span><span>-</span><span>1</span><span>;</span>
  <span>let</span> head <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span>nums<span>[</span>mid<span>]</span><span>)</span>
  head<span>.</span>left <span>=</span> <span>sortedArrayToBST</span><span>(</span>nums<span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span>mid<span>)</span><span>)</span>
  head<span>.</span>right <span>=</span> <span>sortedArrayToBST</span><span>(</span>nums<span>.</span><span>slice</span><span>(</span>mid<span>+</span><span>1</span><span>)</span><span>)</span>
  <span>return</span> head
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><h2 id="_110-平衡二叉树"> 110.平衡二叉树</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=110 lang=typescript
 *
 * [110] 平衡二叉树
 * 
 * 给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。

 

示例 1：


输入：root = [3,9,20,null,null,15,7]
输出：true
示例 2：


输入：root = [1,2,2,3,3,null,null,4,4]
输出：false
示例 3：

输入：root = []
输出：true
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */</span>

<span>function</span> <span>isBalanced</span><span>(</span>root<span>:</span> TreeNode <span>|</span> <span>null</span><span>)</span><span>:</span> <span>boolean</span> <span>{</span>
  <span>function</span> <span>helper</span><span>(</span>node<span>:</span> TreeNode <span>|</span> <span>null</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>node<span>)</span> <span>return</span> <span>0</span><span>;</span>
    <span>let</span> l <span>=</span> <span>helper</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
    <span>let</span> r <span>=</span> <span>helper</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>
    <span>if</span> <span>(</span>l <span>&lt;</span> <span>0</span> <span>||</span> r <span>&lt;</span> <span>0</span> <span>||</span> Math<span>.</span><span>abs</span><span>(</span>l <span>-</span> r<span>)</span> <span>></span> <span>1</span><span>)</span> <span>return</span> <span>-</span><span>1</span><span>;</span>
    <span>return</span> Math<span>.</span><span>max</span><span>(</span>l<span>,</span> r<span>)</span> <span>+</span> <span>1</span><span>;</span>
  <span>}</span>
  <span>return</span> <span>helper</span><span>(</span>root<span>)</span> <span>!==</span> <span>-</span><span>1</span><span>;</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div><h2 id="_118-杨辉三角"> 118.杨辉三角</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=118 lang=javascript
 *
 * [118] 杨辉三角
 * 
 * 给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。



 

示例 1:

输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
示例 2:

输入: numRows = 1
输出: [[1]]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} numRows
 * @return {number[][]}
 */</span>
<span>var</span> <span>generate</span> <span>=</span> <span>function</span> <span>(</span><span>numRows</span><span>)</span> <span>{</span>
    <span>let</span> res <span>=</span> <span>[</span><span>[</span><span>1</span><span>]</span><span>]</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> numRows<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>let</span> item <span>=</span> <span>[</span><span>1</span><span>]</span>
        <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>1</span><span>;</span> j <span>&lt;</span> res<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
            item<span>.</span><span>push</span><span>(</span>res<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j<span>]</span> <span>+</span> res<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j <span>-</span> <span>1</span><span>]</span><span>)</span>
        <span>}</span>
        item<span>.</span><span>push</span><span>(</span><span>1</span><span>)</span>
        res<span>.</span><span>push</span><span>(</span>item<span>)</span>
    <span>}</span>
    <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h2 id="_119-杨辉三角-ii"> 119.杨辉三角-ii</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=119 lang=javascript
 *
 * [119] 杨辉三角 II
 * 
 * 给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。



 

示例 1:

输入: rowIndex = 3
输出: [1,3,3,1]
示例 2:

输入: rowIndex = 0
输出: [1]
示例 3:

输入: rowIndex = 1
输出: [1,1]
 


 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} rowIndex
 * @return {number[]}
 */</span>
<span>var</span> <span>getRow</span> <span>=</span> <span>function</span> <span>(</span><span>rowIndex</span><span>)</span> <span>{</span>
    <span>let</span> res <span>=</span> <span>[</span><span>[</span><span>1</span><span>]</span><span>]</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> rowIndex <span>+</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>let</span> item <span>=</span> <span>[</span><span>1</span><span>]</span>
        <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>1</span><span>;</span> j <span>&lt;</span> res<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
            item<span>.</span><span>push</span><span>(</span>res<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j<span>]</span> <span>+</span> res<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j <span>-</span> <span>1</span><span>]</span><span>)</span>
        <span>}</span>
        item<span>.</span><span>push</span><span>(</span><span>1</span><span>)</span>
        res<span>.</span><span>push</span><span>(</span>item<span>)</span>
    <span>}</span>
    <span>return</span> res<span>.</span><span>pop</span><span>(</span><span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><h2 id="_121-买卖股票的最佳时机"> 121.买卖股票的最佳时机</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=121 lang=javascript
 *
 * [121] 买卖股票的最佳时机
 * 
 * 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

 

示例 1：

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
示例 2：

输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} prices
 * @return {number}
 */</span>
<span>var</span> <span>maxProfit</span> <span>=</span> <span>function</span> <span>(</span><span>prices</span><span>)</span> <span>{</span>
    <span>let</span> min <span>=</span> Number<span>.</span><span>MAX_SAFE_INTEGER</span><span>,</span> max <span>=</span> <span>0</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> prices<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        min <span>=</span> Math<span>.</span><span>min</span><span>(</span>min<span>,</span> prices<span>[</span>i<span>]</span><span>)</span>
        max <span>=</span> Math<span>.</span><span>max</span><span>(</span>max<span>,</span> prices<span>[</span>i<span>]</span> <span>-</span> min<span>)</span>
    <span>}</span>
    <span>return</span> max
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><h2 id="_125-验证回文串"> 125.验证回文串</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=125 lang=javascript
 *
 * [125] 验证回文串
 * 
 * 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

说明：本题中，我们将空字符串定义为有效的回文串。

 

示例 1:

输入: "A man, a plan, a canal: Panama"
输出: true
解释："amanaplanacanalpanama" 是回文串
示例 2:

输入: "race a car"
输出: false
解释："raceacar" 不是回文串
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @return {boolean}
 */</span>
<span>var</span> <span>isPalindrome</span> <span>=</span> <span>function</span> <span>(</span><span>s</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>s<span>.</span><span>trim</span><span>(</span><span>)</span> <span>===</span> <span>""</span><span>)</span> <span>return</span> <span>true</span>
    s <span>=</span> <span>(</span>s<span>.</span><span>match</span><span>(</span><span><span>/</span><span>[0-9a-z]</span><span>/</span><span>ig</span></span><span>)</span> <span>||</span> <span>[</span><span>]</span><span>)</span><span>.</span><span>map</span><span>(</span><span>i</span> <span>=></span> i<span>.</span><span>toLocaleLowerCase</span><span>(</span><span>)</span><span>)</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span>length <span>/</span> <span>2</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>s<span>[</span>i<span>]</span> <span>!==</span> s<span>[</span>s<span>.</span>length <span>-</span> i <span>-</span> <span>1</span><span>]</span><span>)</span> <span>return</span> <span>false</span>
    <span>}</span>
    <span>return</span> <span>true</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><h2 id="_136-只出现一次的数字"> 136.只出现一次的数字</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=136 lang=javascript
 *
 * [136] 只出现一次的数字
 * 
 * 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,1]
输出: 1
示例 2:

输入: [4,1,2,1,2]
输出: 4

 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number}
 */</span>
<span>var</span> <span>singleNumber</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>1</span><span>;</span> j <span>&lt;</span> nums<span>.</span>length<span>;</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>nums<span>[</span><span>0</span><span>]</span> <span>===</span> nums<span>[</span>j<span>]</span><span>)</span> <span>{</span>
            nums<span>.</span><span>splice</span><span>(</span>j<span>,</span> <span>1</span><span>)</span>
            nums<span>.</span><span>shift</span><span>(</span><span>)</span>
            j <span>=</span> <span>1</span>
        <span>}</span> <span>else</span> <span>{</span>
            j<span>++</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> nums<span>[</span><span>0</span><span>]</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h2 id="_141-环形链表"> 141.环形链表</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=141 lang=javascript
 *
 * [141] 环形链表
 * 
 * 给你一个链表的头节点 head ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。

如果链表中存在环 ，则返回 true 。 否则，返回 false 。

 

示例 1：



输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
示例 2：



输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
示例 3：



输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */</span>

<span>/**
 * @param {ListNode} head
 * @return {boolean}
 */</span>
<span>var</span> <span>hasCycle</span> <span>=</span> <span>function</span> <span>(</span><span>head</span><span>)</span> <span>{</span>
  <span>while</span> <span>(</span>head<span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>head<span>.</span>val<span>)</span> <span>return</span> <span>true</span>
    head<span>.</span>val <span>=</span> <span>null</span>
    head <span>=</span> head<span>.</span>next
  <span>}</span>
  <span>return</span> <span>false</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br></div></div><h2 id="_144-二叉树的前序遍历"> 144.二叉树的前序遍历</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=144 lang=javascript
 *
 * [144] 二叉树的前序遍历
 * 
 * 给你二叉树的根节点 root ，返回它节点值的 前序 遍历。

 

示例 1：


输入：root = [1,null,2,3]
输出：[1,2,3]
示例 2：

输入：root = []
输出：[]
示例 3：

输入：root = [1]
输出：[1]
示例 4：


输入：root = [1,2]
输出：[1,2]
示例 5：


输入：root = [1,null,2]
输出：[1,2]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span>/**
 * @param {TreeNode} root
 * @return {number[]}
 */</span>
<span>var</span> <span>preorderTraversal</span> <span>=</span> <span>function</span> <span>(</span><span>root</span><span>)</span> <span>{</span>
    <span>let</span> res <span>=</span> <span>[</span><span>]</span><span>,</span> stack <span>=</span> <span>[</span><span>]</span>
    <span>while</span> <span>(</span>root <span>||</span> stack<span>.</span>length <span>></span> <span>0</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>root<span>)</span> <span>{</span>
            res<span>.</span><span>push</span><span>(</span>root<span>.</span>val<span>)</span>
            stack<span>.</span><span>push</span><span>(</span>root<span>)</span>
            root <span>=</span> root<span>.</span>left
        <span>}</span> <span>else</span> <span>{</span>
            root <span>=</span> stack<span>.</span><span>pop</span><span>(</span><span>)</span>
            root <span>=</span> root<span>.</span>right
        <span>}</span>
    <span>}</span>
    <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br></div></div><h2 id="_145-二叉树的后序遍历"> 145.二叉树的后序遍历</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=145 lang=javascript
 *
 * [145] 二叉树的后序遍历
 * 
 * 给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。

 

示例 1：


输入：root = [1,null,2,3]
输出：[3,2,1]
示例 2：

输入：root = []
输出：[]
示例 3：

输入：root = [1]
输出：[1]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span>/**
 * @param {TreeNode} root
 * @return {number[]}
 */</span>
<span>var</span> <span>postorderTraversal</span> <span>=</span> <span>function</span> <span>(</span><span>root</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>root<span>)</span> <span>return</span> <span>[</span><span>]</span>
    <span>let</span> res <span>=</span> <span>[</span><span>]</span><span>,</span> stack <span>=</span> <span>[</span>root<span>]</span>
    <span>while</span> <span>(</span>stack<span>.</span>length <span>></span> <span>0</span><span>)</span> <span>{</span>
        root <span>=</span> stack<span>.</span><span>shift</span><span>(</span><span>)</span>
        res<span>.</span><span>unshift</span><span>(</span>root<span>.</span>val<span>)</span>
        <span>if</span> <span>(</span>root<span>.</span>left<span>)</span> stack<span>.</span><span>unshift</span><span>(</span>root<span>.</span>left<span>)</span>
        <span>if</span> <span>(</span>root<span>.</span>right<span>)</span> stack<span>.</span><span>unshift</span><span>(</span>root<span>.</span>right<span>)</span>
    <span>}</span>
    <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><h2 id="_146-lru-缓存"> 146.lru-缓存</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=146 lang=javascript
 *
 * [146] LRU 缓存
 * 
 * 请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。
实现 LRUCache 类：
LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存
int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。
函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。

 

示例：

输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} capacity
 */</span>
<span>var</span> <span>LRUCache</span> <span>=</span> <span>function</span><span>(</span><span>capacity</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span>capacity <span>=</span> capacity
  <span>this</span><span>.</span>map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span>
<span>}</span><span>;</span>

<span>/** 
 * @param {number} key
 * @return {number}
 */</span>
<span>LRUCache</span><span>.</span>prototype<span>.</span><span>get</span> <span>=</span> <span>function</span><span>(</span><span>key</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span><span>this</span><span>.</span>map<span>.</span><span>has</span><span>(</span>key<span>)</span><span>)</span> <span>return</span> <span>-</span><span>1</span><span>;</span>
  <span>const</span> res <span>=</span> <span>this</span><span>.</span>map<span>.</span><span>get</span><span>(</span>key<span>)</span>
  <span>this</span><span>.</span>map<span>.</span><span>delete</span><span>(</span>key<span>)</span>
  <span>this</span><span>.</span>map<span>.</span><span>set</span><span>(</span>key<span>,</span> res<span>)</span>
  <span>return</span> res
<span>}</span><span>;</span>

<span>/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */</span>
<span>LRUCache</span><span>.</span>prototype<span>.</span><span>put</span> <span>=</span> <span>function</span><span>(</span><span>key<span>,</span> value</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>this</span><span>.</span>map<span>.</span><span>has</span><span>(</span>key<span>)</span><span>)</span> <span>this</span><span>.</span>map<span>.</span><span>delete</span><span>(</span>key<span>)</span><span>;</span>
  <span>this</span><span>.</span>map<span>.</span><span>set</span><span>(</span>key<span>,</span> value<span>)</span>
  <span>if</span> <span>(</span><span>this</span><span>.</span>map<span>.</span>size <span>></span> <span>this</span><span>.</span>capacity<span>)</span> <span>this</span><span>.</span>map<span>.</span><span>delete</span><span>(</span><span>this</span><span>.</span>map<span>.</span><span>keys</span><span>(</span><span>)</span><span>.</span><span>next</span><span>(</span><span>)</span><span>.</span>value<span>)</span><span>;</span>
<span>}</span><span>;</span>

<span>/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br></div></div><h2 id="_155-最小栈"> 155.最小栈</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=155 lang=javascript
 *
 * [155] 最小栈
 * 
 * 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

实现 MinStack 类:

MinStack() 初始化堆栈对象。
void push(int val) 将元素val推入堆栈。
void pop() 删除堆栈顶部的元素。
int top() 获取堆栈顶部的元素。
int getMin() 获取堆栈中的最小元素。
 

示例 1:

输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
 


 */</span>

<span>// @lc code=start</span>
<span>/**
 * initialize your data structure here.
 */</span>
<span>var</span> <span>MinStack</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>stack <span>=</span> <span>[</span><span>]</span>
<span>}</span><span>;</span>

<span>/** 
 * @param {number} val
 * @return {void}
 */</span>
<span>MinStack</span><span>.</span>prototype<span>.</span><span>push</span> <span>=</span> <span>function</span> <span>(</span><span>val</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>stack<span>.</span><span>push</span><span>(</span><span>{</span>
        val<span>,</span>
        <span>min</span><span>:</span> <span>this</span><span>.</span>stack<span>.</span>length <span>===</span> <span>0</span> <span>?</span> val <span>:</span> Math<span>.</span><span>min</span><span>(</span>val<span>,</span> <span>this</span><span>.</span><span>getMin</span><span>(</span><span>)</span><span>)</span>
    <span>}</span><span>)</span>
<span>}</span><span>;</span>

<span>/**
 * @return {void}
 */</span>
<span>MinStack</span><span>.</span>prototype<span>.</span><span>pop</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>stack<span>.</span><span>pop</span><span>(</span><span>)</span>
<span>}</span><span>;</span>

<span>/**
 * @return {number}
 */</span>
<span>MinStack</span><span>.</span>prototype<span>.</span><span>top</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>stack<span>[</span><span>this</span><span>.</span>stack<span>.</span>length <span>-</span> <span>1</span><span>]</span><span>.</span>val
<span>}</span><span>;</span>

<span>/**
 * @return {number}
 */</span>
<span>MinStack</span><span>.</span>prototype<span>.</span><span>getMin</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>stack<span>[</span><span>this</span><span>.</span>stack<span>.</span>length <span>-</span> <span>1</span><span>]</span><span>.</span>min
<span>}</span>
<span>/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(val)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br></div></div><h2 id="_160-相交链表"> 160.相交链表</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=160 lang=javascript
 *
 * [160] 相交链表
 * 
 * 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。

图示两个链表在节点 c1 开始相交：



题目数据 保证 整个链式结构中不存在环。

注意，函数返回结果后，链表必须 保持其原始结构 。

自定义评测：

评测系统 的输入如下（你设计的程序 不适用 此输入）：

intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0
listA - 第一个链表
listB - 第二个链表
skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数
skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数
评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。

 

示例 1：



输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
示例 2：



输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
示例 3：



输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
 


 */</span>

<span>// @lc code=start</span>
<span>/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */</span>

<span>/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */</span>
<span>var</span> <span>getIntersectionNode</span> <span>=</span> <span>function</span> <span>(</span><span>headA<span>,</span> headB</span><span>)</span> <span>{</span>
    <span>let</span> a <span>=</span> headA<span>,</span> b <span>=</span> headB
    <span>while</span> <span>(</span>a <span>!==</span> b<span>)</span> <span>{</span>
        a <span>=</span> <span>!</span>a <span>?</span> headB <span>:</span> a<span>.</span>next
        b <span>=</span> <span>!</span>b <span>?</span> headA <span>:</span> b<span>.</span>next
    <span>}</span>
    <span>return</span> a
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br></div></div><h2 id="_167-两数之和-ii-输入有序数组"> 167.两数之和-ii-输入有序数组</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=167 lang=javascript
 *
 * [167] 两数之和 II - 输入有序数组
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 */</span>
<span>var</span> <span>twoSum</span> <span>=</span> <span>function</span> <span>(</span><span>numbers<span>,</span> target</span><span>)</span> <span>{</span>
    <span>let</span> m <span>=</span> <span>0</span><span>,</span> n <span>=</span> numbers<span>.</span>length <span>-</span> <span>1</span>
    <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>numbers<span>[</span>m<span>]</span> <span>+</span> numbers<span>[</span>n<span>]</span> <span>></span> target<span>)</span> <span>{</span>
            n<span>--</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>numbers<span>[</span>m<span>]</span> <span>+</span> numbers<span>[</span>n<span>]</span> <span>&lt;</span> target<span>)</span> <span>{</span>
            m<span>++</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>return</span> <span>[</span>m <span>+</span> <span>1</span><span>,</span> n <span>+</span> <span>1</span><span>]</span>
        <span>}</span>
    <span>}</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id="_168-excel表列名称"> 168.excel表列名称</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=168 lang=javascript
 *
 * [168] Excel表列名称
 * 
 * 给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。

例如：

A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 
...
 

示例 1：

输入：columnNumber = 1
输出："A"
示例 2：

输入：columnNumber = 28
输出："AB"
示例 3：

输入：columnNumber = 701
输出："ZY"
示例 4：

输入：columnNumber = 2147483647
输出："FXSHRXW"

 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} columnNumber
 * @return {string}
 */</span>
<span>var</span> <span>convertToTitle</span> <span>=</span> <span>function</span> <span>(</span><span>columnNumber</span><span>)</span> <span>{</span>
    <span>const</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>[</span><span>[</span><span>0</span><span>,</span> <span>"Z"</span><span>]</span><span>,</span> <span>[</span><span>1</span><span>,</span> <span>"A"</span><span>]</span><span>,</span> <span>[</span><span>2</span><span>,</span> <span>"B"</span><span>]</span><span>,</span> <span>[</span><span>3</span><span>,</span> <span>"C"</span><span>]</span><span>,</span> <span>[</span><span>4</span><span>,</span> <span>"D"</span><span>]</span><span>,</span> <span>[</span><span>5</span><span>,</span> <span>"E"</span><span>]</span><span>,</span> <span>[</span><span>6</span><span>,</span> <span>"F"</span><span>]</span><span>,</span> <span>[</span><span>7</span><span>,</span> <span>"G"</span><span>]</span><span>,</span> <span>[</span><span>8</span><span>,</span> <span>"H"</span><span>]</span><span>,</span> <span>[</span><span>9</span><span>,</span> <span>"I"</span><span>]</span><span>,</span> <span>[</span><span>10</span><span>,</span> <span>"J"</span><span>]</span><span>,</span> <span>[</span><span>11</span><span>,</span> <span>"K"</span><span>]</span><span>,</span> <span>[</span><span>12</span><span>,</span> <span>"L"</span><span>]</span><span>,</span> <span>[</span><span>13</span><span>,</span> <span>"M"</span><span>]</span><span>,</span> <span>[</span><span>14</span><span>,</span> <span>"N"</span><span>]</span><span>,</span> <span>[</span><span>15</span><span>,</span> <span>"O"</span><span>]</span><span>,</span> <span>[</span><span>16</span><span>,</span> <span>"P"</span><span>]</span><span>,</span> <span>[</span><span>17</span><span>,</span> <span>"Q"</span><span>]</span><span>,</span> <span>[</span><span>18</span><span>,</span> <span>"R"</span><span>]</span><span>,</span> <span>[</span><span>19</span><span>,</span> <span>"S"</span><span>]</span><span>,</span> <span>[</span><span>20</span><span>,</span> <span>"T"</span><span>]</span><span>,</span> <span>[</span><span>21</span><span>,</span> <span>"U"</span><span>]</span><span>,</span> <span>[</span><span>22</span><span>,</span> <span>"V"</span><span>]</span><span>,</span> <span>[</span><span>23</span><span>,</span> <span>"W"</span><span>]</span><span>,</span> <span>[</span><span>24</span><span>,</span> <span>"X"</span><span>]</span><span>,</span> <span>[</span><span>25</span><span>,</span> <span>"Y"</span><span>]</span><span>,</span> <span>[</span><span>26</span><span>,</span> <span>"Z"</span><span>]</span><span>]</span><span>)</span>
    <span>let</span> res <span>=</span> <span>[</span><span>]</span>
    <span>while</span> <span>(</span>columnNumber <span>></span> <span>26</span><span>)</span> <span>{</span>
        res<span>.</span><span>unshift</span><span>(</span>map<span>.</span><span>get</span><span>(</span>columnNumber <span>%</span> <span>26</span><span>)</span><span>)</span>
        columnNumber <span>=</span> Math<span>.</span><span>ceil</span><span>(</span>columnNumber <span>/</span> <span>26</span> <span>-</span> <span>1</span><span>)</span>
    <span>}</span>
    res<span>.</span><span>unshift</span><span>(</span>map<span>.</span><span>get</span><span>(</span>columnNumber<span>)</span><span>)</span>
    <span>return</span> res<span>.</span><span>join</span><span>(</span><span>""</span><span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br></div></div><h2 id="_169-多数元素"> 169.多数元素</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=169 lang=javascript
 *
 * [169] 多数元素
 * 
 * 给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

 

示例 1：

输入：nums = [3,2,3]
输出：3
示例 2：

输入：nums = [2,2,1,1,1,2,2]
输出：2
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number}
 */</span>
<span>var</span> <span>majorityElement</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
    nums<span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a <span>-</span> b<span>)</span>
    <span>return</span> nums<span>.</span>length <span>%</span> <span>2</span> <span>===</span> <span>0</span> <span>?</span> nums<span>[</span>nums<span>.</span>length <span>/</span> <span>2</span><span>]</span> <span>:</span> nums<span>[</span><span>(</span>nums<span>.</span>length <span>-</span> <span>1</span><span>)</span> <span>/</span> <span>2</span><span>]</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><h2 id="_171-excel-表列序号"> 171.excel-表列序号</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=171 lang=javascript
 *
 * [171] Excel 表列序号
 * 
 * 给你一个字符串 columnTitle ，表示 Excel 表格中的列名称。返回 该列名称对应的列序号 。

例如：

A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 
...
 

示例 1:

输入: columnTitle = "A"
输出: 1
示例 2:

输入: columnTitle = "AB"
输出: 28
示例 3:

输入: columnTitle = "ZY"
输出: 701
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} columnTitle
 * @return {number}
 */</span>
<span>var</span> <span>titleToNumber</span> <span>=</span> <span>function</span> <span>(</span><span>columnTitle</span><span>)</span> <span>{</span>
    <span>const</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>[</span><span>[</span><span>"A"</span><span>,</span> <span>1</span><span>]</span><span>,</span> <span>[</span><span>"B"</span><span>,</span> <span>2</span><span>]</span><span>,</span> <span>[</span><span>"C"</span><span>,</span> <span>3</span><span>]</span><span>,</span> <span>[</span><span>"D"</span><span>,</span> <span>4</span><span>]</span><span>,</span> <span>[</span><span>"E"</span><span>,</span> <span>5</span><span>]</span><span>,</span> <span>[</span><span>"F"</span><span>,</span> <span>6</span><span>]</span><span>,</span> <span>[</span><span>"G"</span><span>,</span> <span>7</span><span>]</span><span>,</span> <span>[</span><span>"H"</span><span>,</span> <span>8</span><span>]</span><span>,</span> <span>[</span><span>"I"</span><span>,</span> <span>9</span><span>]</span><span>,</span> <span>[</span><span>"J"</span><span>,</span> <span>10</span><span>]</span><span>,</span> <span>[</span><span>"K"</span><span>,</span> <span>11</span><span>]</span><span>,</span> <span>[</span><span>"L"</span><span>,</span> <span>12</span><span>]</span><span>,</span> <span>[</span><span>"M"</span><span>,</span> <span>13</span><span>]</span><span>,</span> <span>[</span><span>"N"</span><span>,</span> <span>14</span><span>]</span><span>,</span> <span>[</span><span>"O"</span><span>,</span> <span>15</span><span>]</span><span>,</span> <span>[</span><span>"P"</span><span>,</span> <span>16</span><span>]</span><span>,</span> <span>[</span><span>"Q"</span><span>,</span> <span>17</span><span>]</span><span>,</span> <span>[</span><span>"R"</span><span>,</span> <span>18</span><span>]</span><span>,</span> <span>[</span><span>"S"</span><span>,</span> <span>19</span><span>]</span><span>,</span> <span>[</span><span>"T"</span><span>,</span> <span>20</span><span>]</span><span>,</span> <span>[</span><span>"U"</span><span>,</span> <span>21</span><span>]</span><span>,</span> <span>[</span><span>"V"</span><span>,</span> <span>22</span><span>]</span><span>,</span> <span>[</span><span>"W"</span><span>,</span> <span>23</span><span>]</span><span>,</span> <span>[</span><span>"X"</span><span>,</span> <span>24</span><span>]</span><span>,</span> <span>[</span><span>"Y"</span><span>,</span> <span>25</span><span>]</span><span>,</span> <span>[</span><span>"Z"</span><span>,</span> <span>26</span><span>]</span><span>]</span><span>)</span>
    <span>let</span> res <span>=</span> <span>0</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> columnTitle<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        res <span>+=</span> map<span>.</span><span>get</span><span>(</span>columnTitle<span>[</span>columnTitle<span>.</span>length <span>-</span> <span>1</span> <span>-</span> i<span>]</span><span>)</span> <span>*</span> <span>(</span><span>26</span> <span>**</span> i<span>)</span>
    <span>}</span>
    <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><h2 id="_172-阶乘后的零"> 172.阶乘后的零</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=172 lang=javascript
 *
 * [172] 阶乘后的零
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} n
 * @return {number}
 */</span>
<span>var</span> <span>trailingZeroes</span> <span>=</span> <span>function</span> <span>(</span><span>n</span><span>)</span> <span>{</span>
    <span>let</span> numZeroes <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>5</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i <span>*=</span> <span>5</span><span>)</span> <span>{</span>
        numZeroes <span>+=</span> Math<span>.</span><span>floor</span><span>(</span>n <span>/</span> i<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> numZeroes<span>;</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h2 id="_190-颠倒二进制位"> 190.颠倒二进制位</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=190 lang=javascript
 *
 * [190] 颠倒二进制位
 * 
 * 颠倒给定的 32 位无符号整数的二进制位。

提示：

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
 

示例 1：

输入：n = 00000010100101000001111010011100
输出：964176192 (00111001011110000010100101000000)
解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
示例 2：

输入：n = 11111111111111111111111111111101
输出：3221225471 (10111111111111111111111111111111)
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} n - a positive integer
 * @return {number} - a positive integer
 */</span>
<span>var</span> <span>reverseBits</span> <span>=</span> <span>function</span> <span>(</span><span>n</span><span>)</span> <span>{</span>
  n <span>=</span> n<span>.</span><span>toString</span><span>(</span><span>2</span><span>)</span>
  n <span>=</span> <span>"0"</span><span>.</span><span>repeat</span><span>(</span><span>32</span> <span>-</span> n<span>.</span>length<span>)</span> <span>+</span> n
  <span>let</span> res <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>n<span>[</span>i<span>]</span> <span>===</span> <span>"1"</span><span>)</span> res <span>+=</span> Math<span>.</span><span>pow</span><span>(</span><span>2</span><span>,</span> i<span>)</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><h2 id="_191-位-1-的个数"> 191.位-1-的个数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=191 lang=javascript
 *
 * [191] 位1的个数
 * 
 * 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。

 

提示：

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。
 

示例 1：

输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
示例 2：

输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
示例 3：

输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} n - a positive integer
 * @return {number}
 */</span>
<span>var</span> <span>hammingWeight</span> <span>=</span> <span>function</span><span>(</span><span>n</span><span>)</span> <span>{</span>
    <span>let</span> res <span>=</span> <span>0</span>
    n <span>=</span> n<span>.</span><span>toString</span><span>(</span><span>2</span><span>)</span>
    <span>for</span> <span>(</span><span>let</span> index <span>=</span> <span>0</span><span>;</span> index <span>&lt;</span> n<span>.</span>length<span>;</span> index<span>++</span><span>)</span> <span>{</span>
        <span>if</span><span>(</span>n<span>[</span>index<span>]</span><span>===</span><span>"1"</span><span>)</span> res <span>++</span>
    <span>}</span>
    <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><h2 id="_202-快乐数"> 202.快乐数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=202 lang=javascript
 *
 * [202] 快乐数
 * 
 * 编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」 定义为：

对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果这个过程 结果为 1，那么这个数就是快乐数。
如果 n 是 快乐数 就返回 true ；不是，则返回 false 。

 

示例 1：

输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
示例 2：

输入：n = 2
输出：false
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} n
 * @return {boolean}
 */</span>
<span>var</span> <span>isHappy</span> <span>=</span> <span>function</span> <span>(</span><span>n</span><span>)</span> <span>{</span>
    <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>n <span>===</span> <span>1</span> <span>||</span> n <span>===</span> <span>7</span><span>)</span> <span>return</span> <span>true</span>
        <span>if</span> <span>(</span>n <span>&lt;</span> <span>10</span><span>)</span> <span>return</span> <span>false</span>
        n <span>=</span> n<span>.</span><span>toString</span><span>(</span><span>)</span>
        <span>let</span> s <span>=</span> <span>0</span>
        <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            s <span>+=</span> n<span>[</span>i<span>]</span> <span>**</span> <span>2</span>
        <span>}</span>
        n <span>=</span> s
    <span>}</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><h2 id="_203-移除链表元素"> 203.移除链表元素</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=203 lang=javascript
 *
 * [203] 移除链表元素
 * 
 * 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。
 

示例 1：


输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
示例 2：

输入：head = [], val = 1
输出：[]
示例 3：

输入：head = [7,7,7,7], val = 7
输出：[]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */</span>
<span>/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */</span>
<span>var</span> <span>removeElements</span> <span>=</span> <span>function</span> <span>(</span><span>head<span>,</span> val</span><span>)</span> <span>{</span>
    <span>while</span> <span>(</span>head<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>head<span>.</span>val <span>===</span> val<span>)</span> <span>{</span>
            head <span>=</span> head<span>.</span>next
        <span>}</span> <span>else</span> <span>{</span>
            <span>break</span>
        <span>}</span>
    <span>}</span>
    <span>let</span> curr <span>=</span> head
    <span>while</span> <span>(</span>curr <span>&amp;&amp;</span> curr<span>.</span>next<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>curr<span>.</span>next<span>.</span>val <span>===</span> val<span>)</span> curr<span>.</span>next <span>=</span> curr<span>.</span>next<span>.</span>next<span>;</span>
        <span>else</span> curr <span>=</span> curr<span>.</span>next<span>;</span>
    <span>}</span>
    <span>return</span> head
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><h2 id="_204-计数质数"> 204.计数质数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=204 lang=javascript
 *
 * [204] 计数质数
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} n
 * @return {number}
 */</span>

 <span>var</span> <span>countPrimes</span> <span>=</span> <span>function</span><span>(</span><span>n</span><span>)</span> <span>{</span>
    <span>let</span> seen <span>=</span> <span>new</span> <span>Uint8Array</span><span>(</span>n<span>)</span><span>,</span> ans <span>=</span> <span>0</span>
    <span>for</span> <span>(</span><span>let</span> num <span>=</span> <span>2</span><span>;</span> num <span>&lt;</span> n<span>;</span> num<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>seen<span>[</span>num<span>]</span><span>)</span> <span>continue</span>
        ans<span>++</span>
        <span>for</span> <span>(</span><span>let</span> mult <span>=</span> num <span>*</span> num<span>;</span> mult <span>&lt;</span> n<span>;</span> mult <span>+=</span> num<span>)</span>
            seen<span>[</span>mult<span>]</span> <span>=</span> <span>1</span>
    <span>}</span>
    <span>return</span> ans
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h2 id="_205-同构字符串"> 205.同构字符串</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=205 lang=javascript
 *
 * [205] 同构字符串
 * 
 * 给定两个字符串 s 和 t ，判断它们是否是同构的。

如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

 

示例 1:

输入：s = "egg", t = "add"
输出：true
示例 2：

输入：s = "foo", t = "bar"
输出：false
示例 3：

输入：s = "paper", t = "title"
输出：true
 


 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */</span>
 <span>var</span> <span>isIsomorphic</span> <span>=</span> <span>function</span> <span>(</span><span>s<span>,</span> t</span><span>)</span> <span>{</span>
    <span>const</span> mapS <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>,</span> mapT <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span>mapS<span>.</span><span>has</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span> <span>&amp;&amp;</span> <span>!</span>mapT<span>.</span><span>has</span><span>(</span>t<span>[</span>i<span>]</span><span>)</span><span>)</span> <span>{</span>
            mapS<span>.</span><span>set</span><span>(</span>s<span>[</span>i<span>]</span><span>,</span> t<span>[</span>i<span>]</span><span>)</span>
            mapT<span>.</span><span>set</span><span>(</span>t<span>[</span>i<span>]</span><span>,</span> s<span>[</span>i<span>]</span><span>)</span>
            <span>continue</span>
        <span>}</span>
        <span>if</span> <span>(</span>mapS<span>.</span><span>get</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span> <span>!==</span> t<span>[</span>i<span>]</span> <span>||</span> mapT<span>.</span><span>get</span><span>(</span>t<span>[</span>i<span>]</span><span>)</span> <span>!==</span> s<span>[</span>i<span>]</span><span>)</span> <span>return</span> <span>false</span>
    <span>}</span>
    <span>return</span> <span>true</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><h2 id="_206-反转链表"> 206.反转链表</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=206 lang=javascript
 *
 * [206] 反转链表
 * 
 * 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
 

示例 1：


输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
示例 2：


输入：head = [1,2]
输出：[2,1]
示例 3：

输入：head = []
输出：[]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */</span>
<span>/**
 * @param {ListNode} head
 * @return {ListNode}
 */</span>
<span>// var reverseList = function (head) {</span>
<span>//   const res = new ListNode(), stack = []</span>
<span>//   while (head) {</span>
<span>//     stack.unshift(head.val)</span>
<span>//     head = head.next</span>
<span>//   }</span>
<span>//   if (stack.length === 0) return res.next</span>
<span>//   res.next = new ListNode()</span>
<span>//   let node = res.next</span>
<span>//   for (let i = 0; i &lt; stack.length; i++) {</span>
<span>//     node.val = stack[i]</span>
<span>//     if (i &lt; stack.length - 1) node.next = new ListNode()</span>
<span>//     node = node.next</span>
<span>//   }</span>
<span>//   return res.next</span>
<span>// };</span>

<span>var</span> <span>reverseList</span> <span>=</span> <span>function</span> <span>(</span><span>head</span><span>)</span> <span>{</span>
  <span>let</span> prev <span>=</span> <span>null</span><span>,</span> curr <span>=</span> head
  <span>while</span> <span>(</span>curr<span>)</span> <span>{</span>
      <span>const</span> after <span>=</span> curr<span>.</span>next
      curr<span>.</span>next <span>=</span> prev
      prev <span>=</span> curr
      curr <span>=</span> after
  <span>}</span>
  <span>return</span> prev
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br></div></div><h2 id="_217-存在重复元素"> 217.存在重复元素</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=217 lang=javascript
 *
 * [217] 存在重复元素
 * 
 * 给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。
 

示例 1：

输入：nums = [1,2,3,1]
输出：true
示例 2：

输入：nums = [1,2,3,4]
输出：false
示例 3：

输入：nums = [1,1,1,3,3,4,3,2,4,2]
输出：true
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {boolean}
 */</span>
<span>var</span> <span>containsDuplicate</span> <span>=</span> <span>function</span><span>(</span><span>nums</span><span>)</span> <span>{</span>
  <span>return</span> nums<span>.</span>length <span>!==</span> <span>[</span><span>...</span><span>new</span> <span>Set</span><span>(</span>nums<span>)</span><span>]</span><span>.</span>length
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><h2 id="_219-存在重复元素-ii"> 219.存在重复元素-ii</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=219 lang=javascript
 *
 * [219] 存在重复元素 II
 * 
 * 给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) &lt;= k 。如果存在，返回 true ；否则，返回 false 。

 

示例 1：

输入：nums = [1,2,3,1], k = 3
输出：true
示例 2：

输入：nums = [1,0,1,1], k = 1
输出：true
示例 3：

输入：nums = [1,2,3,1,2,3], k = 2
输出：false
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @param {number} k
 * @return {boolean}
 */</span>
<span>var</span> <span>containsNearbyDuplicate</span> <span>=</span> <span>function</span> <span>(</span><span>nums<span>,</span> k</span><span>)</span> <span>{</span>
  <span>const</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>map<span>.</span><span>has</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span> <span>&amp;&amp;</span> i <span>-</span> map<span>.</span><span>get</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span> <span>&lt;=</span> k<span>)</span> <span>return</span> <span>true</span>
    map<span>.</span><span>set</span><span>(</span>nums<span>[</span>i<span>]</span><span>,</span> i<span>)</span>
  <span>}</span>
  <span>return</span> <span>false</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id="_225-用队列实现栈"> 225.用队列实现栈</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=225 lang=javascript
 *
 * [225] 用队列实现栈
 * 
 * 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。

实现 MyStack 类：

void push(int x) 将元素 x 压入栈顶。
int pop() 移除并返回栈顶元素。
int top() 返回栈顶元素。
boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。
 

注意：

你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。
你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
 

示例：

输入：
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 2, 2, false]

解释：
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // 返回 2
myStack.pop(); // 返回 2
myStack.empty(); // 返回 False
 


 */</span>

<span>// @lc code=start</span>

<span>var</span> <span>MyStack</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span>stack <span>=</span> <span>[</span><span>]</span>
<span>}</span><span>;</span>

<span>/** 
 * @param {number} x
 * @return {void}
 */</span>
<span>MyStack</span><span>.</span>prototype<span>.</span><span>push</span> <span>=</span> <span>function</span> <span>(</span><span>x</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span>stack<span>.</span><span>push</span><span>(</span>x<span>)</span>
<span>}</span><span>;</span>

<span>/**
 * @return {number}
 */</span>
<span>MyStack</span><span>.</span>prototype<span>.</span><span>pop</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>this</span><span>.</span>stack<span>.</span><span>pop</span><span>(</span><span>)</span>
<span>}</span><span>;</span>

<span>/**
 * @return {number}
 */</span>
<span>MyStack</span><span>.</span>prototype<span>.</span><span>top</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>this</span><span>.</span>stack<span>[</span><span>this</span><span>.</span>stack<span>.</span>length <span>-</span> <span>1</span><span>]</span>
<span>}</span><span>;</span>

<span>/**
 * @return {boolean}
 */</span>
<span>MyStack</span><span>.</span>prototype<span>.</span><span>empty</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>this</span><span>.</span>stack<span>.</span>length <span>===</span> <span>0</span>
<span>}</span><span>;</span>

<span>/**
 * Your MyStack object will be instantiated and called as such:
 * var obj = new MyStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.empty()
 */</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br></div></div><h2 id="_226-翻转二叉树"> 226.翻转二叉树</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=226 lang=javascript
 *
 * [226] 翻转二叉树
 * 
 * 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。

 

示例 1：



输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
示例 2：



输入：root = [2,1,3]
输出：[2,3,1]
示例 3：

输入：root = []
输出：[]
 


 */</span>

<span>// @lc code=start</span>
<span>/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span>/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */</span>
<span>var</span> <span>invertTree</span> <span>=</span> <span>function</span> <span>(</span><span>root</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>root<span>)</span> <span>return</span> root
  <span>let</span> temp <span>=</span> root<span>.</span>right<span>;</span>
  root<span>.</span>right <span>=</span> root<span>.</span>left<span>;</span>
  root<span>.</span>left <span>=</span> temp<span>;</span>
  <span>invertTree</span><span>(</span>root<span>.</span>left<span>)</span>
  <span>invertTree</span><span>(</span>root<span>.</span>right<span>)</span>
  <span>return</span> root
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><h2 id="_228-汇总区间"> 228.汇总区间</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=228 lang=javascript
 *
 * [228] 汇总区间
 * 
 * 给定一个  无重复元素 的 有序 整数数组 nums 。

返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表 。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。

列表中的每个区间范围 [a,b] 应该按如下格式输出：

"a->b" ，如果 a != b
"a" ，如果 a == b
 

示例 1：

输入：nums = [0,1,2,4,5,7]
输出：["0->2","4->5","7"]
解释：区间范围是：
[0,2] --> "0->2"
[4,5] --> "4->5"
[7,7] --> "7"
示例 2：

输入：nums = [0,2,3,4,6,8,9]
输出：["0","2->4","6","8->9"]
解释：区间范围是：
[0,0] --> "0"
[2,4] --> "2->4"
[6,6] --> "6"
[8,9] --> "8->9"
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {string[]}
 */</span>
<span>var</span> <span>summaryRanges</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>nums<span>.</span>length <span>===</span> <span>0</span><span>)</span> <span>return</span> nums
  <span>let</span> res <span>=</span> <span>[</span><span>]</span><span>,</span> stack <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>stack<span>.</span>length <span>===</span> <span>0</span> <span>||</span> nums<span>[</span>i<span>]</span> <span>-</span> stack<span>[</span>stack<span>.</span>length <span>-</span> <span>1</span><span>]</span> <span>===</span> <span>1</span><span>)</span> <span>{</span>
      stack<span>.</span><span>push</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span>
      <span>continue</span>
    <span>}</span>
    <span>if</span> <span>(</span>stack<span>.</span>length <span>===</span> <span>1</span><span>)</span> <span>{</span>
      res<span>.</span><span>push</span><span>(</span>stack<span>.</span><span>pop</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      res<span>.</span><span>push</span><span>(</span>stack<span>.</span><span>shift</span><span>(</span><span>)</span> <span>+</span> <span>"->"</span> <span>+</span> stack<span>.</span><span>pop</span><span>(</span><span>)</span><span>)</span>
    <span>}</span>
    stack <span>=</span> <span>[</span>nums<span>[</span>i<span>]</span><span>]</span>
  <span>}</span>
  <span>if</span> <span>(</span>stack<span>.</span>length <span>===</span> <span>1</span><span>)</span> <span>{</span>
    res<span>.</span><span>push</span><span>(</span>stack<span>.</span><span>pop</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    res<span>.</span><span>push</span><span>(</span>stack<span>.</span><span>shift</span><span>(</span><span>)</span> <span>+</span> <span>"->"</span> <span>+</span> stack<span>.</span><span>pop</span><span>(</span><span>)</span><span>)</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br></div></div><h2 id="_231-2-的幂"> 231.2-的幂</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=231 lang=javascript
 *
 * [231] 2 的幂
 * 
 * 给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。

如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。

 

示例 1：

输入：n = 1
输出：true
解释：20 = 1
示例 2：

输入：n = 16
输出：true
解释：24 = 16
示例 3：

输入：n = 3
输出：false
示例 4：

输入：n = 4
输出：true
示例 5：

输入：n = 5
输出：false
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} n
 * @return {boolean}
 */</span>
<span>// var isPowerOfTwo = function (n) {</span>
<span>//   if (n === 0) return false</span>
<span>//   while (n !== 1) {</span>
<span>//     if (n % 2 !== 0) return false</span>
<span>//     n /= 2</span>
<span>//   }</span>
<span>//   return true</span>
<span>// };</span>
<span>var</span> <span>isPowerOfTwo</span> <span>=</span> <span>function</span> <span>(</span><span>n</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>n <span>></span> <span>0</span><span>)</span> <span>&amp;&amp;</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>30</span><span>)</span> <span>%</span> n <span>==</span> <span>0</span><span>;</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><h2 id="_232-用栈实现队列"> 232.用栈实现队列</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=232 lang=javascript
 *
 * [232] 用栈实现队列
 * 
 * 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：

实现 MyQueue 类：

void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false
说明：

你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
 

示例 1：

输入：
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]

解释：
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
 


 */</span>

<span>// @lc code=start</span>

<span>var</span> <span>MyQueue</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span>queue <span>=</span> <span>[</span><span>]</span>
<span>}</span><span>;</span>

<span>/** 
 * @param {number} x
 * @return {void}
 */</span>
<span>MyQueue</span><span>.</span>prototype<span>.</span><span>push</span> <span>=</span> <span>function</span><span>(</span><span>x</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span>queue<span>.</span><span>push</span><span>(</span>x<span>)</span>
<span>}</span><span>;</span>

<span>/**
 * @return {number}
 */</span>
<span>MyQueue</span><span>.</span>prototype<span>.</span><span>pop</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>this</span><span>.</span>queue<span>.</span><span>shift</span><span>(</span><span>)</span>
<span>}</span><span>;</span>

<span>/**
 * @return {number}
 */</span>
<span>MyQueue</span><span>.</span>prototype<span>.</span><span>peek</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>this</span><span>.</span>queue<span>[</span><span>0</span><span>]</span>
<span>}</span><span>;</span>

<span>/**
 * @return {boolean}
 */</span>
<span>MyQueue</span><span>.</span>prototype<span>.</span><span>empty</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>this</span><span>.</span>queue<span>.</span>length <span>===</span> <span>0</span>
<span>}</span><span>;</span>

<span>/**
 * Your MyQueue object will be instantiated and called as such:
 * var obj = new MyQueue()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.peek()
 * var param_4 = obj.empty()
 */</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br></div></div><h2 id="_234-回文链表"> 234.回文链表</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=234 lang=javascript
 *
 * [234] 回文链表
 * 
 * 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。

 

示例 1：


输入：head = [1,2,2,1]
输出：true
示例 2：


输入：head = [1,2]
输出：false
 


 */</span>

<span>// @lc code=start</span>
<span>/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */</span>
<span>/**
 * @param {ListNode} head
 * @return {boolean}
 */</span>
<span>var</span> <span>isPalindrome</span> <span>=</span> <span>function</span> <span>(</span><span>head</span><span>)</span> <span>{</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span>
  <span>while</span> <span>(</span>head<span>)</span> <span>{</span>
    res<span>.</span><span>push</span><span>(</span>head<span>.</span>val<span>)</span>
    head <span>=</span> head<span>.</span>next
  <span>}</span>
  <span>return</span> res<span>.</span><span>join</span><span>(</span><span>""</span><span>)</span> <span>===</span> res<span>.</span><span>reverse</span><span>(</span><span>)</span><span>.</span><span>join</span><span>(</span><span>""</span><span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><h2 id="_237-删除链表中的节点"> 237.删除链表中的节点</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=237 lang=javascript
 *
 * [237] 删除链表中的节点
 * 
 * 请编写一个函数，用于 删除单链表中某个特定节点 。在设计函数时需要注意，你无法访问链表的头节点 head ，只能直接访问 要被删除的节点 。

题目数据保证需要删除的节点 不是末尾节点 。

 

示例 1：


输入：head = [4,5,1,9], node = 5
输出：[4,1,9]
解释：指定链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9
示例 2：


输入：head = [4,5,1,9], node = 1
输出：[4,5,9]
解释：指定链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9
 


 */</span>

<span>// @lc code=start</span>
<span>/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */</span>
<span>/**
 * @param {ListNode} node
 * @return {void} Do not return anything, modify node in-place instead.
 */</span>
<span>var</span> <span>deleteNode</span> <span>=</span> <span>function</span><span>(</span><span>node</span><span>)</span> <span>{</span>
  node<span>.</span>val <span>=</span> node<span>.</span>next<span>.</span>val
  node<span>.</span>next <span>=</span> node<span>.</span>next<span>.</span>next
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><h2 id="_242-有效的字母异位词"> 242.有效的字母异位词</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=242 lang=javascript
 *
 * [242] 有效的字母异位词
 * 
 * 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

 

示例 1:

输入: s = "anagram", t = "nagaram"
输出: true
示例 2:

输入: s = "rat", t = "car"
输出: false
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */</span>
<span>var</span> <span>isAnagram</span> <span>=</span> <span>function</span> <span>(</span><span>s<span>,</span> t</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>s<span>.</span>length <span>!==</span> t<span>.</span>length<span>)</span> <span>return</span> <span>false</span>
  <span>const</span> map1 <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>,</span> map2 <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>map1<span>.</span><span>has</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span><span>)</span> map1<span>.</span><span>set</span><span>(</span>s<span>[</span>i<span>]</span><span>,</span> <span>0</span><span>)</span>
    <span>else</span> map1<span>.</span><span>set</span><span>(</span>s<span>[</span>i<span>]</span><span>,</span> map1<span>.</span><span>get</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span> <span>+</span> <span>1</span><span>)</span>
  <span>}</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> t<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>map2<span>.</span><span>has</span><span>(</span>t<span>[</span>i<span>]</span><span>)</span><span>)</span> map2<span>.</span><span>set</span><span>(</span>t<span>[</span>i<span>]</span><span>,</span> <span>0</span><span>)</span>
    <span>else</span> map2<span>.</span><span>set</span><span>(</span>t<span>[</span>i<span>]</span><span>,</span> map2<span>.</span><span>get</span><span>(</span>t<span>[</span>i<span>]</span><span>)</span> <span>+</span> <span>1</span><span>)</span>
  <span>}</span>
  <span>for</span> <span>(</span><span>const</span> <span>[</span>k<span>,</span> v<span>]</span> <span>of</span> map1<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>map2<span>.</span><span>get</span><span>(</span>k<span>)</span> <span>!==</span> v<span>)</span> <span>return</span> <span>false</span>
  <span>}</span>
  <span>return</span> <span>true</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><h2 id="_258-各位相加"> 258.各位相加</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=258 lang=javascript
 *
 * [258] 各位相加
 * 
 * 给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。

 

示例 1:

输入: num = 38
输出: 2 
解释: 各位相加的过程为：
38 --> 3 + 8 --> 11
11 --> 1 + 1 --> 2
由于 2 是一位数，所以返回 2。
示例 1:

输入: num = 0
输出: 0
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} num
 * @return {number}
 */</span>
<span>var</span> <span>addDigits</span> <span>=</span> <span>function</span> <span>(</span><span>num</span><span>)</span> <span>{</span>
  <span>while</span> <span>(</span>num <span>/</span> <span>10</span> <span>>=</span> <span>1</span><span>)</span> <span>{</span>
    <span>const</span> a <span>=</span> num<span>.</span><span>toString</span><span>(</span><span>)</span>
    num <span>=</span> <span>0</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> a<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      num <span>+=</span> <span>Number</span><span>(</span>a<span>[</span>i<span>]</span><span>)</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> num
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h2 id="_263-丑数"> 263.丑数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=263 lang=javascript
 *
 * [263] 丑数
 * 
 * 丑数 就是只包含质因数 2、3 和 5 的正整数。

给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。

 

示例 1：

输入：n = 6
输出：true
解释：6 = 2 × 3
示例 2：

输入：n = 1
输出：true
解释：1 没有质因数，因此它的全部质因数是 {2, 3, 5} 的空集。习惯上将其视作第一个丑数。
示例 3：

输入：n = 14
输出：false
解释：14 不是丑数，因为它包含了另外一个质因数 7 。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} n
 * @return {boolean}
 */</span>
<span>var</span> <span>isUgly</span> <span>=</span> <span>function</span> <span>(</span><span>n</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>n <span>===</span> <span>0</span><span>)</span> <span>return</span> <span>false</span>
  <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>n <span>%</span> <span>2</span> <span>===</span> <span>0</span><span>)</span> n <span>=</span> n <span>/</span> <span>2</span>
    <span>else</span> <span>if</span> <span>(</span>n <span>%</span> <span>3</span> <span>===</span> <span>0</span><span>)</span> n <span>=</span> n <span>/</span> <span>3</span>
    <span>else</span> <span>if</span> <span>(</span>n <span>%</span> <span>5</span> <span>===</span> <span>0</span><span>)</span> n <span>=</span> n <span>/</span> <span>5</span>
    <span>else</span> <span>if</span> <span>(</span>n <span>===</span> <span>1</span><span>)</span> <span>return</span> <span>true</span>
    <span>else</span> <span>return</span> <span>false</span>
  <span>}</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><h2 id="_268-丢失的数字"> 268.丢失的数字</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=268 lang=javascript
 *
 * [268] 丢失的数字
 * 
 * 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。

 

示例 1：

输入：nums = [3,0,1]
输出：2
解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。
示例 2：

输入：nums = [0,1]
输出：2
解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。
示例 3：

输入：nums = [9,6,4,2,3,5,7,0,1]
输出：8
解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。
示例 4：

输入：nums = [0]
输出：1
解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number}
 */</span>
<span>var</span> <span>missingNumber</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;=</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>nums<span>.</span><span>includes</span><span>(</span>i<span>)</span><span>)</span> <span>return</span> i
  <span>}</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><h2 id="_278-第一个错误的版本"> 278.第一个错误的版本</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=278 lang=javascript
 *
 * [278] 第一个错误的版本
 * 
 * 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。

假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。

你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。

 
示例 1：

输入：n = 5, bad = 4
输出：4
解释：
调用 isBadVersion(3) -> false 
调用 isBadVersion(5) -> true 
调用 isBadVersion(4) -> true
所以，4 是第一个错误的版本。
示例 2：

输入：n = 1, bad = 1
输出：1
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * Definition for isBadVersion()
 * 
 * @param {integer} version number
 * @return {boolean} whether the version is bad
 * isBadVersion = function(version) {
 *     ...
 * };
 */</span>

<span>/**
 * @param {function} isBadVersion()
 * @return {function}
 */</span>
<span>var</span> <span>solution</span> <span>=</span> <span>function</span> <span>(</span><span>isBadVersion</span><span>)</span> <span>{</span>
    <span>/**
     * @param {integer} n Total versions
     * @return {integer} The first bad version
     */</span>
    <span>return</span> <span>function</span> <span>(</span><span>n</span><span>)</span> <span>{</span>
        <span>let</span> s <span>=</span> <span>1</span><span>,</span> e <span>=</span> n<span>,</span> c <span>=</span> <span>(</span>s <span>+</span> e<span>)</span> <span>/</span> <span>2</span>
        <span>while</span> <span>(</span>e <span>!==</span> c<span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>!</span><span>isBadVersion</span><span>(</span>c<span>)</span><span>)</span> <span>{</span>
                s <span>=</span> c
            <span>}</span> <span>else</span> <span>{</span>
                e <span>=</span> c
            <span>}</span>
            c <span>=</span> <span>(</span>s <span>+</span> e<span>)</span> <span>/</span> <span>2</span>
        <span>}</span>
        <span>return</span> c
    <span>}</span><span>;</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br></div></div><h2 id="_283-移动零"> 283.移动零</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=283 lang=javascript
 *
 * [283] 移动零
 * 
 * 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

请注意 ，必须在不复制数组的情况下原地对数组进行操作。

 

示例 1:

输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
示例 2:

输入: nums = [0]
输出: [0]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */</span>
<span>var</span> <span>moveZeroes</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
  <span>let</span> len <span>=</span> nums<span>.</span>length
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>===</span> <span>0</span><span>)</span> <span>{</span>
      nums<span>.</span><span>splice</span><span>(</span>i<span>,</span> <span>1</span><span>)</span>
      nums<span>.</span><span>push</span><span>(</span><span>0</span><span>)</span>
      len<span>--</span>
      <span>continue</span>
    <span>}</span>
    i<span>++</span>
  <span>}</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h2 id="_290-单词规律"> 290.单词规律</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=290 lang=javascript
 *
 * [290] 单词规律
 * 
 * 给定一种规律 pattern 和一个字符串 s ，判断 s 是否遵循相同的规律。

这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。

 

示例1:

输入: pattern = "abba", str = "dog cat cat dog"
输出: true
示例 2:

输入:pattern = "abba", str = "dog cat cat fish"
输出: false
示例 3:

输入: pattern = "aaaa", str = "dog cat cat dog"
输出: false
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} pattern
 * @param {string} s
 * @return {boolean}
 */</span>
<span>var</span> <span>wordPattern</span> <span>=</span> <span>function</span> <span>(</span><span>pattern<span>,</span> s</span><span>)</span> <span>{</span>
  s <span>=</span> s<span>.</span><span>split</span><span>(</span><span>" "</span><span>)</span>
  <span>if</span> <span>(</span>pattern<span>.</span>length <span>!==</span> s<span>.</span>length<span>)</span> <span>return</span> <span>false</span>
  <span>const</span> map1 <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>,</span> map2 <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> pattern<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>map1<span>.</span><span>has</span><span>(</span>pattern<span>[</span>i<span>]</span><span>)</span><span>)</span> map1<span>.</span><span>set</span><span>(</span>pattern<span>[</span>i<span>]</span><span>,</span> s<span>[</span>i<span>]</span><span>)</span>
    <span>else</span> <span>{</span>
      <span>if</span> <span>(</span>map1<span>.</span><span>get</span><span>(</span>pattern<span>[</span>i<span>]</span><span>)</span> <span>!==</span> s<span>[</span>i<span>]</span><span>)</span> <span>return</span> <span>false</span>
    <span>}</span>
    <span>if</span> <span>(</span><span>!</span>map2<span>.</span><span>has</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span><span>)</span> map2<span>.</span><span>set</span><span>(</span>s<span>[</span>i<span>]</span><span>,</span> pattern<span>[</span>i<span>]</span><span>)</span>
    <span>else</span> <span>{</span>
      <span>if</span> <span>(</span>map2<span>.</span><span>get</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span> <span>!==</span> pattern<span>[</span>i<span>]</span><span>)</span> <span>return</span> <span>false</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>true</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><h2 id="_292-nim-游戏"> 292.nim-游戏</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=292 lang=javascript
 *
 * [292] Nim 游戏
 * 
 * 你和你的朋友，两个人一起玩 Nim 游戏：

桌子上有一堆石头。
你们轮流进行自己的回合， 你作为先手 。
每一回合，轮到的人拿掉 1 - 3 块石头。
拿掉最后一块石头的人就是获胜者。
假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。

 

示例 1：

输入：n = 4
输出：false 
解释：以下是可能的结果:
1. 移除1颗石头。你的朋友移走了3块石头，包括最后一块。你的朋友赢了。
2. 移除2个石子。你的朋友移走2块石头，包括最后一块。你的朋友赢了。
3.你移走3颗石子。你的朋友移走了最后一块石头。你的朋友赢了。
在所有结果中，你的朋友是赢家。
示例 2：

输入：n = 1
输出：true
示例 3：

输入：n = 2
输出：true
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} n
 * @return {boolean}
 */</span>
<span>var</span> <span>canWinNim</span> <span>=</span> <span>function</span> <span>(</span><span>n</span><span>)</span> <span>{</span>
  <span>return</span> n <span>%</span> <span>4</span> <span>!==</span> <span>0</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h2 id="_303-区域和检索-数组不可变"> 303.区域和检索-数组不可变</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=303 lang=javascript
 *
 * [303] 区域和检索 - 数组不可变
 * 
 * 给定一个整数数组  nums，处理以下类型的多个查询:

计算索引 left 和 right （包含 left 和 right）之间的 nums 元素的 和 ，其中 left &lt;= right
实现 NumArray 类：

NumArray(int[] nums) 使用数组 nums 初始化对象
int sumRange(int i, int j) 返回数组 nums 中索引 left 和 right 之间的元素的 总和 ，包含 left 和 right 两点（也就是 nums[left] + nums[left + 1] + ... + nums[right] )
 

示例 1：

输入：
["NumArray", "sumRange", "sumRange", "sumRange"]
[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
输出：
[null, 1, -1, -3]

解释：
NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)
numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) 
numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 */</span>
<span>var</span> <span>NumArray</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span>arr <span>=</span> <span>[</span>nums<span>[</span><span>0</span><span>]</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>arr<span>.</span><span>push</span><span>(</span><span>this</span><span>.</span>arr<span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>+</span> nums<span>[</span>i<span>]</span><span>)</span>
  <span>}</span>
<span>}</span><span>;</span>

<span>/** 
 * @param {number} left 
 * @param {number} right
 * @return {number}
 */</span>
<span>NumArray</span><span>.</span>prototype<span>.</span><span>sumRange</span> <span>=</span> <span>function</span> <span>(</span><span>left<span>,</span> right</span><span>)</span> <span>{</span>
  <span>return</span> <span>this</span><span>.</span>arr<span>[</span>right<span>]</span> <span>-</span> <span>(</span><span>this</span><span>.</span>arr<span>[</span>left <span>-</span> <span>1</span><span>]</span> <span>||</span> <span>0</span><span>)</span>
<span>}</span><span>;</span>

<span>/**
 * Your NumArray object will be instantiated and called as such:
 * var obj = new NumArray(nums)
 * var param_1 = obj.sumRange(left,right)
 */</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div><h2 id="_326-3-的幂"> 326.3-的幂</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=326 lang=javascript
 *
 * [326] 3 的幂
 * 
 * 给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。

整数 n 是 3 的幂次方需满足：存在整数 x 使得 n == 3x

 

示例 1：

输入：n = 27
输出：true
示例 2：

输入：n = 0
输出：false
示例 3：

输入：n = 9
输出：true
示例 4：

输入：n = 45
输出：false
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} n
 * @return {boolean}
 */</span>
<span>var</span> <span>isPowerOfThree</span> <span>=</span> <span>function</span> <span>(</span><span>n</span><span>)</span> <span>{</span>
  <span>return</span> <span><span>/</span><span>^10*$</span><span>/</span></span><span>.</span><span>test</span><span>(</span>n<span>.</span><span>toString</span><span>(</span><span>3</span><span>)</span><span>)</span><span>;</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id="_338-比特位计数"> 338.比特位计数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=338 lang=javascript
 *
 * [338] 比特位计数
 * 
 * 给你一个整数 n ，对于 0 &lt;= i &lt;= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。

 

示例 1：

输入：n = 2
输出：[0,1,1]
解释：
0 --> 0
1 --> 1
2 --> 10
示例 2：

输入：n = 5
输出：[0,1,1,2,1,2]
解释：
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} n
 * @return {number[]}
 */</span>
<span>var</span> <span>countBits</span> <span>=</span> <span>function</span> <span>(</span><span>n</span><span>)</span> <span>{</span>
  <span>return</span> <span>new</span> <span>Array</span><span>(</span>n <span>+</span> <span>1</span><span>)</span><span>.</span><span>fill</span><span>(</span><span>0</span><span>)</span><span>.</span><span>map</span><span>(</span><span>(</span><span>item<span>,</span> index</span><span>)</span> <span>=></span> <span>{</span>
    <span>const</span> num <span>=</span> index<span>.</span><span>toString</span><span>(</span><span>2</span><span>)</span>
    <span>let</span> count <span>=</span> item
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> num<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>num<span>[</span>i<span>]</span> <span>===</span> <span>"1"</span><span>)</span> count<span>++</span>
    <span>}</span>
    <span>return</span> count
  <span>}</span><span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><h2 id="_342-4-的幂"> 342.4-的幂</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=342 lang=javascript
 *
 * [342] 4的幂
 * 
 * 给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。

整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4x

 

示例 1：

输入：n = 16
输出：true
示例 2：

输入：n = 5
输出：false
示例 3：

输入：n = 1
输出：true
 


 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} n
 * @return {boolean}
 */</span>
<span>var</span> <span>isPowerOfFour</span> <span>=</span> <span>function</span> <span>(</span><span>n</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>n <span>&lt;</span> <span>1</span><span>)</span> <span>return</span> <span>false</span>
  <span>while</span> <span>(</span>n <span>!==</span> <span>1</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>n <span>%</span> <span>4</span> <span>!==</span> <span>0</span><span>)</span> <span>return</span> <span>false</span>
    n <span>/=</span> <span>4</span>
  <span>}</span>
  <span>return</span> <span>true</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h2 id="_344-反转字符串"> 344.反转字符串</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=344 lang=javascript
 *
 * [344] 反转字符串
 * 
 * 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

 

示例 1：

输入：s = ["h","e","l","l","o"]
输出：["o","l","l","e","h"]
示例 2：

输入：s = ["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */</span>
<span>var</span> <span>reverseString</span> <span>=</span> <span>function</span> <span>(</span><span>s</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span>length <span>/</span> <span>2</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>[</span>s<span>[</span>i<span>]</span><span>,</span> s<span>[</span>s<span>.</span>length <span>-</span> i <span>-</span> <span>1</span><span>]</span><span>]</span> <span>=</span> <span>[</span>s<span>[</span>s<span>.</span>length <span>-</span> i <span>-</span> <span>1</span><span>]</span><span>,</span> s<span>[</span>i<span>]</span><span>]</span>
  <span>}</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><h2 id="_345-反转字符串中的元音字母"> 345.反转字符串中的元音字母</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=345 lang=javascript
 *
 * [345] 反转字符串中的元音字母
 * 
 * 给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。

元音字母包括 'a'、'e'、'i'、'o'、'u'，且可能以大小写两种形式出现。

 

示例 1：

输入：s = "hello"
输出："holle"
示例 2：

输入：s = "leetcode"
输出："leotcede"
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @return {string}
 */</span>
<span>var</span> <span>reverseVowels</span> <span>=</span> <span>function</span> <span>(</span><span>s</span><span>)</span> <span>{</span>
  s <span>=</span> s<span>.</span><span>split</span><span>(</span><span>""</span><span>)</span>
  <span>const</span> set <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>[</span><span>"a"</span><span>,</span> <span>"A"</span><span>,</span> <span>"e"</span><span>,</span> <span>"E"</span><span>,</span> <span>"i"</span><span>,</span> <span>"I"</span><span>,</span> <span>"o"</span><span>,</span> <span>"O"</span><span>,</span> <span>"u"</span><span>,</span> <span>"U"</span><span>]</span><span>)</span>
  <span>let</span> l <span>=</span> <span>0</span><span>,</span> r <span>=</span> s<span>.</span>length <span>-</span> <span>1</span>
  <span>while</span> <span>(</span>l <span>&lt;</span> r<span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>set<span>.</span><span>has</span><span>(</span>s<span>[</span>l<span>]</span><span>)</span><span>)</span> l<span>++</span>
    <span>if</span> <span>(</span><span>!</span>set<span>.</span><span>has</span><span>(</span>s<span>[</span>r<span>]</span><span>)</span><span>)</span> r<span>--</span>
    <span>if</span> <span>(</span>set<span>.</span><span>has</span><span>(</span>s<span>[</span>l<span>]</span><span>)</span> <span>&amp;&amp;</span> set<span>.</span><span>has</span><span>(</span>s<span>[</span>r<span>]</span><span>)</span><span>)</span> <span>{</span>
      <span>[</span>s<span>[</span>l<span>]</span><span>,</span> s<span>[</span>r<span>]</span><span>]</span> <span>=</span> <span>[</span>s<span>[</span>r<span>]</span><span>,</span> s<span>[</span>l<span>]</span><span>]</span>
      l<span>++</span>
      r<span>--</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> s<span>.</span><span>join</span><span>(</span><span>""</span><span>)</span>
<span>}</span><span>;</span>

<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h2 id="_349-两个数组的交集"> 349.两个数组的交集</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=349 lang=javascript
 *
 * [349] 两个数组的交集
 * 
 * 给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。

 

示例 1：

输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
示例 2：

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的
 


 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */</span>
<span>var</span> <span>intersection</span> <span>=</span> <span>function</span> <span>(</span><span>nums1<span>,</span> nums2</span><span>)</span> <span>{</span>
  <span>const</span> set1 <span>=</span> <span>new</span> <span>Set</span><span>(</span>nums1<span>)</span><span>,</span> set2 <span>=</span> <span>new</span> <span>Set</span><span>(</span>nums2<span>)</span><span>,</span>res <span>=</span> <span>[</span><span>]</span>
  <span>let</span> min<span>,</span> max
  <span>if</span> <span>(</span>set1<span>.</span>size <span>&lt;</span> set2<span>.</span>size<span>)</span> <span>{</span>
    min <span>=</span> set1
    max <span>=</span> set2
  <span>}</span> <span>else</span> <span>{</span>
    min <span>=</span> set2
    max <span>=</span> set1
  <span>}</span>
  <span>for</span> <span>(</span><span>const</span> v <span>of</span> min<span>)</span> <span>{</span>
    <span>if</span><span>(</span>max<span>.</span><span>has</span><span>(</span>v<span>)</span><span>)</span> res<span>.</span><span>push</span><span>(</span>v<span>)</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><h2 id="_350-两个数组的交集-ii"> 350.两个数组的交集-ii</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=350 lang=javascript
 *
 * [350] 两个数组的交集 II
 * 
 * 给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。

 

示例 1：

输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
示例 2:

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */</span>
<span>var</span> <span>intersect</span> <span>=</span> <span>function</span> <span>(</span><span>nums1<span>,</span> nums2</span><span>)</span> <span>{</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span><span>;</span>
  <span>[</span>nums1<span>,</span> nums2<span>]</span> <span>=</span> nums1<span>.</span>length <span>&lt;</span> nums2<span>.</span>length <span>?</span> <span>[</span>nums1<span>,</span> nums2<span>]</span> <span>:</span> <span>[</span>nums2<span>,</span> nums1<span>]</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums1<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> index <span>=</span> nums2<span>.</span><span>indexOf</span><span>(</span>nums1<span>[</span>i<span>]</span><span>)</span>
    <span>if</span> <span>(</span>index <span>></span> <span>-</span><span>1</span><span>)</span> <span>{</span>
      res<span>.</span><span>push</span><span>(</span>nums1<span>[</span>i<span>]</span><span>)</span>
      nums2<span>.</span><span>splice</span><span>(</span>index<span>,</span> <span>1</span><span>)</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id="_367-有效的完全平方数"> 367.有效的完全平方数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=367 lang=javascript
 *
 * [367] 有效的完全平方数
 * 
 * 给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。

进阶：不要 使用任何内置的库函数，如  sqrt 。

 

示例 1：

输入：num = 16
输出：true
示例 2：

输入：num = 14
输出：false
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} num
 * @return {boolean}
 */</span>
<span>var</span> <span>isPerfectSquare</span> <span>=</span> <span>function</span> <span>(</span><span>num</span><span>)</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>1</span>
  <span>while</span> <span>(</span>res <span>*</span> res <span>&lt;=</span> num<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>res <span>*</span> res <span>===</span> num<span>)</span> <span>return</span> <span>true</span>
    res<span>++</span>
  <span>}</span>
  <span>return</span> <span>false</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><h2 id="_374-猜数字大小"> 374.猜数字大小</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=374 lang=javascript
 *
 * [374] 猜数字大小
 * 
 * 猜数字游戏的规则如下：

每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。
如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。
你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：

-1：我选出的数字比你猜的数字小 pick &lt; num
1：我选出的数字比你猜的数字大 pick > num
0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num
返回我选出的数字。

 

示例 1：

输入：n = 10, pick = 6
输出：6
示例 2：

输入：n = 1, pick = 1
输出：1
示例 3：

输入：n = 2, pick = 1
输出：1
示例 4：

输入：n = 2, pick = 2
输出：2

 */</span>

<span>// @lc code=start</span>
<span>/** 
 * Forward declaration of guess API.
 * @param {number} num   your guess
 * @return 	            -1 if num is lower than the guess number
 *			             1 if num is higher than the guess number
 *                       otherwise return 0
 * var guess = function(num) {}
 */</span>

<span>/**
 * @param {number} n
 * @return {number}
 */</span>
<span>var</span> <span>guessNumber</span> <span>=</span> <span>function</span> <span>(</span><span>n</span><span>)</span> <span>{</span>
  <span>let</span> s <span>=</span> <span>0</span><span>,</span> c
  <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
    c <span>=</span> <span>(</span>s <span>+</span> n<span>)</span> <span>/</span> <span>2</span>
    <span>const</span> g <span>=</span> <span>guess</span><span>(</span>c<span>)</span>
    <span>if</span> <span>(</span>g <span>===</span> <span>0</span><span>)</span> <span>{</span>
      <span>return</span> c
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>g <span>===</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
      s <span>=</span> c
    <span>}</span> <span>else</span> <span>{</span>
      n <span>=</span> c
    <span>}</span>
  <span>}</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br></div></div><h2 id="_383-赎金信"> 383.赎金信</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=383 lang=javascript
 *
 * [383] 赎金信
 * 
 * 给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。

如果可以，返回 true ；否则返回 false 。

magazine 中的每个字符只能在 ransomNote 中使用一次。

 

示例 1：

输入：ransomNote = "a", magazine = "b"
输出：false
示例 2：

输入：ransomNote = "aa", magazine = "ab"
输出：false
示例 3：

输入：ransomNote = "aa", magazine = "aab"
输出：true
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} ransomNote
 * @param {string} magazine
 * @return {boolean}
 */</span>
<span>var</span> <span>canConstruct</span> <span>=</span> <span>function</span> <span>(</span><span>ransomNote<span>,</span> magazine</span><span>)</span> <span>{</span>
  <span>const</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> magazine<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>map<span>.</span><span>has</span><span>(</span>magazine<span>[</span>i<span>]</span><span>)</span><span>)</span> map<span>.</span><span>set</span><span>(</span>magazine<span>[</span>i<span>]</span><span>,</span> <span>1</span><span>)</span>
    <span>else</span> map<span>.</span><span>set</span><span>(</span>magazine<span>[</span>i<span>]</span><span>,</span> map<span>.</span><span>get</span><span>(</span>magazine<span>[</span>i<span>]</span><span>)</span> <span>+</span> <span>1</span><span>)</span>
  <span>}</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> ransomNote<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>map<span>.</span><span>get</span><span>(</span>ransomNote<span>[</span>i<span>]</span><span>)</span><span>)</span> <span>return</span> <span>false</span>
    <span>else</span> map<span>.</span><span>set</span><span>(</span>ransomNote<span>[</span>i<span>]</span><span>,</span> map<span>.</span><span>get</span><span>(</span>ransomNote<span>[</span>i<span>]</span><span>)</span> <span>-</span> <span>1</span><span>)</span>
  <span>}</span>
  <span>return</span> <span>true</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><h2 id="_387-字符串中的第一个唯一字符"> 387.字符串中的第一个唯一字符</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=387 lang=javascript
 *
 * [387] 字符串中的第一个唯一字符
 * 
 * 给定一个字符串 s ，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1 。

 

示例 1：

输入: s = "leetcode"
输出: 0
示例 2:

输入: s = "loveleetcode"
输出: 2
示例 3:

输入: s = "aabb"
输出: -1
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @return {number}
 */</span>
<span>var</span> <span>firstUniqChar</span> <span>=</span> <span>function</span> <span>(</span><span>s</span><span>)</span> <span>{</span>
  <span>const</span> arr <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>s<span>.</span><span>lastIndexOf</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span> <span>===</span> i <span>&amp;&amp;</span> <span>!</span>arr<span>.</span><span>includes</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span><span>)</span> <span>return</span> i
    arr<span>.</span><span>push</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span>
  <span>}</span>
  <span>return</span> <span>-</span><span>1</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><h2 id="_389-找不同"> 389.找不同</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=389 lang=javascript
 *
 * [389] 找不同
 * 
 * 给定两个字符串 s 和 t ，它们只包含小写字母。

字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。

请找出在 t 中被添加的字母。

 

示例 1：

输入：s = "abcd", t = "abcde"
输出："e"
解释：'e' 是那个被添加的字母。
示例 2：

输入：s = "", t = "y"
输出："y"
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @param {string} t
 * @return {character}
 */</span>
<span>var</span> <span>findTheDifference</span> <span>=</span> <span>function</span> <span>(</span><span>s<span>,</span> t</span><span>)</span> <span>{</span>
  <span>while</span> <span>(</span>s<span>.</span>length <span>></span> <span>0</span><span>)</span> <span>{</span>
    t <span>=</span> t<span>.</span><span>replace</span><span>(</span>s<span>[</span><span>0</span><span>]</span><span>,</span> <span>""</span><span>)</span>
    s <span>=</span> s<span>.</span><span>replace</span><span>(</span>s<span>[</span><span>0</span><span>]</span><span>,</span> <span>""</span><span>)</span>
  <span>}</span>
  <span>return</span> t<span>[</span><span>0</span><span>]</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id="_392-判断子序列"> 392.判断子序列</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=392 lang=javascript
 *
 * [392] 判断子序列
 * 
 * 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

进阶：

如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

致谢：

特别感谢 @pbrother 添加此问题并且创建所有测试用例。

 

示例 1：

输入：s = "abc", t = "ahbgdc"
输出：true
示例 2：

输入：s = "axc", t = "ahbgdc"
输出：false
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */</span>
<span>var</span> <span>isSubsequence</span> <span>=</span> <span>function</span> <span>(</span><span>s<span>,</span> t</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>s<span>.</span>length <span>===</span> <span>0</span><span>)</span> <span>return</span> <span>true</span>
  <span>let</span> index <span>=</span> <span>0</span>
  <span>while</span> <span>(</span>index <span>&lt;</span> t<span>.</span>length<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>t<span>.</span><span>substr</span><span>(</span><span>0</span><span>,</span> s<span>.</span>length<span>)</span> <span>===</span> s<span>)</span> <span>return</span> <span>true</span>
    <span>if</span> <span>(</span>s<span>[</span>index<span>]</span> <span>===</span> t<span>[</span>index<span>]</span><span>)</span> <span>{</span>
      index<span>++</span>
      <span>continue</span>
    <span>}</span>
    t <span>=</span> t<span>.</span><span>replace</span><span>(</span>t<span>[</span>index<span>]</span><span>,</span> <span>""</span><span>)</span>
  <span>}</span>
  <span>return</span> <span>false</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><h2 id="_401-二进制手表"> 401.二进制手表</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=401 lang=typescript
 *
 * [401] 二进制手表
 * 
 * 二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。

例如，下面的二进制手表读取 "3:25" 。


（图源：WikiMedia - Binary clock samui moon.jpg ，许可协议：Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) ）

给你一个整数 turnedOn ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 按任意顺序 返回答案。

小时不会以零开头：

例如，"01:00" 是无效的时间，正确的写法应该是 "1:00" 。
分钟必须由两位数组成，可能会以零开头：

例如，"10:2" 是无效的时间，正确的写法应该是 "10:02" 。
 

示例 1：

输入：turnedOn = 1
输出：["0:01","0:02","0:04","0:08","0:16","0:32","1:00","2:00","4:00","8:00"]
示例 2：

输入：turnedOn = 9
输出：[]
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>readBinaryWatch</span><span>(</span>turnedOn<span>:</span> <span>number</span><span>)</span><span>:</span> <span>string</span><span>[</span><span>]</span> <span>{</span>
  <span>const</span> res<span>:</span> <span>string</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>12</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> <span>60</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>
      <span>const</span> hour <span>=</span> i<span>.</span><span>toString</span><span>(</span><span>2</span><span>)</span><span>.</span><span>match</span><span>(</span><span><span>/</span><span>1</span><span>/</span><span>g</span></span><span>)</span><span>,</span> second <span>=</span> j<span>.</span><span>toString</span><span>(</span><span>2</span><span>)</span><span>.</span><span>match</span><span>(</span><span><span>/</span><span>1</span><span>/</span><span>g</span></span><span>)</span><span>,</span> hourNum <span>=</span> hour <span>?</span> hour<span>.</span>length <span>:</span> <span>0</span><span>,</span> secondNum <span>=</span> second <span>?</span> second<span>.</span>length <span>:</span> <span>0</span>
      <span>if</span> <span>(</span>hourNum <span>+</span> secondNum <span>===</span> turnedOn<span>)</span> <span>{</span>
        res<span>.</span><span>push</span><span>(</span><span><span>`</span><span><span>${</span>i<span>}</span></span><span>:</span><span><span>${</span>j <span>&lt;</span> <span>10</span> <span>?</span> <span>'0'</span> <span>+</span> j <span>:</span> j<span>}</span></span><span>`</span></span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><h2 id="_404-左叶子之和"> 404.左叶子之和</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=404 lang=typescript
 *
 * [404] 左叶子之和
 * 
 * 给定二叉树的根节点 root ，返回所有左叶子之和。

 

示例 1：



输入: root = [3,9,20,null,null,15,7] 
输出: 24 
解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
示例 2:

输入: root = [1]
输出: 0
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */</span>
<span>function</span> <span>sumOfLeftLeaves</span><span>(</span>root<span>:</span> TreeNode <span>|</span> <span>null</span><span>,</span> isLeftNode <span>=</span> <span>false</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>root<span>)</span> <span>return</span> <span>0</span><span>;</span>
  <span>if</span> <span>(</span>isLeftNode <span>&amp;&amp;</span> <span>!</span>root<span>.</span>left <span>&amp;&amp;</span> <span>!</span>root<span>.</span>right<span>)</span> <span>return</span> root<span>.</span>val<span>;</span>
  <span>return</span> <span>sumOfLeftLeaves</span><span>(</span>root<span>.</span>left<span>,</span> <span>true</span><span>)</span> <span>+</span> <span>sumOfLeftLeaves</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>
<span>}</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><h2 id="_405-数字转换为十六进制数"> 405.数字转换为十六进制数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=405 lang=typescript
 *
 * [405] 数字转换为十六进制数
 * 
 * 给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。

注意:

十六进制中所有字母(a-f)都必须是小写。
十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符'0'来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 
给定的数确保在32位有符号整数范围内。
不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。
示例 1：

输入:
26

输出:
"1a"
示例 2：

输入:
-1

输出:
"ffffffff"

 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>toHex</span><span>(</span>num<span>:</span> <span>number</span><span>)</span><span>:</span> <span>string</span> <span>{</span>
  <span>if</span> <span>(</span>num <span>&lt;</span> <span>0</span><span>)</span> num <span>+=</span> <span>2</span> <span>**</span> <span>32</span>
  <span>return</span> <span>get16</span><span>(</span>num<span>)</span>
<span>}</span><span>;</span>

<span>function</span> <span>get16</span><span>(</span>num<span>:</span> <span>number</span><span>)</span><span>:</span> <span>string</span> <span>{</span>
  <span>if</span> <span>(</span>num <span>===</span> <span>0</span><span>)</span> <span>return</span> <span>"0"</span><span>;</span>
  <span>const</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>[</span><span>[</span><span>10</span><span>,</span> <span>"a"</span><span>]</span><span>,</span> <span>[</span><span>11</span><span>,</span> <span>"b"</span><span>]</span><span>,</span> <span>[</span><span>12</span><span>,</span> <span>"c"</span><span>]</span><span>,</span> <span>[</span><span>13</span><span>,</span> <span>"d"</span><span>]</span><span>,</span> <span>[</span><span>14</span><span>,</span> <span>"e"</span><span>]</span><span>,</span> <span>[</span><span>15</span><span>,</span> <span>"f"</span><span>]</span><span>]</span><span>)</span>
  <span>let</span> res <span>=</span> <span>""</span>
  <span>while</span> <span>(</span>num <span>></span> <span>0</span><span>)</span> <span>{</span>
    <span>const</span> a <span>=</span> num <span>%</span> <span>16</span>
    num <span>=</span> Math<span>.</span><span>floor</span><span>(</span>num <span>/</span> <span>16</span><span>)</span><span>;</span>
    res <span>=</span> <span>(</span>map<span>.</span><span>has</span><span>(</span>a<span>)</span> <span>?</span> map<span>.</span><span>get</span><span>(</span>a<span>)</span> <span>:</span> a<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span> <span>+</span> res
  <span>}</span>
  <span>return</span> res
<span>}</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><h2 id="_409-最长回文串"> 409.最长回文串</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=409 lang=javascript
 *
 * [409] 最长回文串
 * 
 * 给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的 最长的回文串 。

在构造过程中，请注意 区分大小写 。比如 "Aa" 不能当做一个回文字符串。

 

示例 1:

输入:s = "abccccdd"
输出:7
解释:
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
示例 2:

输入:s = "a"
输入:1
示例 3:

输入:s = "bb"
输入: 2
 


 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @return {number}
 */</span>
 <span>var</span> <span>longestPalindrome</span> <span>=</span> <span>function</span><span>(</span><span>s</span><span>)</span> <span>{</span>
  <span>const</span> set <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>)</span><span>;</span>
  <span>let</span> count <span>=</span> <span>0</span><span>;</span>
  <span>for</span><span>(</span><span>let</span> i<span>=</span><span>0</span><span>;</span> i<span>&lt;</span>s<span>.</span>length<span>;</span> i<span>++</span><span>)</span><span>{</span>
      <span>if</span><span>(</span>set<span>.</span><span>has</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span><span>)</span><span>{</span>
          count <span>+=</span><span>2</span><span>;</span>
          set<span>.</span><span>delete</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span>
      <span>}</span><span>else</span><span>{</span>
          set<span>.</span><span>add</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span>
      <span>}</span>
  <span>}</span>
  <span>return</span> set<span>.</span>size<span>></span><span>0</span> <span>?</span> count<span>+</span><span>1</span> <span>:</span> count<span>;</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><h2 id="_412-fizz-buzz"> 412.fizz-buzz</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=412 lang=javascript
 *
 * [412] Fizz Buzz
 * 
 * 给你一个整数 n ，找出从 1 到 n 各个整数的 Fizz Buzz 表示，并用字符串数组 answer（下标从 1 开始）返回结果，其中：

answer[i] == "FizzBuzz" 如果 i 同时是 3 和 5 的倍数。
answer[i] == "Fizz" 如果 i 是 3 的倍数。
answer[i] == "Buzz" 如果 i 是 5 的倍数。
answer[i] == i （以字符串形式）如果上述条件全不满足。
 

示例 1：

输入：n = 3
输出：["1","2","Fizz"]
示例 2：

输入：n = 5
输出：["1","2","Fizz","4","Buzz"]
示例 3：

输入：n = 15
输出：["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14","FizzBuzz"]
 


 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} n
 * @return {string[]}
 */</span>
<span>var</span> <span>fizzBuzz</span> <span>=</span> <span>function</span> <span>(</span><span>n</span><span>)</span> <span>{</span>
  <span>let</span> arr <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>let</span> num
    <span>if</span> <span>(</span>i <span>%</span> <span>3</span> <span>===</span> <span>0</span> <span>&amp;&amp;</span> i <span>%</span> <span>5</span> <span>===</span> <span>0</span><span>)</span> <span>{</span>
      num <span>=</span> <span>'FizzBuzz'</span><span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>i <span>%</span> <span>3</span> <span>===</span> <span>0</span><span>)</span> <span>{</span>
      num <span>=</span> <span>'Fizz'</span><span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>i <span>%</span> <span>5</span> <span>===</span> <span>0</span><span>)</span> <span>{</span>
      num <span>=</span> <span>"Buzz"</span>
    <span>}</span> <span>else</span> <span>{</span>
      num <span>=</span> i<span>.</span><span>toString</span><span>(</span><span>)</span>
    <span>}</span>
    arr<span>.</span><span>push</span><span>(</span>num<span>)</span>
  <span>}</span>
  <span>return</span> arr
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><h2 id="_414-第三大的数"> 414.第三大的数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=414 lang=javascript
 *
 * [414] 第三大的数
 * 
 * 给你一个非空数组，返回此数组中 第三大的数 。如果不存在，则返回数组中最大的数。

 

示例 1：

输入：[3, 2, 1]
输出：1
解释：第三大的数是 1 。
示例 2：

输入：[1, 2]
输出：2
解释：第三大的数不存在, 所以返回最大的数 2 。
示例 3：

输入：[2, 2, 3, 1]
输出：1
解释：注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。
此例中存在两个值为 2 的数，它们都排第二。在所有不同数字中排第三大的数为 1 。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number}
 */</span>
<span>var</span> <span>thirdMax</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
  <span>const</span> arr <span>=</span> <span>[</span><span>...</span><span>new</span> <span>Set</span><span>(</span>nums<span>)</span><span>]</span><span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> b <span>-</span> a<span>)</span>
  <span>return</span> arr<span>.</span>length <span>></span> <span>2</span> <span>?</span> arr<span>[</span><span>2</span><span>]</span> <span>:</span> arr<span>[</span><span>0</span><span>]</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><h2 id="_415-字符串相加"> 415.字符串相加</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=415 lang=javascript
 *
 * [415] 字符串相加
 * 
 * 给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。

你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。

 

示例 1：

输入：num1 = "11", num2 = "123"
输出："134"
示例 2：

输入：num1 = "456", num2 = "77"
输出："533"
示例 3：

输入：num1 = "0", num2 = "0"
输出："0"
 


 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */</span>
<span>var</span> <span>addStrings</span> <span>=</span> <span>function</span> <span>(</span><span>num1<span>,</span> num2</span><span>)</span> <span>{</span>
  <span>const</span> len <span>=</span> Math<span>.</span><span>max</span><span>(</span>num1<span>.</span>length<span>,</span> num2<span>.</span>length<span>)</span><span>,</span>
    len1 <span>=</span> num1<span>.</span>length<span>,</span>
    len2 <span>=</span> num2<span>.</span>length<span>;</span>
  <span>let</span> res <span>=</span> <span>''</span><span>,</span>
    flag <span>=</span> <span>0</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>let</span> n <span>=</span>
      <span>(</span><span>Number</span><span>(</span>num1<span>[</span>len1 <span>-</span> i<span>]</span><span>)</span> <span>||</span> <span>0</span><span>)</span> <span>+</span> <span>(</span><span>Number</span><span>(</span>num2<span>[</span>len2 <span>-</span> i<span>]</span><span>)</span> <span>||</span> <span>0</span><span>)</span> <span>+</span> flag<span>;</span>
    <span>if</span> <span>(</span>n <span>>=</span> <span>10</span><span>)</span> <span>{</span>
      n <span>-=</span> <span>10</span><span>;</span>
      flag <span>=</span> <span>1</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      flag <span>=</span> <span>0</span><span>;</span>
    <span>}</span>
    res <span>=</span> n <span>+</span> res<span>;</span>
  <span>}</span>
  <span>return</span> <span><span>`</span><span><span>${</span>flag <span>||</span> <span>''</span><span>}</span></span><span><span>${</span>res<span>}</span></span><span>`</span></span><span>;</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br></div></div><h2 id="_434-字符串中的单词数"> 434.字符串中的单词数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=434 lang=javascript
 *
 * [434] 字符串中的单词数
 * 
 * 统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。

请注意，你可以假定字符串里不包括任何不可打印的字符。

示例:

输入: "Hello, my name is John"
输出: 5
解释: 这里的单词是指连续的不是空格的字符，所以 "Hello," 算作 1 个单词。

 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @return {number}
 */</span>
<span>var</span> <span>countSegments</span> <span>=</span> <span>function</span> <span>(</span><span>s</span><span>)</span> <span>{</span>
  <span>return</span> s<span>.</span><span>split</span><span>(</span><span><span>/</span><span>\s+</span><span>/</span></span><span>)</span><span>.</span><span>filter</span><span>(</span>Boolean<span>)</span><span>.</span>length
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h2 id="_441-排列硬币"> 441.排列硬币</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=441 lang=javascript
 *
 * [441] 排列硬币
 * 
 * 你总共有 n 枚硬币，并计划将它们按阶梯状排列。对于一个由 k 行组成的阶梯，其第 i 行必须正好有 i 枚硬币。阶梯的最后一行 可能 是不完整的。

给你一个数字 n ，计算并返回可形成 完整阶梯行 的总行数。

 

示例 1：


输入：n = 5
输出：2
解释：因为第三行不完整，所以返回 2 。
示例 2：


输入：n = 8
输出：3
解释：因为第四行不完整，所以返回 3 。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} n
 * @return {number}
 */</span>
<span>var</span> <span>arrangeCoins</span> <span>=</span> <span>function</span> <span>(</span><span>n</span><span>)</span> <span>{</span>
  <span>let</span> i <span>=</span> <span>1</span><span>,</span> res <span>=</span> <span>1</span>
  <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
    res <span>+=</span> <span>++</span>i
    <span>if</span> <span>(</span>res <span>===</span> n<span>)</span> <span>return</span> i
    <span>else</span> <span>if</span> <span>(</span>res <span>></span> n<span>)</span> <span>return</span> i <span>-</span> <span>1</span>
  <span>}</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h2 id="_448-找到所有数组中消失的数字"> 448.找到所有数组中消失的数字</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=448 lang=javascript
 *
 * [448] 找到所有数组中消失的数字
 * 
 * 给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。

 

示例 1：

输入：nums = [4,3,2,7,8,2,3,1]
输出：[5,6]
示例 2：

输入：nums = [1,1]
输出：[2]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number[]}
 */</span>
<span>var</span> <span>findDisappearedNumbers</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>nums<span>.</span><span>includes</span><span>(</span>i<span>)</span><span>)</span> res<span>.</span><span>push</span><span>(</span>i<span>)</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><h2 id="_453-最小操作次数使数组元素相等"> 453.最小操作次数使数组元素相等</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=453 lang=javascript
 *
 * [453] 最小操作次数使数组元素相等
 * 
 * 给你一个长度为 n 的整数数组，每次操作将会使 n - 1 个元素增加 1 。返回让数组所有元素相等的最小操作次数。

 

示例 1：

输入：nums = [1,2,3]
输出：3
解释：
只需要3次操作（注意每次操作会增加两个元素的值）：
[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
示例 2：

输入：nums = [1,1,1]
输出：0
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number}
 */</span>
<span>var</span> <span>minMoves</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
  <span>const</span> sum <span>=</span> nums<span>.</span><span>reduce</span><span>(</span><span>(</span><span>p<span>,</span> c</span><span>)</span> <span>=></span> p <span>+</span> c<span>,</span> <span>0</span><span>)</span><span>;</span>
  <span>const</span> min <span>=</span> Math<span>.</span><span>min</span><span>(</span><span>...</span>nums<span>)</span><span>;</span>
  <span>return</span> sum <span>-</span> nums<span>.</span>length <span>*</span> min<span>;</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><h2 id="_455-分发饼干"> 455.分发饼干</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=455 lang=javascript
 *
 * [455] 分发饼干
 * 
 * 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

 
示例 1:

输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
示例 2:

输入: g = [1,2], s = [1,2,3]
输出: 2
解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} g
 * @param {number[]} s
 * @return {number}
 */</span>
<span>var</span> <span>findContentChildren</span> <span>=</span> <span>function</span> <span>(</span><span>g<span>,</span> s</span><span>)</span> <span>{</span>
  g<span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a <span>-</span> b<span>)</span>
  s<span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a <span>-</span> b<span>)</span>
  <span>let</span> cookie <span>=</span> <span>0</span><span>,</span> child <span>=</span> <span>0</span>
  <span>while</span> <span>(</span>child <span>&lt;</span> g<span>.</span>length <span>&amp;&amp;</span> cookie <span>&lt;</span> s<span>.</span>length<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>g<span>[</span>child<span>]</span> <span>&lt;=</span> s<span>[</span>cookie<span>]</span><span>)</span> <span>{</span>
      child<span>++</span><span>;</span>
    <span>}</span>
    cookie<span>++</span><span>;</span>
  <span>}</span>
  <span>return</span> child<span>;</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><h2 id="_459-重复的子字符串"> 459.重复的子字符串</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=459 lang=javascript
 *
 * [459] 重复的子字符串
 * 
 * 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。

 

示例 1:

输入: s = "abab"
输出: true
解释: 可由子串 "ab" 重复两次构成。
示例 2:

输入: s = "aba"
输出: false
示例 3:

输入: s = "abcabcabcabc"
输出: true
解释: 可由子串 "abc" 重复四次构成。 (或子串 "abcabc" 重复两次构成。)
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @return {boolean}
 */</span>
<span>var</span> <span>repeatedSubstringPattern</span> <span>=</span> <span>function</span> <span>(</span><span>s</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>s<span>.</span>length <span>===</span> <span>1</span><span>)</span> <span>return</span> <span>false</span>
  <span>let</span> n <span>=</span> <span>""</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span>length <span>/</span> <span>2</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
    n <span>=</span> s<span>.</span><span>substring</span><span>(</span><span>0</span><span>,</span> i <span>+</span> <span>1</span><span>)</span>
    <span>if</span> <span>(</span>s<span>.</span>length <span>%</span> n<span>.</span>length <span>!==</span> <span>0</span><span>)</span> <span>continue</span>
    <span>if</span> <span>(</span>n<span>.</span><span>repeat</span><span>(</span>s<span>.</span>length <span>/</span> n<span>.</span>length<span>)</span> <span>===</span> s<span>)</span> <span>return</span> <span>true</span>
  <span>}</span>
  <span>return</span> <span>false</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h2 id="_461-汉明距离"> 461.汉明距离</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=461 lang=javascript
 *
 * [461] 汉明距离
 * 
 * 两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。

给你两个整数 x 和 y，计算并返回它们之间的汉明距离。

 

示例 1：

输入：x = 1, y = 4
输出：2
解释：
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
上面的箭头指出了对应二进制位不同的位置。
示例 2：

输入：x = 3, y = 1
输出：1
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} x
 * @param {number} y
 * @return {number}
 */</span>
<span>var</span> <span>hammingDistance</span> <span>=</span> <span>function</span> <span>(</span><span>x<span>,</span> y</span><span>)</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>0</span><span>,</span> max <span>=</span> Math<span>.</span><span>max</span><span>(</span>x<span>,</span> y<span>)</span><span>,</span> min <span>=</span> Math<span>.</span><span>min</span><span>(</span>x<span>,</span> y<span>)</span>
  max <span>=</span> max<span>.</span><span>toString</span><span>(</span><span>2</span><span>)</span>
  min <span>=</span> min<span>.</span><span>toString</span><span>(</span><span>2</span><span>)</span>
  min <span>=</span> <span>"0"</span><span>.</span><span>repeat</span><span>(</span>max<span>.</span>length <span>-</span> min<span>.</span>length<span>)</span> <span>+</span> min
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> max<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>max<span>[</span>i<span>]</span> <span>!==</span> min<span>[</span>i<span>]</span><span>)</span> res<span>++</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h2 id="_463-岛屿的周长"> 463.岛屿的周长</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=463 lang=javascript
 *
 * [463] 岛屿的周长
 * 
 * 给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。

网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。

岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。

 

示例 1：



输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
输出：16
解释：它的周长是上面图片中的 16 个黄色的边
示例 2：

输入：grid = [[1]]
输出：4
示例 3：

输入：grid = [[1,0]]
输出：4
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[][]} grid
 * @return {number}
 */</span>
<span>var</span> <span>islandPerimeter</span> <span>=</span> <span>function</span> <span>(</span><span>grid</span><span>)</span> <span>{</span>
  <span>let</span> a <span>=</span> <span>0</span><span>,</span> b <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> grid<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> grid<span>[</span><span>0</span><span>]</span><span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>grid<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>===</span> <span>0</span><span>)</span> <span>continue</span><span>;</span>
      a<span>++</span><span>;</span>
      <span>if</span> <span>(</span>grid<span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>&amp;&amp;</span> grid<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j<span>]</span> <span>===</span> <span>1</span><span>)</span> b<span>++</span>
      <span>if</span> <span>(</span>grid<span>[</span>i <span>+</span> <span>1</span><span>]</span> <span>&amp;&amp;</span> grid<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>[</span>j<span>]</span> <span>===</span> <span>1</span><span>)</span> b<span>++</span>
      <span>if</span> <span>(</span>grid<span>[</span>i<span>]</span><span>[</span>j <span>-</span> <span>1</span><span>]</span> <span>===</span> <span>1</span><span>)</span> b<span>++</span>
      <span>if</span> <span>(</span>grid<span>[</span>i<span>]</span><span>[</span>j <span>+</span> <span>1</span><span>]</span> <span>===</span> <span>1</span><span>)</span> b<span>++</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> a <span>*</span> <span>4</span> <span>-</span> b
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><h2 id="_476-数字的补数"> 476.数字的补数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=476 lang=javascript
 *
 * [476] 数字的补数
 * 
 * 对整数的二进制表示取反（0 变 1 ，1 变 0）后，再转换为十进制表示，可以得到这个整数的补数。

例如，整数 5 的二进制表示是 "101" ，取反后得到 "010" ，再转回十进制表示得到补数 2 。
给你一个整数 num ，输出它的补数。

 

示例 1：

输入：num = 5
输出：2
解释：5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。
示例 2：

输入：num = 1
输出：0
解释：1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} num
 * @return {number}
 */</span>
<span>var</span> <span>findComplement</span> <span>=</span> <span>function</span> <span>(</span><span>num</span><span>)</span> <span>{</span>
  num <span>=</span> num<span>.</span><span>toString</span><span>(</span><span>2</span><span>)</span>
  <span>let</span> s <span>=</span> <span>""</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> num<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    s <span>+=</span> num<span>[</span>i<span>]</span> <span>===</span> <span>"0"</span> <span>?</span> <span>"1"</span> <span>:</span> <span>"0"</span>
  <span>}</span>
  <span>return</span> <span>parseInt</span><span>(</span>s<span>,</span> <span>2</span><span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id="_482-密钥格式化"> 482.密钥格式化</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=482 lang=javascript
 *
 * [482] 密钥格式化
 * 
 * 给定一个许可密钥字符串 s，仅由字母、数字字符和破折号组成。字符串由 n 个破折号分成 n + 1 组。你也会得到一个整数 k 。

我们想要重新格式化字符串 s，使每一组包含 k 个字符，除了第一组，它可以比 k 短，但仍然必须包含至少一个字符。此外，两组之间必须插入破折号，并且应该将所有小写字母转换为大写字母。

返回 重新格式化的许可密钥 。

 

示例 1：

输入：S = "5F3Z-2e-9-w", k = 4
输出："5F3Z-2E9W"
解释：字符串 S 被分成了两个部分，每部分 4 个字符；
     注意，两个额外的破折号需要删掉。
示例 2：

输入：S = "2-5g-3-J", k = 2
输出："2-5G-3J"
解释：字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @param {number} k
 * @return {string}
 */</span>
<span>var</span> <span>licenseKeyFormatting</span> <span>=</span> <span>function</span> <span>(</span><span>s<span>,</span> k</span><span>)</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>""</span>
  s <span>=</span> s<span>.</span><span>replace</span><span>(</span><span><span>/</span><span>\-</span><span>/</span><span>g</span></span><span>,</span> <span>""</span><span>)</span><span>.</span><span>toLocaleUpperCase</span><span>(</span><span>)</span>
  <span>const</span> head <span>=</span> s<span>.</span>length <span>%</span> k
  <span>if</span> <span>(</span>head <span>></span> <span>0</span><span>)</span> <span>{</span>
    res <span>+=</span> s<span>.</span><span>substring</span><span>(</span><span>0</span><span>,</span> head<span>)</span>
    s <span>=</span> s<span>.</span><span>substring</span><span>(</span>head<span>,</span> s<span>.</span>length<span>)</span>
  <span>}</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span>length<span>;</span> i <span>+=</span> k<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>res<span>.</span>length <span>></span> <span>0</span><span>)</span> res <span>+=</span> <span>"-"</span>
    res <span>+=</span> s<span>.</span><span>substring</span><span>(</span>i<span>,</span> i <span>+</span> k<span>)</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><h2 id="_485-最大连续-1-的个数"> 485.最大连续-1-的个数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=485 lang=javascript
 *
 * [485] 最大连续 1 的个数
 * 
 * 给定一个二进制数组 nums ， 计算其中最大连续 1 的个数。

 

示例 1：

输入：nums = [1,1,0,1,1,1]
输出：3
解释：开头的两位和最后的三位都是连续 1 ，所以最大连续 1 的个数是 3.
示例 2:

输入：nums = [1,0,1,1,0,1]
输出：2
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number}
 */</span>
<span>var</span> <span>findMaxConsecutiveOnes</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>[</span><span>...</span><span>new</span> <span>Set</span><span>(</span>nums<span>)</span><span>]</span><span>.</span><span>toString</span><span>(</span><span>)</span> <span>===</span> <span>"0"</span><span>)</span> <span>return</span> <span>0</span>
  <span>let</span> max <span>=</span> <span>0</span><span>,</span> start <span>=</span> <span>-</span><span>1</span><span>,</span> end <span>=</span> <span>-</span><span>1</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;=</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>===</span> <span>1</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>start <span>&lt;</span> <span>0</span><span>)</span> start <span>=</span> i
      end <span>=</span> i
    <span>}</span> <span>else</span> <span>{</span>
      max <span>=</span> Math<span>.</span><span>max</span><span>(</span>max<span>,</span> end <span>-</span> start <span>+</span> <span>1</span><span>)</span>
      start <span>=</span> <span>-</span><span>1</span>
      end <span>=</span> <span>-</span><span>1</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> max
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h2 id="_492-构造矩形"> 492.构造矩形</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=492 lang=javascript
 *
 * [492] 构造矩形
 * 
 * 作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 所以，现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求：

你设计的矩形页面必须等于给定的目标面积。
宽度 W 不应大于长度 L ，换言之，要求 L >= W 。
长度 L 和宽度 W 之间的差距应当尽可能小。
返回一个 数组 [L, W]，其中 L 和 W 是你按照顺序设计的网页的长度和宽度。
 

示例1：

输入: 4
输出: [2, 2]
解释: 目标面积是 4， 所有可能的构造方案有 [1,4], [2,2], [4,1]。
但是根据要求2，[1,4] 不符合要求; 根据要求3，[2,2] 比 [4,1] 更能符合要求. 所以输出长度 L 为 2， 宽度 W 为 2。
示例 2:

输入: area = 37
输出: [37,1]
示例 3:

输入: area = 122122
输出: [427,286]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} area
 * @return {number[]}
 */</span>
<span>var</span> <span>constructRectangle</span> <span>=</span> <span>function</span> <span>(</span><span>area</span><span>)</span> <span>{</span>
  <span>let</span> l <span>=</span> Math<span>.</span><span>ceil</span><span>(</span>Math<span>.</span><span>sqrt</span><span>(</span>area<span>)</span><span>)</span>
  <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>area <span>%</span> l <span>===</span> <span>0</span><span>)</span> <span>return</span> <span>[</span>l<span>,</span> area <span>/</span> l<span>]</span>
    l<span>++</span>
  <span>}</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><h2 id="_495-提莫攻击"> 495.提莫攻击</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=495 lang=typescript
 *
 * [495] 提莫攻击
 * 
 * 在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄。他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。

当提莫攻击艾希，艾希的中毒状态正好持续 duration 秒。

正式地讲，提莫在 t 发起发起攻击意味着艾希在时间区间 [t, t + duration - 1]（含 t 和 t + duration - 1）处于中毒状态。如果提莫在中毒影响结束 前 再次攻击，中毒状态计时器将会 重置 ，在新的攻击之后，中毒影响将会在 duration 秒后结束。

给你一个 非递减 的整数数组 timeSeries ，其中 timeSeries[i] 表示提莫在 timeSeries[i] 秒时对艾希发起攻击，以及一个表示中毒持续时间的整数 duration 。

返回艾希处于中毒状态的 总 秒数。

 
示例 1：

输入：timeSeries = [1,4], duration = 2
输出：4
解释：提莫攻击对艾希的影响如下：
- 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。
- 第 4 秒，提莫再次攻击艾希，艾希中毒状态又持续 2 秒，即第 4 秒和第 5 秒。
艾希在第 1、2、4、5 秒处于中毒状态，所以总中毒秒数是 4 。
示例 2：

输入：timeSeries = [1,2], duration = 2
输出：3
解释：提莫攻击对艾希的影响如下：
- 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。
- 第 2 秒，提莫再次攻击艾希，并重置中毒计时器，艾希中毒状态需要持续 2 秒，即第 2 秒和第 3 秒。
艾希在第 1、2、3 秒处于中毒状态，所以总中毒秒数是 3 。
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>findPoisonedDuration</span><span>(</span>timeSeries<span>:</span> <span>number</span><span>[</span><span>]</span><span>,</span> duration<span>:</span> <span>number</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>let</span> res<span>:</span> <span>number</span> <span>=</span> <span>0</span><span>,</span> until<span>:</span> <span>number</span> <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> timeSeries<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    res <span>+=</span> timeSeries<span>[</span>i<span>]</span> <span>></span> until <span>?</span> duration <span>:</span> duration <span>-</span> <span>(</span>until <span>-</span> timeSeries<span>[</span>i<span>]</span><span>)</span>
    until <span>=</span> timeSeries<span>[</span>i<span>]</span> <span>+</span> duration
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><h2 id="_496-下一个更大元素-i"> 496.下一个更大元素-i</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=496 lang=javascript
 *
 * [496] 下一个更大元素 I
 * 
 * nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。

给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。

对于每个 0 &lt;= i &lt; nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。

返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。

 

示例 1：

输入：nums1 = [4,1,2], nums2 = [1,3,4,2].
输出：[-1,3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。
- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
示例 2：

输入：nums1 = [2,4], nums2 = [1,2,3,4].
输出：[3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。
- 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */</span>
<span>var</span> <span>nextGreaterElement</span> <span>=</span> <span>function</span> <span>(</span><span>nums1<span>,</span> nums2</span><span>)</span> <span>{</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span><span>,</span> max <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>...</span>nums2<span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums1<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> index <span>=</span> nums2<span>.</span><span>indexOf</span><span>(</span>nums1<span>[</span>i<span>]</span><span>)</span>
    <span>if</span> <span>(</span>nums1<span>[</span>i<span>]</span> <span>===</span> max <span>||</span> index <span>===</span> nums2<span>.</span>length <span>-</span> <span>1</span><span>)</span> <span>{</span>
      res<span>.</span><span>push</span><span>(</span><span>-</span><span>1</span><span>)</span>
      <span>continue</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> index <span>+</span> <span>1</span><span>;</span> j <span>&lt;</span> nums2<span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>nums2<span>[</span>j<span>]</span> <span>></span> nums1<span>[</span>i<span>]</span><span>)</span> <span>{</span>
        res<span>.</span><span>push</span><span>(</span>nums2<span>[</span>j<span>]</span><span>)</span>
        <span>break</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>if</span> <span>(</span>j <span>===</span> nums2<span>.</span>length <span>-</span> <span>1</span><span>)</span> res<span>.</span><span>push</span><span>(</span><span>-</span><span>1</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br></div></div><h2 id="_500-键盘行"> 500.键盘行</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=500 lang=javascript
 *
 * [500] 键盘行
 * 
 * 给你一个字符串数组 words ，只返回可以使用在 美式键盘 同一行的字母打印出来的单词。键盘如下图所示。

美式键盘 中：

第一行由字符 "qwertyuiop" 组成。
第二行由字符 "asdfghjkl" 组成。
第三行由字符 "zxcvbnm" 组成。
American keyboard

 

示例 1：

输入：words = ["Hello","Alaska","Dad","Peace"]
输出：["Alaska","Dad"]
示例 2：

输入：words = ["omk"]
输出：[]
示例 3：

输入：words = ["adsdf","sfd"]
输出：["adsdf","sfd"]
 


 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string[]} words
 * @return {string[]}
 */</span>
<span>var</span> <span>findWords</span> <span>=</span> <span>function</span> <span>(</span><span>words</span><span>)</span> <span>{</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span><span>,</span> set1 <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>[</span><span>"Q"</span><span>,</span> <span>"q"</span><span>,</span> <span>"W"</span><span>,</span> <span>"w"</span><span>,</span> <span>"E"</span><span>,</span> <span>"e"</span><span>,</span> <span>"R"</span><span>,</span> <span>"r"</span><span>,</span> <span>"T"</span><span>,</span> <span>"t"</span><span>,</span> <span>"Y"</span><span>,</span> <span>"y"</span><span>,</span> <span>"U"</span><span>,</span> <span>"u"</span><span>,</span> <span>"I"</span><span>,</span> <span>"i"</span><span>,</span> <span>"O"</span><span>,</span> <span>"o"</span><span>,</span> <span>"P"</span><span>,</span> <span>"p"</span><span>]</span><span>)</span><span>,</span> set2 <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>[</span><span>"A"</span><span>,</span> <span>"a"</span><span>,</span> <span>"S"</span><span>,</span> <span>"s"</span><span>,</span> <span>"D"</span><span>,</span> <span>"d"</span><span>,</span> <span>"F"</span><span>,</span> <span>"f"</span><span>,</span> <span>"G"</span><span>,</span> <span>"g"</span><span>,</span> <span>"H"</span><span>,</span> <span>"h"</span><span>,</span> <span>"J"</span><span>,</span> <span>"j"</span><span>,</span> <span>"K"</span><span>,</span> <span>"k"</span><span>,</span> <span>"L"</span><span>,</span> <span>"l"</span><span>]</span><span>)</span><span>,</span> set3 <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>[</span><span>"Z"</span><span>,</span> <span>"z"</span><span>,</span> <span>"X"</span><span>,</span> <span>"x"</span><span>,</span> <span>"C"</span><span>,</span> <span>"c"</span><span>,</span> <span>"V"</span><span>,</span> <span>"v"</span><span>,</span> <span>"B"</span><span>,</span> <span>"b"</span><span>,</span> <span>"N"</span><span>,</span> <span>"n"</span><span>,</span> <span>"M"</span><span>,</span> <span>"m"</span><span>]</span><span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> words<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    res<span>.</span><span>push</span><span>(</span>words<span>[</span>i<span>]</span><span>)</span>
    <span>const</span> set <span>=</span> set1<span>.</span><span>has</span><span>(</span>words<span>[</span>i<span>]</span><span>[</span><span>0</span><span>]</span><span>)</span> <span>?</span> set1 <span>:</span> set2<span>.</span><span>has</span><span>(</span>words<span>[</span>i<span>]</span><span>[</span><span>0</span><span>]</span><span>)</span> <span>?</span> set2 <span>:</span> set3
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>1</span><span>;</span> j <span>&lt;</span> words<span>[</span>i<span>]</span><span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>!</span>set<span>.</span><span>has</span><span>(</span>words<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>)</span><span>)</span> <span>{</span>
        res<span>.</span><span>pop</span><span>(</span><span>)</span>
        <span>break</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><h2 id="_501-二叉搜索树中的众数"> 501.二叉搜索树中的众数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=501 lang=typescript
 *
 * [501] 二叉搜索树中的众数
 * 
 * 给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。

如果树中有不止一个众数，可以按 任意顺序 返回。

假定 BST 满足如下定义：

结点左子树中所含节点的值 小于等于 当前节点的值
结点右子树中所含节点的值 大于等于 当前节点的值
左子树和右子树都是二叉搜索树
 

示例 1：


输入：root = [1,null,2,2]
输出：[2]
示例 2：

输入：root = [0]
输出：[0]
 


 */</span>

<span>// @lc code=start</span>
<span>/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */</span>

<span>function</span> <span>findMode</span><span>(</span>root<span>:</span> TreeNode <span>|</span> <span>null</span><span>)</span><span>:</span> <span>number</span><span>[</span><span>]</span> <span>{</span>
  <span>const</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>,</span> res<span>:</span> <span>number</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>]</span><span>,</span> stack <span>=</span> <span>[</span><span>]</span>
  <span>let</span> max <span>=</span> <span>0</span>
  <span>while</span> <span>(</span>root <span>||</span> stack<span>.</span>length <span>></span> <span>0</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>root<span>)</span> <span>{</span>
          map<span>.</span><span>set</span><span>(</span>root<span>.</span>val<span>,</span> <span>(</span>map<span>.</span><span>get</span><span>(</span>root<span>.</span>val<span>)</span> <span>||</span> <span>0</span><span>)</span> <span>+</span> <span>1</span><span>)</span>
          max <span>=</span> Math<span>.</span><span>max</span><span>(</span>max<span>,</span> map<span>.</span><span>get</span><span>(</span>root<span>.</span>val<span>)</span><span>)</span>
          stack<span>.</span><span>push</span><span>(</span>root<span>)</span>
          root <span>=</span> root<span>.</span>left
      <span>}</span> <span>else</span> <span>{</span>
          root <span>=</span> stack<span>.</span><span>pop</span><span>(</span><span>)</span>
          root <span>=</span> root<span>.</span>right
      <span>}</span>
  <span>}</span>
  <span>for</span> <span>(</span><span>const</span> <span>[</span>key<span>,</span> value<span>]</span> <span>of</span> map<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>value <span>===</span> max<span>)</span> res<span>.</span><span>push</span><span>(</span>key<span>)</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br></div></div><h2 id="_504-七进制数"> 504.七进制数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=504 lang=typescript
 *
 * [504] 七进制数
 * 
 * 给定一个整数 num，将其转化为 7 进制，并以字符串形式输出。

 

示例 1:

输入: num = 100
输出: "202"
示例 2:

输入: num = -7
输出: "-10"
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>convertToBase7</span><span>(</span>num<span>:</span> <span>number</span><span>)</span><span>:</span> <span>string</span> <span>{</span>
  <span>return</span> num<span>.</span><span>toString</span><span>(</span><span>7</span><span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id="_506-相对名次"> 506.相对名次</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=506 lang=javascript
 *
 * [506] 相对名次
 * 
 * 给你一个长度为 n 的整数数组 score ，其中 score[i] 是第 i 位运动员在比赛中的得分。所有得分都 互不相同 。

运动员将根据得分 决定名次 ，其中名次第 1 的运动员得分最高，名次第 2 的运动员得分第 2 高，依此类推。运动员的名次决定了他们的获奖情况：

名次第 1 的运动员获金牌 "Gold Medal" 。
名次第 2 的运动员获银牌 "Silver Medal" 。
名次第 3 的运动员获铜牌 "Bronze Medal" 。
从名次第 4 到第 n 的运动员，只能获得他们的名次编号（即，名次第 x 的运动员获得编号 "x"）。
使用长度为 n 的数组 answer 返回获奖，其中 answer[i] 是第 i 位运动员的获奖情况。

 

示例 1：

输入：score = [5,4,3,2,1]
输出：["Gold Medal","Silver Medal","Bronze Medal","4","5"]
解释：名次为 [1st, 2nd, 3rd, 4th, 5th] 。
示例 2：

输入：score = [10,3,8,9,4]
输出：["Gold Medal","5","Bronze Medal","Silver Medal","4"]
解释：名次为 [1st, 5th, 3rd, 2nd, 4th] 。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} score
 * @return {string[]}
 */</span>
<span>var</span> <span>findRelativeRanks</span> <span>=</span> <span>function</span> <span>(</span><span>score</span><span>)</span> <span>{</span>
  <span>const</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>[</span><span>[</span><span>1</span><span>,</span> <span>"Gold Medal"</span><span>]</span><span>,</span> <span>[</span><span>2</span><span>,</span> <span>"Silver Medal"</span><span>]</span><span>,</span> <span>[</span><span>3</span><span>,</span> <span>"Bronze Medal"</span><span>]</span><span>]</span><span>)</span>
  <span>const</span> arr <span>=</span> score
    <span>.</span><span>map</span><span>(</span><span>(</span><span>value<span>,</span> index</span><span>)</span> <span>=></span> <span>(</span><span>{</span> value<span>,</span> index <span>}</span><span>)</span><span>)</span>
    <span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> b<span>.</span>value <span>-</span> a<span>.</span>value<span>)</span><span>;</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    res<span>[</span>arr<span>[</span>i<span>]</span><span>.</span>index<span>]</span> <span>=</span> map<span>.</span><span>get</span><span>(</span>i <span>+</span> <span>1</span><span>)</span> <span>||</span> <span>(</span>i <span>+</span> <span>1</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span>
  <span>}</span>
  <span>return</span> res<span>;</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><h2 id="_507-完美数"> 507.完美数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=507 lang=javascript
 *
 * [507] 完美数
 * 
 * 对于一个 正整数，如果它和除了它自身以外的所有 正因子 之和相等，我们称它为 「完美数」。

给定一个 整数 n， 如果是完美数，返回 true；否则返回 false。

 

示例 1：

输入：num = 28
输出：true
解释：28 = 1 + 2 + 4 + 7 + 14
1, 2, 4, 7, 和 14 是 28 的所有正因子。
示例 2：

输入：num = 7
输出：false
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} num
 * @return {boolean}
 */</span>
 <span>var</span> <span>checkPerfectNumber</span> <span>=</span> <span>function</span> <span>(</span><span>num</span><span>)</span> <span>{</span>
  <span>const</span> arr <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> num <span>/</span> <span>2</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>num <span>%</span> i <span>===</span> <span>0</span><span>)</span> arr<span>.</span><span>push</span><span>(</span>i<span>)</span>
  <span>}</span>
  <span>return</span> num <span>===</span> arr<span>.</span><span>reduce</span><span>(</span><span>(</span><span>prev<span>,</span> next</span><span>)</span> <span>=></span> prev <span>+</span> next<span>,</span> <span>0</span><span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><h2 id="_509-斐波那契数"> 509.斐波那契数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=509 lang=javascript
 *
 * [509] 斐波那契数
 * 
 * 斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给定 n ，请计算 F(n) 。

 

示例 1：

输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
示例 2：

输入：n = 3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2
示例 3：

输入：n = 4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} n
 * @return {number}
 */</span>
<span>var</span> <span>fib</span> <span>=</span> <span>function</span> <span>(</span><span>n</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>n <span>===</span> <span>0</span><span>)</span> <span>return</span> <span>0</span>
  <span>else</span> <span>if</span> <span>(</span>n <span>&lt;</span> <span>3</span><span>)</span> <span>return</span> <span>1</span>
  <span>return</span> <span>fib</span><span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>+</span> <span>fib</span><span>(</span>n <span>-</span> <span>2</span><span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h2 id="_520-检测大写字母"> 520.检测大写字母</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=520 lang=javascript
 *
 * [520] 检测大写字母
 * 
 * 我们定义，在以下情况时，单词的大写用法是正确的：

全部字母都是大写，比如 "USA" 。
单词中所有字母都不是大写，比如 "leetcode" 。
如果单词不只含有一个字母，只有首字母大写， 比如 "Google" 。
给你一个字符串 word 。如果大写用法正确，返回 true ；否则，返回 false 。

 

示例 1：

输入：word = "USA"
输出：true
示例 2：

输入：word = "FlaG"
输出：false
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} word
 * @return {boolean}
 */</span>
<span>var</span> <span>detectCapitalUse</span> <span>=</span> <span>function</span> <span>(</span><span>word</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>word<span>.</span>length <span>===</span> <span>1</span><span>)</span> <span>return</span> <span>true</span>
  <span>const</span> stage <span>=</span> word<span>[</span><span>0</span><span>]</span><span>.</span><span>charCodeAt</span><span>(</span><span>0</span><span>)</span> <span>&lt;</span> <span>91</span> <span>&amp;&amp;</span> word<span>[</span><span>1</span><span>]</span><span>.</span><span>charCodeAt</span><span>(</span><span>0</span><span>)</span> <span>&lt;</span> <span>91</span> <span>?</span> <span>1</span> <span>:</span> flag2 <span>=</span> word<span>[</span><span>0</span><span>]</span><span>.</span><span>charCodeAt</span><span>(</span><span>0</span><span>)</span> <span>></span> <span>96</span> <span>&amp;&amp;</span> word<span>[</span><span>1</span><span>]</span><span>.</span><span>charCodeAt</span><span>(</span><span>0</span><span>)</span> <span>></span> <span>96</span> <span>?</span> <span>2</span> <span>:</span> flag3 <span>=</span> word<span>[</span><span>0</span><span>]</span><span>.</span><span>charCodeAt</span><span>(</span><span>0</span><span>)</span> <span>&lt;</span> <span>91</span> <span>&amp;&amp;</span> word<span>[</span><span>1</span><span>]</span><span>.</span><span>charCodeAt</span><span>(</span><span>0</span><span>)</span> <span>></span> <span>96</span> <span>?</span> <span>3</span> <span>:</span> <span>0</span>
  <span>if</span> <span>(</span>stage <span>===</span> <span>0</span><span>)</span> <span>return</span> <span>false</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;</span> word<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>stage <span>===</span> <span>1</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>word<span>[</span>i<span>]</span><span>.</span><span>charCodeAt</span><span>(</span><span>0</span><span>)</span> <span>></span> <span>96</span><span>)</span> <span>return</span> <span>false</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>if</span> <span>(</span>word<span>[</span>i<span>]</span><span>.</span><span>charCodeAt</span><span>(</span><span>0</span><span>)</span> <span>&lt;</span> <span>91</span><span>)</span> <span>return</span> <span>false</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>true</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h2 id="_521-最长特殊序列-i"> 521.最长特殊序列-ⅰ</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=521 lang=javascript
 *
 * [521] 最长特殊序列 Ⅰ
 * 
 * 给你两个字符串 a 和 b，请返回 这两个字符串中 最长的特殊序列  的长度。如果不存在，则返回 -1 。

「最长特殊序列」 定义如下：该序列为 某字符串独有的最长子序列（即不能是其他字符串的子序列） 。

字符串 s 的子序列是在从 s 中删除任意数量的字符后可以获得的字符串。

例如，"abc" 是 "aebdc" 的子序列，因为删除 "aebdc" 中斜体加粗的字符可以得到 "abc" 。 "aebdc" 的子序列还包括 "aebdc" 、 "aeb" 和 "" (空字符串)。
 

示例 1：

输入: a = "aba", b = "cdc"
输出: 3
解释: 最长特殊序列可为 "aba" (或 "cdc")，两者均为自身的子序列且不是对方的子序列。
示例 2：

输入：a = "aaa", b = "bbb"
输出：3
解释: 最长特殊序列是 "aaa" 和 "bbb" 。
示例 3：

输入：a = "aaa", b = "aaa"
输出：-1
解释: 字符串 a 的每个子序列也是字符串 b 的每个子序列。同样，字符串 b 的每个子序列也是字符串 a 的子序列。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} a
 * @param {string} b
 * @return {number}
 */</span>
 <span>var</span> <span>findLUSlength</span> <span>=</span> <span>function</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>a <span>===</span> b<span>)</span> <span>return</span> <span>-</span><span>1</span><span>;</span>
  <span>else</span> <span>return</span> Math<span>.</span><span>max</span><span>(</span>a<span>.</span>length<span>,</span> b<span>.</span>length<span>)</span><span>;</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><h2 id="_530-二叉搜索树的最小绝对差"> 530.二叉搜索树的最小绝对差</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=530 lang=typescript
 *
 * [530] 二叉搜索树的最小绝对差
 */</span>

<span>// @lc code=start</span>
<span>/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */</span>

<span>function</span> <span>getMinimumDifference</span><span>(</span>root<span>:</span> TreeNode <span>|</span> <span>null</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>const</span> stack <span>=</span> <span>[</span><span>]</span><span>,</span> arr<span>:</span> <span>number</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>]</span>
  <span>while</span> <span>(</span>root <span>||</span> stack<span>.</span>length <span>></span> <span>0</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root<span>)</span> <span>{</span>
      arr<span>.</span><span>push</span><span>(</span>root<span>.</span>val<span>)</span>
      stack<span>.</span><span>push</span><span>(</span>root<span>)</span>
      root <span>=</span> root<span>.</span>left
    <span>}</span> <span>else</span> <span>{</span>
      root <span>=</span> stack<span>.</span><span>pop</span><span>(</span><span>)</span>
      root <span>=</span> root<span>.</span>right
    <span>}</span>
  <span>}</span>
  arr<span>.</span><span>sort</span><span>(</span><span>(</span>a<span>,</span> b<span>)</span> <span>=></span> a <span>-</span> b<span>)</span>
  <span>let</span> res<span>:</span> <span>number</span> <span>=</span> arr<span>[</span><span>1</span><span>]</span> <span>-</span> arr<span>[</span><span>0</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    res <span>=</span> Math<span>.</span><span>min</span><span>(</span>arr<span>[</span>i<span>]</span> <span>-</span> arr<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>,</span> res<span>)</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><h2 id="_541-反转字符串-ii"> 541.反转字符串-ii</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=541 lang=javascript
 *
 * [541] 反转字符串 II
 * 
 * 给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。

如果剩余字符少于 k 个，则将剩余字符全部反转。
如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。
 

示例 1：

输入：s = "abcdefg", k = 2
输出："bacdfeg"
示例 2：

输入：s = "abcd", k = 2
输出："bacd"
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @param {number} k
 * @return {string}
 */</span>
 <span>var</span> <span>reverseStr</span> <span>=</span> <span>function</span> <span>(</span><span>s<span>,</span> k</span><span>)</span> <span>{</span>
  s <span>=</span> s<span>.</span><span>split</span><span>(</span><span>''</span><span>)</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span>length<span>;</span> i <span>+=</span> <span>2</span> <span>*</span> k<span>)</span> <span>{</span>
    <span>const</span> len <span>=</span> Math<span>.</span><span>min</span><span>(</span>s<span>.</span><span>slice</span><span>(</span>i<span>)</span><span>.</span>length<span>,</span> k<span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> len <span>/</span> <span>2</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>
      <span>[</span>s<span>[</span>i <span>+</span> j<span>]</span><span>,</span> s<span>[</span>i <span>+</span> len <span>-</span> <span>1</span> <span>-</span> j<span>]</span><span>]</span> <span>=</span> <span>[</span>s<span>[</span>i <span>+</span> len <span>-</span> <span>1</span> <span>-</span> j<span>]</span><span>,</span> s<span>[</span>i <span>+</span> j<span>]</span><span>]</span><span>;</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> s<span>.</span><span>join</span><span>(</span><span>""</span><span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id="_543-二叉树的直径"> 543.二叉树的直径</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=543 lang=typescript
 *
 * [543] 二叉树的直径
 * 
 * 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

 

示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

 

注意：两结点之间的路径长度是以它们之间边的数目表示。


 */</span>

<span>// @lc code=start</span>
<span>/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */</span>

<span>function</span> <span>diameterOfBinaryTree</span><span>(</span>root<span>:</span> TreeNode <span>|</span> <span>null</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>let</span> result <span>=</span> <span>0</span>
  <span>function</span> <span>deep</span><span>(</span>root<span>:</span> TreeNode <span>|</span> <span>null</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>root<span>)</span> <span>return</span> <span>-</span><span>1</span><span>;</span>
    <span>const</span> left <span>=</span> root<span>.</span>left <span>?</span> <span>deep</span><span>(</span>root<span>.</span>left<span>)</span> <span>+</span> <span>1</span> <span>:</span> <span>0</span><span>;</span>
    <span>const</span> right <span>=</span> root<span>.</span>right <span>?</span> <span>deep</span><span>(</span>root<span>.</span>right<span>)</span> <span>+</span> <span>1</span> <span>:</span> <span>0</span><span>;</span>
    result <span>=</span> Math<span>.</span><span>max</span><span>(</span>left <span>+</span> right<span>,</span> result<span>)</span><span>;</span>
    <span>return</span> Math<span>.</span><span>max</span><span>(</span>left<span>,</span> right<span>)</span><span>;</span>
  <span>}</span>
  <span>deep</span><span>(</span>root<span>)</span>
  <span>return</span> result
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br></div></div><h2 id="_551-学生出勤记录-i"> 551.学生出勤记录-i</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=551 lang=javascript
 *
 * [551] 学生出勤记录 I
 * 
 * 给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：

'A'：Absent，缺勤
'L'：Late，迟到
'P'：Present，到场
如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：

按 总出勤 计，学生缺勤（'A'）严格 少于两天。
学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（'L'）记录。
如果学生可以获得出勤奖励，返回 true ；否则，返回 false 。

 

示例 1：

输入：s = "PPALLP"
输出：true
解释：学生缺勤次数少于 2 次，且不存在 3 天或以上的连续迟到记录。
示例 2：

输入：s = "PPALLL"
输出：false
解释：学生最后三天连续迟到，所以不满足出勤奖励的条件。
 


 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @return {boolean}
 */</span>
<span>var</span> <span>checkRecord</span> <span>=</span> <span>function</span> <span>(</span><span>s</span><span>)</span> <span>{</span>
  <span>let</span> countA <span>=</span> <span>0</span><span>,</span> countL <span>=</span> <span>0</span><span>,</span> prev
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>s<span>[</span>i<span>]</span> <span>===</span> <span>"A"</span><span>)</span> countA<span>++</span>
    <span>if</span> <span>(</span>s<span>[</span>i<span>]</span> <span>===</span> <span>"L"</span><span>)</span> <span>{</span>
      countL<span>++</span>
    <span>}</span> <span>else</span> <span>{</span>
      countL <span>=</span> <span>0</span>
    <span>}</span>
    <span>if</span> <span>(</span>countA <span>></span> <span>1</span> <span>||</span> countL <span>></span> <span>2</span><span>)</span> <span>return</span> <span>false</span>
    prev <span>=</span> s<span>[</span>i<span>]</span>
  <span>}</span>
  <span>return</span> <span>true</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><h2 id="_557-反转字符串中的单词-iii"> 557.反转字符串中的单词-iii</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=557 lang=javascript
 *
 * [557] 反转字符串中的单词 III
 * 
 * 给定一个字符串 s ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

 

示例 1：

输入：s = "Let's take LeetCode contest"
输出："s'teL ekat edoCteeL tsetnoc"
示例 2:

输入： s = "God Ding"
输出："doG gniD"
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @return {string}
 */</span>
<span>var</span> <span>reverseWords</span> <span>=</span> <span>function</span> <span>(</span><span>s</span><span>)</span> <span>{</span>
  <span>return</span> s<span>.</span><span>split</span><span>(</span><span>" "</span><span>)</span><span>.</span><span>map</span><span>(</span><span>item</span> <span>=></span> item<span>.</span><span>split</span><span>(</span><span>""</span><span>)</span><span>.</span><span>reverse</span><span>(</span><span>)</span><span>.</span><span>join</span><span>(</span><span>""</span><span>)</span><span>)</span><span>.</span><span>join</span><span>(</span><span>" "</span><span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><h2 id="_561-数组拆分-i"> 561.数组拆分-i</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=561 lang=javascript
 *
 * [561] 数组拆分 I
 * 
 * 给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。

返回该 最大总和 。

 

示例 1：

输入：nums = [1,4,3,2]
输出：4
解释：所有可能的分法（忽略元素顺序）为：
1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3
2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3
3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4
所以最大总和为 4
示例 2：

输入：nums = [6,2,6,5,1,2]
输出：9
解释：最优的分法为 (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number}
 */</span>
<span>var</span> <span>arrayPairSum</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
  nums <span>=</span> nums<span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a <span>-</span> b<span>)</span>
  <span>let</span> count <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i <span>+=</span> <span>2</span><span>)</span> <span>{</span>
    count <span>+=</span> nums<span>[</span>i<span>]</span>
  <span>}</span>
  <span>return</span> count
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h2 id="_566-重塑矩阵"> 566.重塑矩阵</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=566 lang=javascript
 *
 * [566] 重塑矩阵
 * 
 * 在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个 m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。

给你一个由二维数组 mat 表示的 m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩阵的行数和列数。

重构后的矩阵需要将原始矩阵的所有元素以相同的 行遍历顺序 填充。

如果具有给定参数的 reshape 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。

 

示例 1：


输入：mat = [[1,2],[3,4]], r = 1, c = 4
输出：[[1,2,3,4]]
示例 2：


输入：mat = [[1,2],[3,4]], r = 2, c = 4
输出：[[1,2],[3,4]]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[][]} mat
 * @param {number} r
 * @param {number} c
 * @return {number[][]}
 */</span>
<span>var</span> <span>matrixReshape</span> <span>=</span> <span>function</span> <span>(</span><span>mat<span>,</span> r<span>,</span> c</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>mat<span>[</span><span>0</span><span>]</span><span>.</span>length <span>*</span> mat<span>.</span>length <span>!==</span> r <span>*</span> c<span>)</span> <span>return</span> mat<span>;</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span><span>;</span>
  <span>let</span> item <span>=</span> <span>[</span><span>]</span><span>;</span>
  mat <span>=</span> mat<span>.</span><span>flat</span><span>(</span><span>)</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> mat<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>item<span>.</span>length <span>&lt;</span> c<span>)</span> item<span>.</span><span>push</span><span>(</span>mat<span>[</span>i<span>]</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>item<span>.</span>length <span>===</span> c<span>)</span> <span>{</span>
      res<span>.</span><span>push</span><span>(</span>item<span>)</span><span>;</span>
      item <span>=</span> <span>[</span><span>]</span><span>;</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res<span>;</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><h2 id="_575-分糖果"> 575.分糖果</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=575 lang=javascript
 *
 * [575] 分糖果
 * 
 * Alice 有 n 枚糖，其中第 i 枚糖的类型为 candyType[i] 。Alice 注意到她的体重正在增长，所以前去拜访了一位医生。

医生建议 Alice 要少摄入糖分，只吃掉她所有糖的 n / 2 即可（n 是一个偶数）。Alice 非常喜欢这些糖，她想要在遵循医生建议的情况下，尽可能吃到最多不同种类的糖。

给你一个长度为 n 的整数数组 candyType ，返回： Alice 在仅吃掉 n / 2 枚糖的情况下，可以吃到糖的 最多 种类数。

 

示例 1：

输入：candyType = [1,1,2,2,3,3]
输出：3
解释：Alice 只能吃 6 / 2 = 3 枚糖，由于只有 3 种糖，她可以每种吃一枚。
示例 2：

输入：candyType = [1,1,2,3]
输出：2
解释：Alice 只能吃 4 / 2 = 2 枚糖，不管她选择吃的种类是 [1,2]、[1,3] 还是 [2,3]，她只能吃到两种不同类的糖。
示例 3：

输入：candyType = [6,6,6,6]
输出：1
解释：Alice 只能吃 4 / 2 = 2 枚糖，尽管她能吃 2 枚，但只能吃到 1 种糖。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} candyType
 * @return {number}
 */</span>
<span>var</span> <span>distributeCandies</span> <span>=</span> <span>function</span> <span>(</span><span>candyType</span><span>)</span> <span>{</span>
  <span>const</span> len <span>=</span> candyType<span>.</span>length
  candyType <span>=</span> <span>[</span><span>...</span><span>new</span> <span>Set</span><span>(</span>candyType<span>)</span><span>]</span>
  <span>return</span> Math<span>.</span><span>min</span><span>(</span>len <span>/</span> <span>2</span><span>,</span> candyType<span>.</span>length<span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h2 id="_594-最长和谐子序列"> 594.最长和谐子序列</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=594 lang=javascript
 *
 * [594] 最长和谐子序列
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number}
 */</span>
<span>var</span> <span>findLHS</span> <span>=</span> <span>function</span><span>(</span><span>nums</span><span>)</span> <span>{</span>
  
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="_598-范围求和-ii"> 598.范围求和-ii</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=598 lang=typescript
 *
 * [598] 范围求和 II
 * 
 * 给你一个 m x n 的矩阵 M ，初始化时所有的 0 和一个操作数组 op ，其中 ops[i] = [ai, bi] 意味着当所有的 0 &lt;= x &lt; ai 和 0 &lt;= y &lt; bi 时， M[x][y] 应该加 1。

在 执行完所有操作后 ，计算并返回 矩阵中最大整数的个数 。

 

示例 1:



输入: m = 3, n = 3，ops = [[2,2],[3,3]]
输出: 4
解释: M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。
示例 2:

输入: m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]
输出: 4
示例 3:

输入: m = 3, n = 3, ops = []
输出: 9
 


 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>maxCount</span><span>(</span>m<span>:</span> <span>number</span><span>,</span> n<span>:</span> <span>number</span><span>,</span> ops<span>:</span> <span>number</span><span>[</span><span>]</span><span>[</span><span>]</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>return</span> ops<span>.</span>length <span>===</span> <span>0</span> <span>?</span> m <span>*</span> n <span>:</span> Math<span>.</span><span>min</span><span>(</span><span>...</span>ops<span>.</span><span>map</span><span>(</span>i <span>=></span> i<span>[</span><span>0</span><span>]</span><span>)</span><span>)</span> <span>*</span> Math<span>.</span><span>min</span><span>(</span><span>...</span>ops<span>.</span><span>map</span><span>(</span>i <span>=></span> i<span>[</span><span>1</span><span>]</span><span>)</span><span>)</span><span>;</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><h2 id="_599-两个列表的最小索引总和"> 599.两个列表的最小索引总和</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=599 lang=javascript
 *
 * [599] 两个列表的最小索引总和
 * 
 * 假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。

你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。

 

示例 1:

输入: list1 = ["Shogun", "Tapioca Express", "Burger King", "KFC"]，list2 = ["Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun"]
输出: ["Shogun"]
解释: 他们唯一共同喜爱的餐厅是“Shogun”。
示例 2:

输入:list1 = ["Shogun", "Tapioca Express", "Burger King", "KFC"]，list2 = ["KFC", "Shogun", "Burger King"]
输出: ["Shogun"]
解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string[]} list1
 * @param {string[]} list2
 * @return {string[]}
 */</span>
<span>var</span> <span>findRestaurant</span> <span>=</span> <span>function</span> <span>(</span><span>list1<span>,</span> list2</span><span>)</span> <span>{</span>
  <span>const</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span>
  <span>let</span> min <span>=</span> Number<span>.</span><span>MAX_SAFE_INTEGER</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> list1<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> index <span>=</span> list2<span>.</span><span>indexOf</span><span>(</span>list1<span>[</span>i<span>]</span><span>)</span><span>,</span> item <span>=</span> map<span>.</span><span>get</span><span>(</span>i <span>+</span> index<span>)</span> <span>||</span> <span>[</span><span>]</span>
    <span>if</span> <span>(</span>index <span>></span> <span>-</span><span>1</span><span>)</span> <span>{</span>
      item<span>.</span><span>push</span><span>(</span>list2<span>[</span>index<span>]</span><span>)</span>
      map<span>.</span><span>set</span><span>(</span>i <span>+</span> index<span>,</span> item<span>)</span>
      min <span>=</span> Math<span>.</span><span>min</span><span>(</span>min<span>,</span> i <span>+</span> index<span>)</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> map<span>.</span><span>get</span><span>(</span>min<span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h2 id="_605-种花问题"> 605.种花问题</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=605 lang=typescript
 *
 * [605] 种花问题
 * 
 * 假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

给你一个整数数组  flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。

 

示例 1：

输入：flowerbed = [1,0,0,0,1], n = 1
输出：true
示例 2：

输入：flowerbed = [1,0,0,0,1], n = 2
输出：false
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>canPlaceFlowers</span><span>(</span>flowerbed<span>:</span> <span>number</span><span>[</span><span>]</span><span>,</span> n<span>:</span> <span>number</span><span>)</span><span>:</span> <span>boolean</span> <span>{</span>
  <span>if</span> <span>(</span>n <span>===</span> <span>0</span><span>)</span> <span>return</span> <span>true</span>
  <span>let</span> count<span>:</span> <span>number</span> <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> flowerbed<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>flowerbed<span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>!==</span> <span>1</span> <span>&amp;&amp;</span> flowerbed<span>[</span>i<span>]</span> <span>!==</span> <span>1</span> <span>&amp;&amp;</span> flowerbed<span>[</span>i <span>+</span> <span>1</span><span>]</span> <span>!==</span> <span>1</span><span>)</span> <span>{</span>
      count<span>++</span>
      flowerbed<span>[</span>i<span>]</span> <span>=</span> <span>1</span>
    <span>}</span>
    <span>if</span> <span>(</span>count <span>===</span> n<span>)</span> <span>return</span> <span>true</span>
  <span>}</span>
  <span>return</span> <span>false</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><h2 id="_627-变更性别"> 627.变更性别</h2>
<div><pre><code>
</code></pre>
<div><span>1</span><br></div></div><h2 id="_628-三个数的最大乘积"> 628.三个数的最大乘积</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=628 lang=javascript
 *
 * [628] 三个数的最大乘积
 * 
 * 给你一个整型数组 nums ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。

 

示例 1：

输入：nums = [1,2,3]
输出：6
示例 2：

输入：nums = [1,2,3,4]
输出：24
示例 3：

输入：nums = [-1,-2,-3]
输出：-6
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number}
 */</span>
<span>var</span> <span>maximumProduct</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
  nums <span>=</span> nums<span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a <span>-</span> b<span>)</span>
  <span>const</span> len <span>=</span> nums<span>.</span>length
  <span>return</span> Math<span>.</span><span>max</span><span>(</span>nums<span>[</span>len <span>-</span> <span>1</span><span>]</span> <span>*</span> nums<span>[</span>len <span>-</span> <span>2</span><span>]</span> <span>*</span> nums<span>[</span>len <span>-</span> <span>3</span><span>]</span><span>,</span> nums<span>[</span>len <span>-</span> <span>1</span><span>]</span> <span>*</span> nums<span>[</span><span>0</span><span>]</span> <span>*</span> nums<span>[</span><span>1</span><span>]</span><span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><h2 id="_643-子数组最大平均数-i"> 643.子数组最大平均数-i</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=643 lang=javascript
 *
 * [643] 子数组最大平均数 I
 * 
 * 给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。

请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。

任何误差小于 10-5 的答案都将被视为正确答案。

 

示例 1：

输入：nums = [1,12,-5,-6,50,3], k = 4
输出：12.75
解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75
示例 2：

输入：nums = [5], k = 1
输出：5.00000
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */</span>
<span>var</span> <span>findMaxAverage</span> <span>=</span> <span>function</span> <span>(</span><span>nums<span>,</span> k</span><span>)</span> <span>{</span>
  <span>let</span> max <span>=</span> nums<span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span> k<span>)</span><span>.</span><span>reduce</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a <span>+</span> b<span>,</span> <span>0</span><span>)</span> <span>/</span> k<span>,</span> curr <span>=</span> max
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> k<span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    curr <span>+=</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>-</span> nums<span>[</span>i <span>-</span> k<span>]</span><span>)</span> <span>/</span> k
    max <span>=</span> Math<span>.</span><span>max</span><span>(</span>max<span>,</span> curr<span>)</span>
  <span>}</span>
  <span>return</span> max
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h2 id="_645-错误的集合"> 645.错误的集合</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=645 lang=typescript
 *
 * [645] 错误的集合
 * 
 * 集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。

给定一个数组 nums 代表了集合 S 发生错误后的结果。

请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。

 

示例 1：

输入：nums = [1,2,2,4]
输出：[2,3]
示例 2：

输入：nums = [1,1]
输出：[1,2]
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>findErrorNums</span><span>(</span>nums<span>:</span> <span>number</span><span>[</span><span>]</span><span>)</span> <span>{</span>
  nums<span>.</span><span>sort</span><span>(</span><span>(</span>a<span>,</span> b<span>)</span> <span>=></span> a <span>-</span> b<span>)</span>
  <span>const</span> nums1 <span>=</span> <span>[</span><span>...</span><span>new</span> <span>Set</span><span>(</span>nums<span>)</span><span>]</span><span>,</span> res<span>:</span> <span>number</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>res<span>[</span><span>0</span><span>]</span> <span>&amp;&amp;</span> nums<span>[</span>i<span>]</span> <span>!==</span> nums1<span>[</span>i<span>]</span><span>)</span> res<span>[</span><span>0</span><span>]</span> <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
    <span>if</span> <span>(</span><span>!</span>res<span>[</span><span>1</span><span>]</span> <span>&amp;&amp;</span> i <span>+</span> <span>1</span> <span>!==</span> nums1<span>[</span>i<span>]</span><span>)</span> res<span>[</span><span>1</span><span>]</span> <span>=</span> i <span>+</span> <span>1</span>
    <span>if</span> <span>(</span>res<span>[</span><span>0</span><span>]</span> <span>&amp;&amp;</span> res<span>[</span><span>1</span><span>]</span><span>)</span> <span>break</span><span>;</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><h2 id="_657-机器人能否返回原点"> 657.机器人能否返回原点</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=657 lang=javascript
 *
 * [657] 机器人能否返回原点
 * 
 * 在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。

移动顺序由字符串 moves 表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。

如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。

注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。

 

示例 1:

输入: moves = "UD"
输出: true
解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。
示例 2:

输入: moves = "LL"
输出: false
解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} moves
 * @return {boolean}
 */</span>
<span>var</span> <span>judgeCircle</span> <span>=</span> <span>function</span> <span>(</span><span>moves</span><span>)</span> <span>{</span>
  <span>const</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> moves<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>map<span>.</span><span>has</span><span>(</span>moves<span>[</span>i<span>]</span><span>)</span><span>)</span> map<span>.</span><span>set</span><span>(</span>moves<span>[</span>i<span>]</span><span>,</span> <span>0</span><span>)</span>
    <span>else</span> map<span>.</span><span>set</span><span>(</span>moves<span>[</span>i<span>]</span><span>,</span> map<span>.</span><span>get</span><span>(</span>moves<span>[</span>i<span>]</span><span>)</span> <span>+</span> <span>1</span><span>)</span>
  <span>}</span>
  <span>return</span> map<span>.</span><span>get</span><span>(</span><span>"U"</span><span>)</span> <span>===</span> map<span>.</span><span>get</span><span>(</span><span>"D"</span><span>)</span> <span>&amp;&amp;</span> map<span>.</span><span>get</span><span>(</span><span>"L"</span><span>)</span> <span>===</span> map<span>.</span><span>get</span><span>(</span><span>"R"</span><span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h2 id="_661-图片平滑器"> 661.图片平滑器</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=661 lang=typescript
 *
 * [661] 图片平滑器
 * 
 * 图像平滑器 是大小为 3 x 3 的过滤器，用于对图像的每个单元格平滑处理，平滑处理后单元格的值为该单元格的平均灰度。

每个单元格的  平均灰度 定义为：该单元格自身及其周围的 8 个单元格的平均值，结果需向下取整。（即，需要计算蓝色平滑器中 9 个单元格的平均值）。

如果一个单元格周围存在单元格缺失的情况，则计算平均灰度时不考虑缺失的单元格（即，需要计算红色平滑器中 4 个单元格的平均值）。



给你一个表示图像灰度的 m x n 整数矩阵 img ，返回对图像的每个单元格平滑处理后的图像 。

 

示例 1:



输入:img = [[1,1,1],[1,0,1],[1,1,1]]
输出:[[0, 0, 0],[0, 0, 0], [0, 0, 0]]
解释:
对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0
对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0
对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0
示例 2:


输入: img = [[100,200,100],[200,50,200],[100,200,100]]
输出: [[137,141,137],[141,138,141],[137,141,137]]
解释:
对于点 (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137
对于点 (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141
对于点 (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>imageSmoother</span><span>(</span>img<span>:</span> <span>number</span><span>[</span><span>]</span><span>[</span><span>]</span><span>)</span><span>:</span> <span>number</span><span>[</span><span>]</span><span>[</span><span>]</span> <span>{</span>
  <span>const</span> res<span>:</span><span>number</span><span>[</span><span>]</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>]</span><span>;</span>
  <span>let</span> r <span>=</span> img<span>.</span>length<span>,</span>
    c <span>=</span> img<span>[</span><span>0</span><span>]</span><span>.</span>length<span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> r<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    res<span>.</span><span>push</span><span>(</span><span>[</span><span>]</span><span>)</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> c<span>;</span> j<span>++</span><span>)</span> <span>{</span>
      <span>let</span> sum <span>=</span> img<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>;</span>
      <span>let</span> cnt <span>=</span> <span>1</span><span>;</span>
      <span>if</span> <span>(</span>i <span>></span> <span>0</span><span>)</span> <span>(</span>sum <span>+=</span> img<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j<span>]</span><span>)</span><span>,</span> cnt<span>++</span><span>;</span>
      <span>if</span> <span>(</span>i <span>&lt;</span> r <span>-</span> <span>1</span><span>)</span> <span>(</span>sum <span>+=</span> img<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>[</span>j<span>]</span><span>)</span><span>,</span> cnt<span>++</span><span>;</span>
      <span>if</span> <span>(</span>j <span>></span> <span>0</span><span>)</span> <span>(</span>sum <span>+=</span> img<span>[</span>i<span>]</span><span>[</span>j <span>-</span> <span>1</span><span>]</span><span>)</span><span>,</span> cnt<span>++</span><span>;</span>
      <span>if</span> <span>(</span>j <span>&lt;</span> c <span>-</span> <span>1</span><span>)</span> <span>(</span>sum <span>+=</span> img<span>[</span>i<span>]</span><span>[</span>j <span>+</span> <span>1</span><span>]</span><span>)</span><span>,</span> cnt<span>++</span><span>;</span>
      <span>if</span> <span>(</span>i <span>></span> <span>0</span> <span>&amp;&amp;</span> j <span>></span> <span>0</span><span>)</span> <span>(</span>sum <span>+=</span> img<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j <span>-</span> <span>1</span><span>]</span><span>)</span><span>,</span> cnt<span>++</span><span>;</span>
      <span>if</span> <span>(</span>i <span>></span> <span>0</span> <span>&amp;&amp;</span> j <span>&lt;</span> c <span>-</span> <span>1</span><span>)</span> <span>(</span>sum <span>+=</span> img<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j <span>+</span> <span>1</span><span>]</span><span>)</span><span>,</span> cnt<span>++</span><span>;</span>
      <span>if</span> <span>(</span>i <span>&lt;</span> r <span>-</span> <span>1</span> <span>&amp;&amp;</span> j <span>></span> <span>0</span><span>)</span> <span>(</span>sum <span>+=</span> img<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>[</span>j <span>-</span> <span>1</span><span>]</span><span>)</span><span>,</span> cnt<span>++</span><span>;</span>
      <span>if</span> <span>(</span>i <span>&lt;</span> r <span>-</span> <span>1</span> <span>&amp;&amp;</span> j <span>&lt;</span> c <span>-</span> <span>1</span><span>)</span> <span>(</span>sum <span>+=</span> img<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>[</span>j <span>+</span> <span>1</span><span>]</span><span>)</span><span>,</span> cnt<span>++</span><span>;</span>
      res<span>[</span>i<span>]</span><span>.</span><span>push</span><span>(</span>Math<span>.</span><span>floor</span><span>(</span>sum <span>/</span> cnt<span>)</span><span>)</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res<span>;</span>
<span>}</span>
<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br></div></div><h2 id="_674-最长连续递增序列"> 674.最长连续递增序列</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=674 lang=javascript
 *
 * [674] 最长连续递增序列
 * 
 * 给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。

连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

 

示例 1：

输入：nums = [1,3,5,4,7]
输出：3
解释：最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 
示例 2：

输入：nums = [2,2,2,2,2]
输出：1
解释：最长连续递增序列是 [2], 长度为1。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number}
 */</span>
<span>var</span> <span>findLengthOfLCIS</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
  <span>let</span> arr <span>=</span> <span>[</span>nums<span>[</span><span>0</span><span>]</span><span>]</span><span>,</span> len <span>=</span> <span>1</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>&lt;=</span> arr<span>[</span>arr<span>.</span>length <span>-</span> <span>1</span><span>]</span><span>)</span> arr <span>=</span> <span>[</span><span>]</span><span>;</span>
    arr<span>.</span><span>push</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span><span>;</span>
    len <span>=</span> Math<span>.</span><span>max</span><span>(</span>len<span>,</span> arr<span>.</span>length<span>)</span><span>;</span>
  <span>}</span>
  <span>return</span> len<span>;</span>
<span>}</span><span>;</span>

<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><h2 id="_680-验证回文字符串-ii"> 680.验证回文字符串-ⅱ</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=680 lang=typescript
 *
 * [680] 验证回文字符串 Ⅱ
 * 
 * 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。

 

示例 1:

输入: s = "aba"
输出: true
示例 2:

输入: s = "abca"
输出: true
解释: 你可以删除c字符。
示例 3:

输入: s = "abc"
输出: false
 
 */</span>

<span>// @lc code=start</span>

<span>function</span> <span>validPalindrome</span><span>(</span>s<span>:</span> <span>string</span><span>,</span> canDelete<span>:</span> <span>boolean</span> <span>=</span> <span>true</span><span>)</span><span>:</span> <span>boolean</span> <span>{</span>
  <span>for</span> <span>(</span><span>let</span> left <span>=</span> <span>0</span><span>,</span> right <span>=</span> s<span>.</span>length <span>-</span> <span>1</span><span>;</span> left <span>&lt;</span> right<span>;</span> left<span>++</span><span>,</span> right<span>--</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>s<span>[</span>left<span>]</span> <span>!==</span> s<span>[</span>right<span>]</span><span>)</span> <span>return</span> canDelete <span>&amp;&amp;</span> <span>(</span><span>validPalindrome</span><span>(</span>s<span>.</span><span>slice</span><span>(</span>left <span>+</span> <span>1</span><span>,</span> right <span>+</span> <span>1</span><span>)</span><span>,</span> <span>false</span><span>)</span> <span>||</span> <span>validPalindrome</span><span>(</span>s<span>.</span><span>slice</span><span>(</span>left<span>,</span> right<span>)</span><span>,</span> <span>false</span><span>)</span><span>)</span><span>;</span>
  <span>}</span>
  <span>return</span> <span>true</span><span>;</span>
<span>}</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><h2 id="_682-棒球比赛"> 682.棒球比赛</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=682 lang=javascript
 *
 * [682] 棒球比赛
 * 
 * 你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。

比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：

整数 x - 表示本回合新获得分数 x
"+" - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。
"D" - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。
"C" - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。
请你返回记录中所有得分的总和。

 

示例 1：

输入：ops = ["5","2","C","D","+"]
输出：30
解释：
"5" - 记录加 5 ，记录现在是 [5]
"2" - 记录加 2 ，记录现在是 [5, 2]
"C" - 使前一次得分的记录无效并将其移除，记录现在是 [5].
"D" - 记录加 2 * 5 = 10 ，记录现在是 [5, 10].
"+" - 记录加 5 + 10 = 15 ，记录现在是 [5, 10, 15].
所有得分的总和 5 + 10 + 15 = 30
示例 2：

输入：ops = ["5","-2","4","C","D","9","+","+"]
输出：27
解释：
"5" - 记录加 5 ，记录现在是 [5]
"-2" - 记录加 -2 ，记录现在是 [5, -2]
"4" - 记录加 4 ，记录现在是 [5, -2, 4]
"C" - 使前一次得分的记录无效并将其移除，记录现在是 [5, -2]
"D" - 记录加 2 * -2 = -4 ，记录现在是 [5, -2, -4]
"9" - 记录加 9 ，记录现在是 [5, -2, -4, 9]
"+" - 记录加 -4 + 9 = 5 ，记录现在是 [5, -2, -4, 9, 5]
"+" - 记录加 9 + 5 = 14 ，记录现在是 [5, -2, -4, 9, 5, 14]
所有得分的总和 5 + -2 + -4 + 9 + 5 + 14 = 27
示例 3：

输入：ops = ["1"]
输出：1
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string[]} ops
 * @return {number}
 */</span>
<span>var</span> <span>calPoints</span> <span>=</span> <span>function</span> <span>(</span><span>ops</span><span>)</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>0</span><span>,</span> arr <span>=</span> <span>[</span><span>]</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> ops<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>let</span> item <span>=</span> <span>0</span><span>;</span>
    <span>if</span> <span>(</span>ops<span>[</span>i<span>]</span> <span>===</span> <span>'+'</span><span>)</span> item <span>=</span> arr<span>[</span>arr<span>.</span>length <span>-</span> <span>1</span><span>]</span> <span>+</span> arr<span>[</span>arr<span>.</span>length <span>-</span> <span>2</span><span>]</span><span>;</span>
    <span>else</span> <span>if</span> <span>(</span>ops<span>[</span>i<span>]</span> <span>===</span> <span>'D'</span><span>)</span> item <span>=</span> arr<span>[</span>arr<span>.</span>length <span>-</span> <span>1</span><span>]</span> <span>*</span> <span>2</span><span>;</span>
    <span>else</span> <span>if</span> <span>(</span>ops<span>[</span>i<span>]</span> <span>===</span> <span>'C'</span><span>)</span> <span>{</span>
      <span>const</span> del <span>=</span> arr<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>
      res <span>-=</span> <span>Number</span><span>(</span>del<span>)</span><span>;</span>
      <span>continue</span>
    <span>}</span> <span>else</span> item <span>=</span> <span>Number</span><span>(</span>ops<span>[</span>i<span>]</span><span>)</span><span>;</span>
    arr<span>.</span><span>push</span><span>(</span>item<span>)</span><span>;</span>
    res <span>+=</span> item<span>;</span>
  <span>}</span>
  <span>return</span> res<span>;</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br></div></div><h2 id="_693-交替位二进制数"> 693.交替位二进制数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=693 lang=typescript
 *
 * [693] 交替位二进制数
 * 
 * 给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。

 

示例 1：

输入：n = 5
输出：true
解释：5 的二进制表示是：101
示例 2：

输入：n = 7
输出：false
解释：7 的二进制表示是：111.
示例 3：

输入：n = 11
输出：false
解释：11 的二进制表示是：1011.
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>hasAlternatingBits</span><span>(</span>n<span>:</span> <span>number</span><span>)</span><span>:</span> <span>boolean</span> <span>{</span>
  <span>const</span> n2 <span>=</span> n<span>.</span><span>toString</span><span>(</span><span>2</span><span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n2<span>.</span>length<span>;</span> i <span>+=</span> <span>2</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>n2<span>[</span>i<span>]</span> <span>===</span> <span>"0"</span> <span>||</span> n2<span>[</span>i <span>+</span> <span>1</span><span>]</span> <span>===</span> <span>"1"</span><span>)</span> <span>return</span> <span>false</span>
  <span>}</span>
  <span>return</span> <span>true</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><h2 id="_696-计数二进制子串"> 696.计数二进制子串</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=696 lang=typescript
 *
 * [696] 计数二进制子串
 * 
 * 给定一个字符串 s，统计并返回具有相同数量 0 和 1 的非空（连续）子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是成组连续的。

重复出现（不同位置）的子串也要统计它们出现的次数。

 
示例 1：

输入：s = "00110011"
输出：6
解释：6 个子串满足具有相同数量的连续 1 和 0 ："0011"、"01"、"1100"、"10"、"0011" 和 "01" 。
注意，一些重复出现的子串（不同位置）要统计它们出现的次数。
另外，"00110011" 不是有效的子串，因为所有的 0（还有 1 ）没有组合在一起。
示例 2：

输入：s = "10101"
输出：4
解释：有 4 个子串："10"、"01"、"10"、"01" ，具有相同数量的连续 1 和 0 。
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>countBinarySubstrings</span><span>(</span>s<span>:</span> <span>string</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>0</span><span>,</span>
    left <span>=</span> <span>1</span><span>,</span>
    right <span>=</span> <span>0</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> s<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>right <span>===</span> <span>0</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>s<span>[</span>i<span>]</span> <span>===</span> s<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span> <span>{</span>
        left<span>++</span><span>;</span>
      <span>}</span> <span>else</span> <span>{</span>
        right<span>++</span><span>;</span>
      <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>if</span> <span>(</span>s<span>[</span>i<span>]</span> <span>===</span> s<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span> <span>{</span>
        right<span>++</span><span>;</span>
      <span>}</span> <span>else</span> <span>{</span>
        res <span>+=</span> Math<span>.</span><span>min</span><span>(</span>left<span>,</span> right<span>)</span><span>;</span>
        left <span>=</span> right<span>;</span>
        right <span>=</span> <span>1</span><span>;</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  res <span>+=</span> Math<span>.</span><span>min</span><span>(</span>left<span>,</span> right<span>)</span><span>;</span>
  <span>return</span> res<span>;</span>
<span>}</span>
<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><h2 id="_697-数组的度"> 697.数组的度</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=697 lang=typescript
 *
 * [697] 数组的度
 * 
 * 给定一个非空且只包含非负数的整数数组 nums，数组的 度 的定义是指数组里任一元素出现频数的最大值。

你的任务是在 nums 中找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。

 

示例 1：

输入：nums = [1,2,2,3,1]
输出：2
解释：
输入数组的度是 2 ，因为元素 1 和 2 的出现频数最大，均为 2 。
连续子数组里面拥有相同度的有如下所示：
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
最短连续子数组 [2, 2] 的长度为 2 ，所以返回 2 。
示例 2：

输入：nums = [1,2,2,3,1,4,2]
输出：6
解释：
数组的度是 3 ，因为元素 2 重复出现 3 次。
所以 [2,2,3,1,4,2] 是最短子数组，因此返回 6 。
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>findShortestSubArray</span><span>(</span>nums<span>:</span> <span>number</span><span>[</span><span>]</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>const</span> map1 <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>,</span>
    map2 <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>,</span>
    map3 <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>;</span>
  <span>let</span> res <span>=</span> Number<span>.</span><span>MAX_VALUE</span><span>,</span>max <span>=</span> <span>0</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>map1<span>.</span><span>has</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span><span>)</span> <span>{</span>
      map1<span>.</span><span>set</span><span>(</span>nums<span>[</span>i<span>]</span><span>,</span> <span>1</span><span>)</span><span>;</span>
      map2<span>.</span><span>set</span><span>(</span>nums<span>[</span>i<span>]</span><span>,</span> i<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      map1<span>.</span><span>set</span><span>(</span>nums<span>[</span>i<span>]</span><span>,</span> map1<span>.</span><span>get</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>
    map3<span>.</span><span>set</span><span>(</span>nums<span>[</span>i<span>]</span><span>,</span> i<span>)</span><span>;</span>
    max <span>=</span> Math<span>.</span><span>max</span><span>(</span>max<span>,</span>map1<span>.</span><span>get</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span><span>)</span>
  <span>}</span>
  <span>const</span> arr<span>:</span><span>any</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>const</span> <span>[</span>k<span>,</span>v<span>]</span> <span>of</span> map1<span>.</span><span>entries</span><span>(</span><span>)</span><span>)</span> <span>{</span>
    <span>if</span><span>(</span>v<span>===</span>max<span>)</span> arr<span>.</span><span>push</span><span>(</span>k<span>)</span>
  <span>}</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    res <span>=</span> Math<span>.</span><span>min</span><span>(</span>res<span>,</span>map3<span>.</span><span>get</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span><span>-</span>map2<span>.</span><span>get</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span><span>+</span><span>1</span><span>)</span>
  <span>}</span>
  <span>return</span> res<span>;</span>
<span>}</span>
<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div><h2 id="_703-数据流中的第-k-大元素"> 703.数据流中的第-k-大元素</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=703 lang=typescript
 *
 * [703] 数据流中的第 K 大元素
 * 
 * 设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。

请实现 KthLargest 类：

KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。
int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。
 

示例：

输入：
["KthLargest", "add", "add", "add", "add", "add"]
[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]
输出：
[null, 4, 5, 5, 8, 8]

解释：
KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);
kthLargest.add(3);   // return 4
kthLargest.add(5);   // return 5
kthLargest.add(10);  // return 5
kthLargest.add(9);   // return 8
kthLargest.add(4);   // return 8
 
 */</span>

<span>// @lc code=start</span>
<span>class</span> <span>KthLargest</span> <span>{</span>
    nums<span>:</span><span>number</span><span>[</span><span>]</span><span>;</span>
    k<span>:</span><span>number</span><span>;</span>
    <span>constructor</span><span>(</span>k<span>:</span> <span>number</span><span>,</span> nums<span>:</span> <span>number</span><span>[</span><span>]</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>nums <span>=</span> nums<span>;</span>
      <span>this</span><span>.</span>k <span>=</span> k<span>;</span>
    <span>}</span>
    <span>add</span><span>(</span>val<span>:</span> <span>number</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
      <span>this</span><span>.</span>nums <span>=</span> <span>[</span><span>...</span><span>this</span><span>.</span>nums<span>,</span>val<span>]</span><span>.</span><span>sort</span><span>(</span><span>(</span>a<span>,</span>b<span>)</span><span>=></span>b<span>-</span>a<span>)</span><span>;</span>
      <span>return</span> <span>this</span><span>.</span>nums<span>[</span><span>this</span><span>.</span>k<span>-</span><span>1</span><span>]</span>
    <span>}</span>
<span>}</span>

<span>/**
 * Your KthLargest object will be instantiated and called as such:
 * var obj = new KthLargest(k, nums)
 * var param_1 = obj.add(val)
 */</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><h2 id="_704-二分查找"> 704.二分查找</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=704 lang=javascript
 *
 * [704] 二分查找
 * 
 * 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。


示例 1:

输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
示例 2:

输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
 


 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */</span>

<span>var</span> <span>search</span> <span>=</span> <span>function</span> <span>(</span><span>nums<span>,</span> target</span><span>)</span> <span>{</span>
  <span>let</span> start <span>=</span> <span>0</span><span>,</span>
    end <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>
  <span>if</span> <span>(</span>nums<span>[</span>start<span>]</span> <span>===</span> target<span>)</span> <span>return</span> start<span>;</span>
  <span>if</span> <span>(</span>nums<span>[</span>end<span>]</span> <span>===</span> target<span>)</span> <span>return</span> end<span>;</span>
  <span>while</span> <span>(</span>start <span>!==</span> end<span>)</span> <span>{</span>
    <span>const</span> mid <span>=</span> start <span>+</span> Math<span>.</span><span>floor</span><span>(</span><span>(</span>end <span>-</span> start <span>+</span> <span>1</span><span>)</span> <span>/</span> <span>2</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>nums<span>[</span>mid<span>]</span> <span>></span> target<span>)</span> end <span>=</span> mid <span>-</span> <span>1</span><span>;</span>
    <span>else</span> <span>if</span> <span>(</span>nums<span>[</span>mid<span>]</span> <span>&lt;</span> target<span>)</span> start <span>=</span> mid<span>;</span>
    <span>else</span> <span>return</span> mid<span>;</span>
  <span>}</span>
  <span>return</span> <span>-</span><span>1</span><span>;</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h2 id="_705-设计哈希集合"> 705.设计哈希集合</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=705 lang=javascript
 *
 * [705] 设计哈希集合
 * 
 * 不使用任何内建的哈希表库设计一个哈希集合（HashSet）。

实现 MyHashSet 类：

void add(key) 向哈希集合中插入值 key 。
bool contains(key) 返回哈希集合中是否存在这个值 key 。
void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。
 
示例：

输入：
["MyHashSet", "add", "add", "contains", "contains", "add", "contains", "remove", "contains"]
[[], [1], [2], [1], [3], [2], [2], [2], [2]]
输出：
[null, null, null, true, false, null, true, null, false]

解释：
MyHashSet myHashSet = new MyHashSet();
myHashSet.add(1);      // set = [1]
myHashSet.add(2);      // set = [1, 2]
myHashSet.contains(1); // 返回 True
myHashSet.contains(3); // 返回 False ，（未找到）
myHashSet.add(2);      // set = [1, 2]
myHashSet.contains(2); // 返回 True
myHashSet.remove(2);   // set = [1]
myHashSet.contains(2); // 返回 False ，（已移除）
 


 */</span>

<span>// @lc code=start</span>

<span>var</span> <span>MyHashSet</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span>set <span>=</span> <span>{</span><span>}</span>
<span>}</span><span>;</span>

<span>/** 
 * @param {number} key
 * @return {void}
 */</span>
<span>MyHashSet</span><span>.</span>prototype<span>.</span><span>add</span> <span>=</span> <span>function</span> <span>(</span><span>key</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span>set<span>[</span>key<span>]</span> <span>=</span> <span>true</span>
<span>}</span><span>;</span>

<span>/** 
 * @param {number} key
 * @return {void}
 */</span>
<span>MyHashSet</span><span>.</span>prototype<span>.</span><span>remove</span> <span>=</span> <span>function</span> <span>(</span><span>key</span><span>)</span> <span>{</span>
  <span>delete</span> <span>this</span><span>.</span>set<span>[</span>key<span>]</span>
<span>}</span><span>;</span>

<span>/** 
 * @param {number} key
 * @return {boolean}
 */</span>
<span>MyHashSet</span><span>.</span>prototype<span>.</span><span>contains</span> <span>=</span> <span>function</span> <span>(</span><span>key</span><span>)</span> <span>{</span>
  <span>return</span> <span>this</span><span>.</span>set<span>[</span>key<span>]</span> <span>||</span> <span>false</span>
<span>}</span><span>;</span>

<span>/**
 * Your MyHashSet object will be instantiated and called as such:
 * var obj = new MyHashSet()
 * obj.add(key)
 * obj.remove(key)
 * var param_3 = obj.contains(key)
 */</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br></div></div><h2 id="_706-设计哈希映射"> 706.设计哈希映射</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=706 lang=javascript
 *
 * [706] 设计哈希映射
 * 
 * 不使用任何内建的哈希表库设计一个哈希映射（HashMap）。

实现 MyHashMap 类：

MyHashMap() 用空映射初始化对象
void put(int key, int value) 向 HashMap 插入一个键值对 (key, value) 。如果 key 已经存在于映射中，则更新其对应的值 value 。
int get(int key) 返回特定的 key 所映射的 value ；如果映射中不包含 key 的映射，返回 -1 。
void remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value 。
 

示例：

输入：
["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"]
[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]
输出：
[null, null, null, 1, -1, null, 1, null, -1]

解释：
MyHashMap myHashMap = new MyHashMap();
myHashMap.put(1, 1); // myHashMap 现在为 [[1,1]]
myHashMap.put(2, 2); // myHashMap 现在为 [[1,1], [2,2]]
myHashMap.get(1);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,2]]
myHashMap.get(3);    // 返回 -1（未找到），myHashMap 现在为 [[1,1], [2,2]]
myHashMap.put(2, 1); // myHashMap 现在为 [[1,1], [2,1]]（更新已有的值）
myHashMap.get(2);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,1]]
myHashMap.remove(2); // 删除键为 2 的数据，myHashMap 现在为 [[1,1]]
myHashMap.get(2);    // 返回 -1（未找到），myHashMap 现在为 [[1,1]]
 
 */</span>

<span>// @lc code=start</span>

<span>var</span> <span>MyHashMap</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span>map <span>=</span> <span>{</span><span>}</span>
<span>}</span><span>;</span>

<span>/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */</span>
<span>MyHashMap</span><span>.</span>prototype<span>.</span><span>put</span> <span>=</span> <span>function</span> <span>(</span><span>key<span>,</span> value</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span>map<span>[</span>key<span>]</span> <span>=</span> value
<span>}</span><span>;</span>

<span>/** 
 * @param {number} key
 * @return {number}
 */</span>
<span>MyHashMap</span><span>.</span>prototype<span>.</span><span>get</span> <span>=</span> <span>function</span> <span>(</span><span>key</span><span>)</span> <span>{</span>
  <span>return</span> <span>this</span><span>.</span>map<span>[</span>key<span>]</span> <span>||</span> <span>this</span><span>.</span>map<span>[</span>key<span>]</span> <span>===</span> <span>0</span> <span>?</span> <span>this</span><span>.</span>map<span>[</span>key<span>]</span> <span>:</span> <span>-</span><span>1</span>
<span>}</span><span>;</span>

<span>/** 
 * @param {number} key
 * @return {void}
 */</span>
<span>MyHashMap</span><span>.</span>prototype<span>.</span><span>remove</span> <span>=</span> <span>function</span> <span>(</span><span>key</span><span>)</span> <span>{</span>
  <span>delete</span> <span>this</span><span>.</span>map<span>[</span>key<span>]</span>
<span>}</span><span>;</span>

<span>/**
 * Your MyHashMap object will be instantiated and called as such:
 * var obj = new MyHashMap()
 * obj.put(key,value)
 * var param_2 = obj.get(key)
 * obj.remove(key)
 */</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br></div></div><h2 id="_709-转换成小写字母"> 709.转换成小写字母</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=709 lang=javascript
 *
 * [709] 转换成小写字母
 * 
 * 给你一个字符串 s ，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。

 

示例 1：

输入：s = "Hello"
输出："hello"
示例 2：

输入：s = "here"
输出："here"
示例 3：

输入：s = "LOVELY"
输出："lovely"
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @return {string}
 */</span>
<span>var</span> <span>toLowerCase</span> <span>=</span> <span>function</span> <span>(</span><span>s</span><span>)</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>""</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    res <span>+=</span> <span><span>/</span><span>[A-Z]</span><span>/</span></span><span>.</span><span>test</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span> <span>?</span> s<span>[</span>i<span>]</span><span>.</span><span>toLocaleLowerCase</span><span>(</span><span>)</span> <span>:</span> s<span>[</span>i<span>]</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><h2 id="_717-1-比特与-2-比特字符"> 717.1-比特与-2-比特字符</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=717 lang=typescript

有两种特殊字符：

第一种字符可以用一比特 0 表示
第二种字符可以用两比特（10 或 11）表示
给你一个以 0 结尾的二进制数组 bits ，如果最后一个字符必须是一个一比特字符，则返回 true 。

 

示例 1:

输入: bits = [1, 0, 0]
输出: true
解释: 唯一的解码方式是将其解析为一个两比特字符和一个一比特字符。
所以最后一个字符是一比特字符。
示例 2:

输入：bits = [1,1,1,0]
输出：false
解释：唯一的解码方式是将其解析为两比特字符和两比特字符。
所以最后一个字符不是一比特字符。
 
 *
 * [717] 1 比特与 2 比特字符
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>isOneBitCharacter</span><span>(</span>bits<span>:</span> <span>number</span><span>[</span><span>]</span><span>)</span><span>:</span> <span>boolean</span> <span>{</span>
  <span>while</span> <span>(</span>bits<span>.</span>length <span>></span> <span>1</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>bits<span>[</span><span>0</span><span>]</span> <span>===</span> <span>1</span><span>)</span> <span>{</span>
      bits<span>.</span><span>shift</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    bits<span>.</span><span>shift</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>
  <span>return</span> bits<span>.</span>length <span>===</span> <span>1</span>
<span>}</span>
<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><h2 id="_724-寻找数组的中心下标"> 724.寻找数组的中心下标</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=724 lang=javascript
 *
 * [724] 寻找数组的中心下标
 * 
 * 给你一个整数数组 nums ，请计算数组的 中心下标 。

数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。

如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。

如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。

 

示例 1：

输入：nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
中心下标是 3 。
左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，
右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。
示例 2：

输入：nums = [1, 2, 3]
输出：-1
解释：
数组中不存在满足此条件的中心下标。
示例 3：

输入：nums = [2, 1, -1]
输出：0
解释：
中心下标是 0 。
左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），
右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number}
 */</span>
<span>var</span> <span>pivotIndex</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
  <span>let</span> left <span>=</span> <span>0</span><span>,</span> right <span>=</span> nums<span>.</span><span>reduce</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a <span>+</span> b<span>,</span> <span>-</span>nums<span>[</span><span>0</span><span>]</span><span>)</span>
  <span>if</span> <span>(</span>left <span>===</span> right<span>)</span> <span>return</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    left <span>+=</span> nums<span>[</span>i <span>-</span> <span>1</span><span>]</span>
    right <span>-=</span> nums<span>[</span>i<span>]</span>
    <span>if</span> <span>(</span>left <span>===</span> right<span>)</span> <span>return</span> i
  <span>}</span>
  <span>return</span> <span>-</span><span>1</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div><h2 id="_728-自除数"> 728.自除数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=728 lang=javascript
 *
 * [728] 自除数
 * 
 * 自除数 是指可以被它包含的每一位数整除的数。

例如，128 是一个 自除数 ，因为 128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。
自除数 不允许包含 0 。

给定两个整数 left 和 right ，返回一个列表，列表的元素是范围 [left, right] 内所有的 自除数 。

 

示例 1：

输入：left = 1, right = 22
输出：[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]
示例 2:

输入：left = 47, right = 85
输出：[48,55,66,77]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} left
 * @param {number} right
 * @return {number[]}
 */</span>
<span>var</span> <span>selfDividingNumbers</span> <span>=</span> <span>function</span> <span>(</span><span>left<span>,</span> right</span><span>)</span> <span>{</span>
  <span>const</span> arr <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> left<span>;</span> i <span>&lt;=</span> right<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> str <span>=</span> i<span>.</span><span>toString</span><span>(</span><span>)</span>
    <span>let</span> flag <span>=</span> <span>true</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> str<span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
      <span>const</span> item <span>=</span> <span>Number</span><span>(</span>str<span>[</span>j<span>]</span><span>)</span>
      <span>if</span> <span>(</span>item <span>===</span> <span>0</span> <span>||</span> i <span>%</span> item <span>!==</span> <span>0</span><span>)</span> flag <span>=</span> <span>false</span>
    <span>}</span>
    <span>if</span> <span>(</span>flag<span>)</span> arr<span>.</span><span>push</span><span>(</span>i<span>)</span>
  <span>}</span>
  <span>return</span> arr
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><h2 id="_733-图像渲染"> 733.图像渲染</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=733 lang=typescript

有一幅以 m x n 的二维整数数组表示的图画 image ，其中 image[i][j] 表示该图画的像素值大小。

你也被给予三个整数 sr ,  sc 和 newColor 。你应该从像素 image[sr][sc] 开始对图像进行 上色填充 。

为了完成 上色工作 ，从初始像素开始，记录初始坐标的 上下左右四个方向上 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 四个方向上 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为 newColor 。

最后返回 经过上色渲染后的图像 。

 

示例 1:



输入: image = [[1,1,1],[1,1,0],[1,0,1]]，sr = 1, sc = 1, newColor = 2
输出: [[2,2,2],[2,2,0],[2,0,1]]
解析: 在图像的正中间，(坐标(sr,sc)=(1,1)),在路径上所有符合条件的像素点的颜色都被更改成2。
注意，右下角的像素没有更改为2，因为它不是在上下左右四个方向上与初始点相连的像素点。
示例 2:

输入: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 2
输出: [[2,2,2],[2,2,2]]
 
 *
 * [733] 图像渲染
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>floodFill</span><span>(</span>
  image<span>:</span> <span>number</span><span>[</span><span>]</span><span>[</span><span>]</span><span>,</span>
  sr<span>:</span> <span>number</span><span>,</span>
  sc<span>:</span> <span>number</span><span>,</span>
  color<span>:</span> <span>number</span>
<span>)</span><span>:</span> <span>number</span><span>[</span><span>]</span><span>[</span><span>]</span> <span>{</span>
  <span>const</span> arr<span>:</span> <span>any</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>]</span><span>,</span>
    l <span>=</span> image<span>[</span>sr<span>]</span><span>[</span>sc<span>]</span><span>;</span>
  <span>if</span> <span>(</span>l <span>===</span> color<span>)</span> <span>return</span> image<span>;</span>
  arr<span>.</span><span>push</span><span>(</span><span>{</span> sr<span>,</span> sc <span>}</span><span>)</span><span>;</span>
  image<span>[</span>sr<span>]</span><span>[</span>sc<span>]</span> <span>=</span> color<span>;</span>
  <span>while</span> <span>(</span>arr<span>.</span>length <span>></span> <span>0</span><span>)</span> <span>{</span>
    <span>const</span> node <span>=</span> arr<span>.</span><span>shift</span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>image<span>[</span>node<span>.</span>sr<span>]</span><span>[</span>node<span>.</span>sc <span>-</span> <span>1</span><span>]</span> <span>===</span> l<span>)</span> <span>{</span>
      image<span>[</span>node<span>.</span>sr<span>]</span><span>[</span>node<span>.</span>sc <span>-</span> <span>1</span><span>]</span> <span>=</span> color<span>;</span>
      arr<span>.</span><span>push</span><span>(</span><span>{</span> sr<span>:</span> node<span>.</span>sr<span>,</span> sc<span>:</span> node<span>.</span>sc <span>-</span> <span>1</span> <span>}</span><span>)</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>image<span>[</span>node<span>.</span>sr<span>]</span><span>[</span>node<span>.</span>sc <span>+</span> <span>1</span><span>]</span> <span>===</span> l<span>)</span> <span>{</span>
      image<span>[</span>node<span>.</span>sr<span>]</span><span>[</span>node<span>.</span>sc <span>+</span> <span>1</span><span>]</span> <span>=</span> color<span>;</span>
      arr<span>.</span><span>push</span><span>(</span><span>{</span> sr<span>:</span> node<span>.</span>sr<span>,</span> sc<span>:</span> node<span>.</span>sc <span>+</span> <span>1</span> <span>}</span><span>)</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>image<span>[</span>node<span>.</span>sr <span>-</span> <span>1</span><span>]</span> <span>&amp;&amp;</span> image<span>[</span>node<span>.</span>sr <span>-</span> <span>1</span><span>]</span><span>[</span>node<span>.</span>sc<span>]</span> <span>===</span> l<span>)</span> <span>{</span>
      image<span>[</span>node<span>.</span>sr <span>-</span> <span>1</span><span>]</span><span>[</span>node<span>.</span>sc<span>]</span> <span>=</span> color<span>;</span>
      arr<span>.</span><span>push</span><span>(</span><span>{</span> sr<span>:</span> node<span>.</span>sr <span>-</span> <span>1</span><span>,</span> sc<span>:</span> node<span>.</span>sc <span>}</span><span>)</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>image<span>[</span>node<span>.</span>sr <span>+</span> <span>1</span><span>]</span> <span>&amp;&amp;</span> image<span>[</span>node<span>.</span>sr <span>+</span> <span>1</span><span>]</span><span>[</span>node<span>.</span>sc<span>]</span> <span>===</span> l<span>)</span> <span>{</span>
      image<span>[</span>node<span>.</span>sr <span>+</span> <span>1</span><span>]</span><span>[</span>node<span>.</span>sc<span>]</span> <span>=</span> color<span>;</span>
      arr<span>.</span><span>push</span><span>(</span><span>{</span> sr<span>:</span> node<span>.</span>sr <span>+</span> <span>1</span><span>,</span> sc<span>:</span> node<span>.</span>sc <span>}</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> image<span>;</span>
<span>}</span>
<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br></div></div><h2 id="_744-寻找比目标字母大的最小字母"> 744.寻找比目标字母大的最小字母</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=744 lang=javascript
 *
 * [744] 寻找比目标字母大的最小字母
 * 
 * 给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。

在比较时，字母是依序循环出现的。举个例子：

如果目标字母 target = 'z' 并且字符列表为 letters = ['a', 'b']，则答案返回 'a'
 

示例 1：

输入: letters = ["c", "f", "j"]，target = "a"
输出: "c"
示例 2:

输入: letters = ["c","f","j"], target = "c"
输出: "f"
示例 3:

输入: letters = ["c","f","j"], target = "d"
输出: "f"
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {character[]} letters
 * @param {character} target
 * @return {character}
 */</span>
<span>var</span> <span>nextGreatestLetter</span> <span>=</span> <span>function</span> <span>(</span><span>letters<span>,</span> target</span><span>)</span> <span>{</span>
  target <span>=</span> target<span>.</span><span>charCodeAt</span><span>(</span><span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> letters<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>letters<span>[</span>i<span>]</span><span>.</span><span>charCodeAt</span><span>(</span><span>)</span> <span>></span> target<span>)</span> <span>return</span> letters<span>[</span>i<span>]</span>
  <span>}</span>
  <span>return</span> letters<span>[</span><span>0</span><span>]</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><h2 id="_746-使用最小花费爬楼梯"> 746.使用最小花费爬楼梯</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=746 lang=javascript
 *
 * [746] 使用最小花费爬楼梯
 * 
 * 给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

 

示例 1：

输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
示例 2：

输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。
 


 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} cost
 * @return {number}
 */</span>
<span>var</span> <span>minCostClimbingStairs</span> <span>=</span> <span>function</span> <span>(</span><span>cost</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> cost<span>.</span>length <span>-</span> <span>3</span><span>;</span> i <span>!==</span> <span>-</span><span>1</span><span>;</span> i<span>--</span><span>)</span>
    cost<span>[</span>i<span>]</span> <span>+=</span> Math<span>.</span><span>min</span><span>(</span>cost<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>,</span> cost<span>[</span>i <span>+</span> <span>2</span><span>]</span><span>)</span>
  <span>return</span> Math<span>.</span><span>min</span><span>(</span>cost<span>[</span><span>0</span><span>]</span><span>,</span> cost<span>[</span><span>1</span><span>]</span><span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><h2 id="_747-至少是其他数字两倍的最大数"> 747.至少是其他数字两倍的最大数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=747 lang=javascript
 *
 * [747] 至少是其他数字两倍的最大数
 * 
 * 给你一个整数数组 nums ，其中总是存在 唯一的 一个最大整数 。

请你找出数组中的最大元素并检查它是否 至少是数组中每个其他数字的两倍 。如果是，则返回 最大元素的下标 ，否则返回 -1 。

 

示例 1：

输入：nums = [3,6,1,0]
输出：1
解释：6 是最大的整数，对于数组中的其他整数，6 至少是数组中其他元素的两倍。6 的下标是 1 ，所以返回 1 。
示例 2：

输入：nums = [1,2,3,4]
输出：-1
解释：4 没有超过 3 的两倍大，所以返回 -1 。
示例 3：

输入：nums = [1]
输出：0
解释：因为不存在其他数字，所以认为现有数字 1 至少是其他数字的两倍。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number}
 */</span>
<span>var</span> <span>dominantIndex</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>nums<span>.</span>length <span>===</span> <span>1</span><span>)</span> <span>return</span> <span>0</span>
  <span>const</span> arr <span>=</span> nums<span>.</span><span>slice</span><span>(</span><span>0</span><span>)</span><span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> b <span>-</span> a<span>)</span>
  <span>if</span> <span>(</span>arr<span>[</span><span>0</span><span>]</span> <span>>=</span> arr<span>[</span><span>1</span><span>]</span> <span>*</span> <span>2</span><span>)</span> <span>return</span> nums<span>.</span><span>indexOf</span><span>(</span>arr<span>[</span><span>0</span><span>]</span><span>)</span>
  <span>return</span> <span>-</span><span>1</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><h2 id="_748-最短补全词"> 748.最短补全词</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=748 lang=javascript
 *
 * [748] 最短补全词
 * 
 * 给你一个字符串 licensePlate 和一个字符串数组 words ，请你找出 words 中的 最短补全词 。

补全词 是一个包含 licensePlate 中所有字母的单词。忽略 licensePlate 中的 数字和空格 。不区分大小写。如果某个字母在 licensePlate 中出现不止一次，那么该字母在补全词中的出现次数应当一致或者更多。

例如：licensePlate = "aBc 12c"，那么它的补全词应当包含字母 'a'、'b' （忽略大写）和两个 'c' 。可能的 补全词 有 "abccdef"、"caaacab" 以及 "cbca" 。

请返回 words 中的 最短补全词 。题目数据保证一定存在一个最短补全词。当有多个单词都符合最短补全词的匹配条件时取 words 中 第一个 出现的那个。

 

示例 1：

输入：licensePlate = "1s3 PSt", words = ["step", "steps", "stripe", "stepple"]
输出："steps"
解释：最短补全词应该包括 "s"、"p"、"s"（忽略大小写） 以及 "t"。
"step" 包含 "t"、"p"，但只包含一个 "s"，所以它不符合条件。
"steps" 包含 "t"、"p" 和两个 "s"。
"stripe" 缺一个 "s"。
"stepple" 缺一个 "s"。
因此，"steps" 是唯一一个包含所有字母的单词，也是本例的答案。
示例 2：

输入：licensePlate = "1s3 456", words = ["looks", "pest", "stew", "show"]
输出："pest"
解释：licensePlate 只包含字母 "s" 。所有的单词都包含字母 "s" ，其中 "pest"、"stew"、和 "show" 三者最短。答案是 "pest" ，因为它是三个单词中在 words 里最靠前的那个。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} licensePlate
 * @param {string[]} words
 * @return {string}
 */</span>
<span>var</span> <span>shortestCompletingWord</span> <span>=</span> <span>function</span> <span>(</span><span>licensePlate<span>,</span> words</span><span>)</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>''</span><span>;</span>
  <span>const</span> license <span>=</span> licensePlate<span>.</span><span>match</span><span>(</span><span><span>/</span><span>[A-z]</span><span>/</span><span>g</span></span><span>)</span><span>.</span><span>map</span><span>(</span><span>item</span> <span>=></span> item<span>.</span><span>toLocaleLowerCase</span><span>(</span><span>)</span><span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> words<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>res <span>&amp;&amp;</span> res<span>.</span>length <span>&lt;=</span> words<span>[</span>i<span>]</span><span>.</span>length<span>)</span> <span>continue</span><span>;</span>
    <span>const</span> arr <span>=</span> license<span>.</span><span>slice</span><span>(</span><span>0</span><span>)</span><span>;</span>
    <span>const</span> arr1 <span>=</span> words<span>[</span>i<span>]</span><span>.</span><span>toLocaleLowerCase</span><span>(</span><span>)</span><span>.</span><span>split</span><span>(</span><span>''</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> arr1<span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
      <span>const</span> index <span>=</span> arr<span>.</span><span>indexOf</span><span>(</span>arr1<span>[</span>j<span>]</span><span>)</span>
      <span>if</span> <span>(</span>index <span>></span> <span>-</span><span>1</span><span>)</span> arr<span>.</span><span>splice</span><span>(</span>index<span>,</span> <span>1</span><span>)</span>
      <span>if</span> <span>(</span>arr<span>.</span>length <span>===</span> <span>0</span><span>)</span> <span>{</span>
        res <span>=</span> words<span>[</span>i<span>]</span><span>;</span>
        <span>break</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res<span>;</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br></div></div><h2 id="_762-二进制表示中质数个计算置位"> 762.二进制表示中质数个计算置位</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=762 lang=javascript
 *
 * [762] 二进制表示中质数个计算置位
 * 
 * 给你两个整数 left 和 right ，在闭区间 [left, right] 范围内，统计并返回 计算置位位数为质数 的整数个数。

计算置位位数 就是二进制表示中 1 的个数。

例如， 21 的二进制表示 10101 有 3 个计算置位。
 

示例 1：

输入：left = 6, right = 10
输出：4
解释：
6 -> 110 (2 个计算置位，2 是质数)
7 -> 111 (3 个计算置位，3 是质数)
9 -> 1001 (2 个计算置位，2 是质数)
10-> 1010 (2 个计算置位，2 是质数)
共计 4 个计算置位为质数的数字。
示例 2：

输入：left = 10, right = 15
输出：5
解释：
10 -> 1010 (2 个计算置位, 2 是质数)
11 -> 1011 (3 个计算置位, 3 是质数)
12 -> 1100 (2 个计算置位, 2 是质数)
13 -> 1101 (3 个计算置位, 3 是质数)
14 -> 1110 (3 个计算置位, 3 是质数)
15 -> 1111 (4 个计算置位, 4 不是质数)
共计 5 个计算置位为质数的数字。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} left
 * @param {number} right
 * @return {number}
 */</span>
<span>var</span> <span>countPrimeSetBits</span> <span>=</span> <span>function</span> <span>(</span><span>left<span>,</span> right</span><span>)</span> <span>{</span>
  <span>const</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>;</span>
  <span>let</span> res <span>=</span> <span>0</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> left<span>;</span> i <span>&lt;=</span> right<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>isPrime</span><span>(</span>i<span>.</span><span>toString</span><span>(</span><span>2</span><span>)</span><span>.</span><span>match</span><span>(</span><span><span>/</span><span>1</span><span>/</span><span>g</span></span><span>)</span><span>.</span>length<span>,</span> map<span>)</span><span>)</span> res<span>++</span><span>;</span>
  <span>}</span>
  <span>return</span> res<span>;</span>
<span>}</span><span>;</span>

<span>/**
 * @param {number} num
 * @param {Map&lt;string,boolean>} map
 * @return {boolean}
 */</span>
<span>var</span> <span>isPrime</span> <span>=</span> <span>function</span> <span>(</span><span>num<span>,</span> map</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>num <span>===</span> <span>1</span><span>)</span> <span>return</span> <span>false</span><span>;</span>
  <span>if</span> <span>(</span>map<span>.</span><span>has</span><span>(</span>num<span>)</span><span>)</span> <span>return</span> map<span>.</span><span>get</span><span>(</span>num<span>)</span><span>;</span>
  map<span>.</span><span>set</span><span>(</span>num<span>,</span> <span>true</span><span>)</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;</span> num<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>num <span>%</span> i <span>===</span> <span>0</span><span>)</span> <span>{</span>
      map<span>.</span><span>set</span><span>(</span>num<span>,</span> <span>false</span><span>)</span><span>;</span>
      <span>break</span><span>;</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> map<span>.</span><span>get</span><span>(</span>num<span>)</span><span>;</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br></div></div><h2 id="_766-托普利茨矩阵"> 766.托普利茨矩阵</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=766 lang=typescript

给你一个 m x n 的矩阵 matrix 。如果这个矩阵是托普利茨矩阵，返回 true ；否则，返回 false 。

如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是 托普利茨矩阵 。

 

示例 1：


输入：matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]
输出：true
解释：
在上述矩阵中, 其对角线为: 
"[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]"。 
各条对角线上的所有元素均相同, 因此答案是 True 。
示例 2：


输入：matrix = [[1,2],[2,2]]
输出：false
解释：
对角线 "[1, 2]" 上的元素不同。
 
 *
 * [766] 托普利茨矩阵
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>isToeplitzMatrix</span><span>(</span>matrix<span>:</span> <span>number</span><span>[</span><span>]</span><span>[</span><span>]</span><span>)</span><span>:</span> <span>boolean</span> <span>{</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> matrix<span>.</span>length <span>-</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> matrix<span>[</span>i<span>]</span><span>.</span>length <span>-</span> <span>1</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>matrix<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>!==</span> matrix<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>[</span>j <span>+</span> <span>1</span><span>]</span><span>)</span> <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>true</span><span>;</span>
<span>}</span>
<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id="_771-宝石与石头"> 771.宝石与石头</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=771 lang=javascript
 *
 * [771] 宝石与石头
 * 
 *  给你一个字符串 jewels 代表石头中宝石的类型，另有一个字符串 stones 代表你拥有的石头。 stones 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。

字母区分大小写，因此 "a" 和 "A" 是不同类型的石头。

 

示例 1：

输入：jewels = "aA", stones = "aAAbbbb"
输出：3
示例 2：

输入：jewels = "z", stones = "ZZ"
输出：0
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} jewels
 * @param {string} stones
 * @return {number}
 */</span>
<span>var</span> <span>numJewelsInStones</span> <span>=</span> <span>function</span> <span>(</span><span>jewels<span>,</span> stones</span><span>)</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> stones<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>jewels<span>.</span><span>includes</span><span>(</span>stones<span>[</span>i<span>]</span><span>)</span><span>)</span> res<span>++</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><h2 id="_796-旋转字符串"> 796.旋转字符串</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=796 lang=javascript
 *
 * [796] 旋转字符串
 * 
 * 给定两个字符串, s 和 goal。如果在若干次旋转操作之后，s 能变成 goal ，那么返回 true 。

s 的 旋转操作 就是将 s 最左边的字符移动到最右边。 

例如, 若 s = 'abcde'，在旋转一次之后结果就是'bcdea' 。
 

示例 1:

输入: s = "abcde", goal = "cdeab"
输出: true
示例 2:

输入: s = "abcde", goal = "abced"
输出: false
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @param {string} goal
 * @return {boolean}
 */</span>
<span>var</span> <span>rotateString</span> <span>=</span> <span>function</span> <span>(</span><span>s<span>,</span> goal</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>s <span>===</span> goal<span>)</span> <span>return</span> <span>true</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> s<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>s<span>.</span><span>slice</span><span>(</span>i<span>)</span> <span>+</span> s<span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span> i<span>)</span> <span>===</span> goal<span>)</span> <span>return</span> <span>true</span>
  <span>}</span>
  <span>return</span> <span>false</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><h2 id="_804-唯一摩尔斯密码词"> 804.唯一摩尔斯密码词</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=804 lang=javascript
 *
 * [804] 唯一摩尔斯密码词
 * 
 * 国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如:

'a' 对应 ".-" ，
'b' 对应 "-..." ，
'c' 对应 "-.-." ，以此类推。
为了方便，所有 26 个英文字母的摩尔斯密码表如下：

[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
给你一个字符串数组 words ，每个单词可以写成每个字母对应摩尔斯密码的组合。

例如，"cab" 可以写成 "-.-..--..." ，(即 "-.-." + ".-" + "-..." 字符串的结合)。我们将这样一个连接过程称作 单词翻译 。
对 words 中所有单词进行单词翻译，返回不同 单词翻译 的数量。

 

示例 1：

输入: words = ["gin", "zen", "gig", "msg"]
输出: 2
解释: 
各单词翻译如下:
"gin" -> "--...-."
"zen" -> "--...-."
"gig" -> "--...--."
"msg" -> "--...--."

共有 2 种不同翻译, "--...-." 和 "--...--.".
示例 2：

输入：words = ["a"]
输出：1
 


 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string[]} words
 * @return {number}
 */</span>
<span>var</span> <span>uniqueMorseRepresentations</span> <span>=</span> <span>function</span> <span>(</span><span>words</span><span>)</span> <span>{</span>
  <span>const</span> set <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>)</span><span>,</span> arr <span>=</span> <span>[</span><span>".-"</span><span>,</span> <span>"-..."</span><span>,</span> <span>"-.-."</span><span>,</span> <span>"-.."</span><span>,</span> <span>"."</span><span>,</span> <span>"..-."</span><span>,</span> <span>"--."</span><span>,</span> <span>"...."</span><span>,</span> <span>".."</span><span>,</span> <span>".---"</span><span>,</span> <span>"-.-"</span><span>,</span> <span>".-.."</span><span>,</span> <span>"--"</span><span>,</span> <span>"-."</span><span>,</span> <span>"---"</span><span>,</span> <span>".--."</span><span>,</span> <span>"--.-"</span><span>,</span> <span>".-."</span><span>,</span> <span>"..."</span><span>,</span> <span>"-"</span><span>,</span> <span>"..-"</span><span>,</span> <span>"...-"</span><span>,</span> <span>".--"</span><span>,</span> <span>"-..-"</span><span>,</span> <span>"-.--"</span><span>,</span> <span>"--.."</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> words<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>let</span> item <span>=</span> <span>""</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> words<span>[</span>i<span>]</span><span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
      item <span>+=</span> arr<span>[</span>words<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>.</span><span>charCodeAt</span><span>(</span><span>)</span> <span>-</span> <span>97</span><span>]</span>
    <span>}</span>
    set<span>.</span><span>add</span><span>(</span>item<span>)</span>
  <span>}</span>
  <span>return</span> set<span>.</span>size
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br></div></div><h2 id="_806-写字符串需要的行数"> 806.写字符串需要的行数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=806 lang=javascript
 *
 * [806] 写字符串需要的行数
 * 
 * 我们要把给定的字符串 S 从左到右写到每一行上，每一行的最大宽度为100个单位，如果我们在写某个字母的时候会使这行超过了100 个单位，那么我们应该把这个字母写到下一行。我们给定了一个数组 widths ，这个数组 widths[0] 代表 'a' 需要的单位， widths[1] 代表 'b' 需要的单位，...， widths[25] 代表 'z' 需要的单位。

现在回答两个问题：至少多少行能放下S，以及最后一行使用的宽度是多少个单位？将你的答案作为长度为2的整数列表返回。

示例 1:
输入: 
widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]
S = "abcdefghijklmnopqrstuvwxyz"
输出: [3, 60]
解释: 
所有的字符拥有相同的占用单位10。所以书写所有的26个字母，
我们需要2个整行和占用60个单位的一行。
示例 2:
输入: 
widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]
S = "bbbcccdddaaa"
输出: [2, 4]
解释: 
除去字母'a'所有的字符都是相同的单位10，并且字符串 "bbbcccdddaa" 将会覆盖 9 * 10 + 2 * 4 = 98 个单位.
最后一个字母 'a' 将会被写到第二行，因为第一行只剩下2个单位了。
所以，这个答案是2行，第二行有4个单位宽度。

 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} widths
 * @param {string} s
 * @return {number[]}
 */</span>
<span>var</span> <span>numberOfLines</span> <span>=</span> <span>function</span> <span>(</span><span>widths<span>,</span> s</span><span>)</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>[</span><span>1</span><span>,</span> <span>0</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> item <span>=</span> widths<span>[</span>s<span>[</span>i<span>]</span><span>.</span><span>charCodeAt</span><span>(</span><span>)</span> <span>-</span> <span>97</span><span>]</span>
    <span>if</span> <span>(</span>res<span>[</span><span>1</span><span>]</span> <span>+</span> item <span>&lt;=</span> <span>100</span><span>)</span> <span>{</span>
      res<span>[</span><span>1</span><span>]</span> <span>+=</span> item
      <span>continue</span>
    <span>}</span>
    res<span>[</span><span>0</span><span>]</span><span>++</span>
    res<span>[</span><span>1</span><span>]</span> <span>=</span> item
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><h2 id="_812-最大三角形面积"> 812.最大三角形面积</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=812 lang=javascript
 *
 * [812] 最大三角形面积
 * 
 * 给定包含多个点的集合，从其中取三个点组成三角形，返回能组成的最大三角形的面积。

示例:
输入: points = [[0,0],[0,1],[1,0],[0,2],[2,0]]
输出: 2
解释: 
这五个点如下图所示。组成的橙色三角形是最大的，面积为2。



 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[][]} points
 * @return {number}
 */</span>
<span>function</span> <span>largestTriangleArea</span><span>(</span><span>points</span><span>)</span> <span>{</span>
  <span>let</span> max <span>=</span> Number<span>.</span><span>MIN_SAFE_INTEGER</span>
  <span>for</span> <span>(</span><span>const</span> point1 <span>of</span> points<span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>const</span> point2 <span>of</span> points<span>)</span> <span>{</span>
      <span>for</span> <span>(</span><span>const</span> point3 <span>of</span> points<span>)</span> <span>{</span>
        max <span>=</span> Math<span>.</span><span>max</span><span>(</span>max<span>,</span> <span>countTriangleArea</span><span>(</span><span>[</span>point1<span>,</span> point2<span>,</span> point3<span>]</span><span>)</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> max
<span>}</span>

<span>function</span> <span>countTriangleArea</span><span>(</span><span>points</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>[</span>x1<span>,</span> y1<span>]</span><span>,</span> <span>[</span>x2<span>,</span> y2<span>]</span><span>,</span> <span>[</span>x3<span>,</span> y3<span>]</span><span>]</span> <span>=</span> points
  <span>// 海伦公式</span>
  <span>// 向量 正弦定理</span>
  <span>// return (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2</span>
  <span>// 左边梯形 + 右边梯形 - 底部梯形 = 顶部三角形</span>
  <span>return</span> <span>(</span>x1 <span>*</span> <span>(</span>y2 <span>-</span> y3<span>)</span> <span>+</span> x2 <span>*</span> <span>(</span>y3 <span>-</span> y1<span>)</span> <span>+</span> x3 <span>*</span> <span>(</span>y1 <span>-</span> y2<span>)</span><span>)</span> <span>/</span> <span>2</span>
<span>}</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><h2 id="_819-最常见的单词"> 819.最常见的单词</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=819 lang=javascript
 *
 * [819] 最常见的单词
 * 
 * 给定一个段落 (paragraph) 和一个禁用单词列表 (banned)。返回出现次数最多，同时不在禁用列表中的单词。

题目保证至少有一个词不在禁用列表中，而且答案唯一。

禁用列表中的单词用小写字母表示，不含标点符号。段落中的单词不区分大小写。答案都是小写字母。

 

示例：

输入: 
paragraph = "Bob hit a ball, the hit BALL flew far after it was hit."
banned = ["hit"]
输出: "ball"
解释: 
"hit" 出现了3次，但它是一个禁用的单词。
"ball" 出现了2次 (同时没有其他单词出现2次)，所以它是段落里出现次数最多的，且不在禁用列表中的单词。 
注意，所有这些单词在段落里不区分大小写，标点符号需要忽略（即使是紧挨着单词也忽略， 比如 "ball,"）， 
"hit"不是最终的答案，虽然它出现次数更多，但它在禁用单词列表中。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} paragraph
 * @param {string[]} banned
 * @return {string}
 */</span>
<span>var</span> <span>mostCommonWord</span> <span>=</span> <span>function</span> <span>(</span><span>paragraph<span>,</span> banned</span><span>)</span> <span>{</span>
  paragraph <span>=</span> paragraph<span>.</span><span>toLocaleLowerCase</span><span>(</span><span>)</span><span>.</span><span>replace</span><span>(</span><span><span>/</span><span>[^a-z|\s|\,]</span><span>/</span><span>g</span></span><span>,</span> <span>""</span><span>)</span><span>.</span><span>split</span><span>(</span><span><span>/</span><span>\s|\,</span><span>/</span></span><span>)</span>
  <span>let</span> res <span>=</span> <span>""</span><span>,</span> count <span>=</span> <span>0</span><span>,</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> paragraph<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>paragraph<span>[</span>i<span>]</span><span>)</span> <span>continue</span>
    <span>if</span> <span>(</span><span>!</span>banned<span>.</span><span>includes</span><span>(</span>paragraph<span>[</span>i<span>]</span><span>)</span><span>)</span> <span>{</span>
      map<span>.</span><span>set</span><span>(</span>paragraph<span>[</span>i<span>]</span><span>,</span> map<span>.</span><span>has</span><span>(</span>paragraph<span>[</span>i<span>]</span><span>)</span> <span>?</span> map<span>.</span><span>get</span><span>(</span>paragraph<span>[</span>i<span>]</span><span>)</span> <span>+</span> <span>1</span> <span>:</span> <span>1</span><span>)</span>
      <span>const</span> num <span>=</span> map<span>.</span><span>get</span><span>(</span>paragraph<span>[</span>i<span>]</span><span>)</span>
      <span>if</span> <span>(</span>num <span>></span> count<span>)</span> <span>{</span>
        res <span>=</span> paragraph<span>[</span>i<span>]</span>
        count <span>=</span> num
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><h2 id="_821-字符的最短距离"> 821.字符的最短距离</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=821 lang=javascript
 *
 * [821] 字符的最短距离
 * 
 * 给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。

返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。

两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。

 

示例 1：

输入：s = "loveleetcode", c = "e"
输出：[3,2,1,0,1,0,0,1,2,2,1,0]
解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。
距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。
距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。
对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。
距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。
示例 2：

输入：s = "aaab", c = "b"
输出：[3,2,1,0]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @param {character} c
 * @return {number[]}
 */</span>
<span>var</span> <span>shortestToChar</span> <span>=</span> <span>function</span> <span>(</span><span>s<span>,</span> c</span><span>)</span> <span>{</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>s<span>.</span><span>lastIndexOf</span><span>(</span>c<span>,</span> i<span>)</span> <span>></span> <span>-</span><span>1</span><span>)</span> res<span>.</span><span>push</span><span>(</span>Math<span>.</span><span>min</span><span>(</span>Math<span>.</span><span>abs</span><span>(</span>s<span>.</span><span>indexOf</span><span>(</span>c<span>,</span> i<span>)</span> <span>-</span> i<span>)</span><span>,</span> Math<span>.</span><span>abs</span><span>(</span>s<span>.</span><span>lastIndexOf</span><span>(</span>c<span>,</span> i<span>)</span> <span>-</span> i<span>)</span><span>)</span><span>)</span>
    <span>else</span> res<span>.</span><span>push</span><span>(</span>Math<span>.</span><span>abs</span><span>(</span>s<span>.</span><span>indexOf</span><span>(</span>c<span>,</span> i<span>)</span> <span>-</span> i<span>)</span><span>)</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h2 id="_824-山羊拉丁文"> 824.山羊拉丁文</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=824 lang=javascript
 *
 * [824] 山羊拉丁文
 * 
 * 给你一个由若干单词组成的句子 sentence ，单词间由空格分隔。每个单词仅由大写和小写英文字母组成。

请你将句子转换为 “山羊拉丁文（Goat Latin）”（一种类似于 猪拉丁文 - Pig Latin 的虚构语言）。山羊拉丁文的规则如下：

如果单词以元音开头（'a', 'e', 'i', 'o', 'u'），在单词后添加"ma"。
例如，单词 "apple" 变为 "applema" 。
如果单词以辅音字母开头（即，非元音字母），移除第一个字符并将它放到末尾，之后再添加"ma"。
例如，单词 "goat" 变为 "oatgma" 。
根据单词在句子中的索引，在单词最后添加与索引相同数量的字母'a'，索引从 1 开始。
例如，在第一个单词后添加 "a" ，在第二个单词后添加 "aa" ，以此类推。
返回将 sentence 转换为山羊拉丁文后的句子。

 

示例 1：

输入：sentence = "I speak Goat Latin"
输出："Imaa peaksmaaa oatGmaaaa atinLmaaaaa"
示例 2：

输入：sentence = "The quick brown fox jumped over the lazy dog"
输出："heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa"
 


 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} sentence
 * @return {string}
 */</span>
<span>var</span> <span>toGoatLatin</span> <span>=</span> <span>function</span> <span>(</span><span>sentence</span><span>)</span> <span>{</span>
  <span>const</span> set <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>[</span><span>"a"</span><span>,</span> <span>"A"</span><span>,</span> <span>"E"</span><span>,</span> <span>"e"</span><span>,</span> <span>"I"</span><span>,</span> <span>"i"</span><span>,</span> <span>"O"</span><span>,</span> <span>"o"</span><span>,</span> <span>"U"</span><span>,</span> <span>"u"</span><span>]</span><span>)</span>
  sentence <span>=</span> sentence<span>.</span><span>split</span><span>(</span><span>" "</span><span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> sentence<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>set<span>.</span><span>has</span><span>(</span>sentence<span>[</span>i<span>]</span><span>[</span><span>0</span><span>]</span><span>)</span><span>)</span> sentence<span>[</span>i<span>]</span> <span>=</span> sentence<span>[</span>i<span>]</span><span>.</span><span>slice</span><span>(</span><span>1</span><span>)</span> <span>+</span> sentence<span>[</span>i<span>]</span><span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span> <span>1</span><span>)</span>
    sentence<span>[</span>i<span>]</span> <span>+=</span> <span>"ma"</span> <span>+</span> <span>"a"</span><span>.</span><span>repeat</span><span>(</span>i <span>+</span> <span>1</span><span>)</span>
  <span>}</span>
  <span>return</span> sentence<span>.</span><span>join</span><span>(</span><span>" "</span><span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><h2 id="_830-较大分组的位置"> 830.较大分组的位置</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=830 lang=javascript
 *
 * [830] 较大分组的位置
 * 
 * 在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。

例如，在字符串 s = "abbxxxxzyy" 中，就含有 "a", "bb", "xxxx", "z" 和 "yy" 这样的一些分组。

分组可以用区间 [start, end] 表示，其中 start 和 end 分别表示该分组的起始和终止位置的下标。上例中的 "xxxx" 分组用区间表示为 [3,6] 。

我们称所有包含大于或等于三个连续字符的分组为 较大分组 。

找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后，返回结果。

 

示例 1：

输入：s = "abbxxxxzzy"
输出：[[3,6]]
解释："xxxx" 是一个起始于 3 且终止于 6 的较大分组。
示例 2：

输入：s = "abc"
输出：[]
解释："a","b" 和 "c" 均不是符合要求的较大分组。
示例 3：

输入：s = "abcdddeeeeaabbbcd"
输出：[[3,5],[6,9],[12,14]]
解释：较大分组为 "ddd", "eeee" 和 "bbb"
示例 4：

输入：s = "aba"
输出：[]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @return {number[][]}
 */</span>
<span>var</span> <span>largeGroupPositions</span> <span>=</span> <span>function</span> <span>(</span><span>s</span><span>)</span> <span>{</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span>
  <span>let</span> curr <span>=</span> <span>""</span><span>,</span> len <span>=</span> <span>1</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>s<span>[</span>i<span>]</span> <span>===</span> s<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>)</span> <span>{</span>
      curr <span>=</span> s<span>[</span>i<span>]</span>
      len<span>++</span>
      <span>continue</span>
    <span>}</span>
    <span>if</span> <span>(</span><span>!</span>curr<span>)</span> <span>continue</span>
    <span>if</span> <span>(</span>len <span>>=</span> <span>3</span><span>)</span> res<span>.</span><span>push</span><span>(</span><span>[</span>i <span>-</span> len <span>+</span> <span>1</span><span>,</span> i<span>]</span><span>)</span>
    curr <span>=</span> <span>""</span>
    len <span>=</span> <span>1</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br></div></div><h2 id="_832-翻转图像"> 832.翻转图像</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=832 lang=javascript
 *
 * [832] 翻转图像
 * 
 * 给定一个 n x n 的二进制矩阵 image ，先 水平 翻转图像，然后 反转 图像并返回 结果 。

水平翻转图片就是将图片的每一行都进行翻转，即逆序。

例如，水平翻转 [1,1,0] 的结果是 [0,1,1]。
反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。

例如，反转 [0,1,1] 的结果是 [1,0,0]。
 

示例 1：

输入：image = [[1,1,0],[1,0,1],[0,0,0]]
输出：[[1,0,0],[0,1,0],[1,1,1]]
解释：首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；
     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]
示例 2：

输入：image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
输出：[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
解释：首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；
     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[][]} image
 * @return {number[][]}
 */</span>
<span>var</span> <span>flipAndInvertImage</span> <span>=</span> <span>function</span> <span>(</span><span>image</span><span>)</span> <span>{</span>
  <span>return</span> image<span>.</span><span>map</span><span>(</span><span>item</span> <span>=></span> item<span>.</span><span>reverse</span><span>(</span><span>)</span><span>.</span><span>map</span><span>(</span><span>ele</span> <span>=></span> ele <span>===</span> <span>1</span> <span>?</span> <span>0</span> <span>:</span> <span>1</span><span>)</span><span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id="_836-矩形重叠"> 836.矩形重叠</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=836 lang=javascript
 *
 * [836] 矩形重叠
 * 
 * 矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。矩形的上下边平行于 x 轴，左右边平行于 y 轴。

如果相交的面积为 正 ，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。

给出两个矩形 rec1 和 rec2 。如果它们重叠，返回 true；否则，返回 false 。

 

示例 1：

输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]
输出：true
示例 2：

输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]
输出：false
示例 3：

输入：rec1 = [0,0,1,1], rec2 = [2,2,3,3]
输出：false
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} rec1
 * @param {number[]} rec2
 * @return {boolean}
 */</span>
<span>var</span> <span>isRectangleOverlap</span> <span>=</span> <span>function</span> <span>(</span><span>r1<span>,</span> r2</span><span>)</span> <span>{</span>
  <span>return</span> r2<span>[</span><span>0</span><span>]</span> <span>>=</span> r1<span>[</span><span>2</span><span>]</span> <span>||</span> r2<span>[</span><span>1</span><span>]</span> <span>>=</span> r1<span>[</span><span>3</span><span>]</span> <span>||</span> r2<span>[</span><span>2</span><span>]</span> <span>&lt;=</span> r1<span>[</span><span>0</span><span>]</span> <span>||</span> r2<span>[</span><span>3</span><span>]</span> <span>&lt;=</span> r1<span>[</span><span>1</span><span>]</span>
    <span>?</span> <span>false</span>
    <span>:</span> <span>true</span><span>;</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h2 id="_844-比较含退格的字符串"> 844.比较含退格的字符串</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=844 lang=javascript
 *
 * [844] 比较含退格的字符串
 * 
 * 给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。

注意：如果对空文本输入退格字符，文本继续为空。

 

示例 1：

输入：s = "ab#c", t = "ad#c"
输出：true
解释：s 和 t 都会变成 "ac"。
示例 2：

输入：s = "ab##", t = "c#d#"
输出：true
解释：s 和 t 都会变成 ""。
示例 3：

输入：s = "a#c", t = "b"
输出：false
解释：s 会变成 "c"，但 t 仍然是 "b"。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */</span>
<span>var</span> <span>backspaceCompare</span> <span>=</span> <span>function</span> <span>(</span><span>s<span>,</span> t</span><span>)</span> <span>{</span>
  <span>const</span> len <span>=</span> Math<span>.</span><span>max</span><span>(</span>s<span>.</span>length<span>,</span>t<span>.</span>length<span>)</span>
  <span>let</span> strS <span>=</span> <span>""</span><span>,</span> strT <span>=</span> <span>""</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>s<span>[</span>i<span>]</span> <span>===</span> <span>"#"</span><span>)</span> <span>{</span>
      strS <span>=</span> strS<span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span> strS<span>.</span>length <span>-</span> <span>1</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      strS <span>+=</span> s<span>[</span>i<span>]</span> <span>||</span> <span>""</span>
    <span>}</span>
    <span>if</span> <span>(</span>t<span>[</span>i<span>]</span> <span>===</span> <span>"#"</span><span>)</span> <span>{</span>
      strT <span>=</span> strT<span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span> strT<span>.</span>length <span>-</span> <span>1</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      strT <span>+=</span> t<span>[</span>i<span>]</span> <span>||</span> <span>""</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> strS <span>===</span> strT
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><h2 id="_852-山脉数组的峰顶索引"> 852.山脉数组的峰顶索引</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=852 lang=javascript
 *
 * [852] 山脉数组的峰顶索引
 * 
 * 符合下列属性的数组 arr 称为 山脉数组 ：
arr.length >= 3
存在 i（0 &lt; i &lt; arr.length - 1）使得：
arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i] 
arr[i] > arr[i+1] > ... > arr[arr.length - 1]
给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] &lt; arr[1] &lt; ... arr[i - 1] &lt; arr[i] > arr[i + 1] > ... > arr[arr.length - 1] 的下标 i 。

 

示例 1：

输入：arr = [0,1,0]
输出：1
示例 2：

输入：arr = [0,2,1,0]
输出：1
示例 3：

输入：arr = [0,10,5,2]
输出：1
示例 4：

输入：arr = [3,4,5,1]
输出：2
示例 5：

输入：arr = [24,69,100,99,79,78,67,36,26,19]
输出：2

 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} arr
 * @return {number}
 */</span>
<span>var</span> <span>peakIndexInMountainArray</span> <span>=</span> <span>function</span> <span>(</span><span>arr</span><span>)</span> <span>{</span>
  <span>return</span> arr<span>.</span><span>indexOf</span><span>(</span>Math<span>.</span><span>max</span><span>(</span><span>...</span>arr<span>)</span><span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><h2 id="_859-亲密字符串"> 859.亲密字符串</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=859 lang=typescript
 *
 * [859] 亲密字符串
 * 
 * 给你两个字符串 s 和 goal ，只要我们可以通过交换 s 中的两个字母得到与 goal 相等的结果，就返回 true ；否则返回 false 。

交换字母的定义是：取两个下标 i 和 j （下标从 0 开始）且满足 i != j ，接着交换 s[i] 和 s[j] 处的字符。

例如，在 "abcd" 中交换下标 0 和下标 2 的元素可以生成 "cbad" 。
 

示例 1：

输入：s = "ab", goal = "ba"
输出：true
解释：你可以交换 s[0] = 'a' 和 s[1] = 'b' 生成 "ba"，此时 s 和 goal 相等。
示例 2：

输入：s = "ab", goal = "ab"
输出：false
解释：你只能交换 s[0] = 'a' 和 s[1] = 'b' 生成 "ba"，此时 s 和 goal 不相等。
示例 3：

输入：s = "aa", goal = "aa"
输出：true
解释：你可以交换 s[0] = 'a' 和 s[1] = 'a' 生成 "aa"，此时 s 和 goal 相等。
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>buddyStrings</span><span>(</span>s<span>:</span> <span>string</span><span>,</span> goal<span>:</span> <span>string</span><span>)</span><span>:</span> <span>boolean</span> <span>{</span>
  <span>if</span> <span>(</span>s<span>.</span>length <span>!==</span> goal<span>.</span>length<span>)</span> <span>return</span> <span>false</span><span>;</span>
  <span>if</span> <span>(</span>s <span>===</span> goal<span>)</span> <span>return</span> <span>new</span> <span>Set</span><span>(</span>s<span>.</span><span>split</span><span>(</span><span>""</span><span>)</span><span>)</span><span>.</span>size <span>!==</span> s<span>.</span>length<span>;</span>
  <span>const</span> arr<span>:</span> <span>string</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>s<span>[</span>i<span>]</span> <span>!==</span> goal<span>[</span>i<span>]</span><span>)</span> <span>{</span>
      arr<span>.</span><span>push</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span>
      arr<span>.</span><span>push</span><span>(</span>goal<span>[</span>i<span>]</span><span>)</span>
    <span>}</span>
    <span>if</span> <span>(</span>arr<span>.</span>length <span>></span> <span>4</span><span>)</span> <span>return</span> <span>false</span>
  <span>}</span>
  <span>if</span> <span>(</span>arr<span>[</span><span>0</span><span>]</span> <span>===</span> arr<span>[</span><span>3</span><span>]</span> <span>&amp;&amp;</span> arr<span>[</span><span>1</span><span>]</span> <span>===</span> arr<span>[</span><span>2</span><span>]</span><span>)</span> <span>return</span> <span>true</span>
  <span>return</span> <span>false</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><h2 id="_860-柠檬水找零"> 860.柠檬水找零</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=860 lang=typescript
 *
 * [860] 柠檬水找零
 * 
 * 在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。

注意，一开始你手头没有任何零钱。

给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。

 

示例 1：

输入：bills = [5,5,5,10,20]
输出：true
解释：
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
由于所有客户都得到了正确的找零，所以我们输出 true。
示例 2：

输入：bills = [5,5,10,10,20]
输出：false
解释：
前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
由于不是每位顾客都得到了正确的找零，所以答案是 false。
 


 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>lemonadeChange</span><span>(</span>bills<span>:</span> <span>number</span><span>[</span><span>]</span><span>)</span><span>:</span> <span>boolean</span> <span>{</span>
  <span>const</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> bills<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> f <span>=</span> map<span>.</span><span>get</span><span>(</span><span>5</span><span>)</span> <span>||</span> <span>0</span><span>,</span> t <span>=</span> map<span>.</span><span>get</span><span>(</span><span>10</span><span>)</span> <span>||</span> <span>0</span><span>;</span>
    <span>if</span> <span>(</span>bills<span>[</span>i<span>]</span> <span>===</span> <span>5</span><span>)</span> <span>{</span>
      map<span>.</span><span>set</span><span>(</span><span>5</span><span>,</span> f <span>+</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>bills<span>[</span>i<span>]</span> <span>===</span> <span>10</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>f <span>===</span> <span>0</span><span>)</span> <span>return</span> <span>false</span>
      map<span>.</span><span>set</span><span>(</span><span>10</span><span>,</span> t <span>+</span> <span>1</span><span>)</span><span>;</span>
      map<span>.</span><span>set</span><span>(</span><span>5</span><span>,</span> f <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>if</span> <span>(</span>f <span>===</span> <span>0</span><span>)</span> <span>return</span> <span>false</span>
      <span>if</span> <span>(</span>t <span>!==</span> <span>0</span><span>)</span> <span>{</span>
        map<span>.</span><span>set</span><span>(</span><span>10</span><span>,</span> t <span>-</span> <span>1</span><span>)</span><span>;</span>
        map<span>.</span><span>set</span><span>(</span><span>5</span><span>,</span> f <span>-</span> <span>1</span><span>)</span><span>;</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>if</span> <span>(</span>f <span>&lt;</span> <span>3</span><span>)</span> <span>return</span> <span>false</span>
        map<span>.</span><span>set</span><span>(</span><span>5</span><span>,</span> f <span>-</span> <span>3</span><span>)</span><span>;</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>true</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br></div></div><h2 id="_867-转置矩阵"> 867.转置矩阵</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=867 lang=typescript

给你一个二维整数数组 matrix， 返回 matrix 的 转置矩阵 。

矩阵的 转置 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。



 

示例 1：

输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[1,4,7],[2,5,8],[3,6,9]]
示例 2：

输入：matrix = [[1,2,3],[4,5,6]]
输出：[[1,4],[2,5],[3,6]]
 
 *
 * [867] 转置矩阵
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>transpose</span><span>(</span>matrix<span>:</span> <span>number</span><span>[</span><span>]</span><span>[</span><span>]</span><span>)</span><span>:</span> <span>number</span><span>[</span><span>]</span><span>[</span><span>]</span> <span>{</span>
  <span>const</span> res<span>:</span> <span>number</span><span>[</span><span>]</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>]</span><span>;</span>
  <span>while</span> <span>(</span>res<span>.</span>length <span>&lt;</span> matrix<span>[</span><span>0</span><span>]</span><span>.</span>length<span>)</span> <span>{</span>
    res<span>.</span><span>push</span><span>(</span><span>[</span><span>]</span><span>)</span><span>;</span>
  <span>}</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> matrix<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> matrix<span>[</span>i<span>]</span><span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
      res<span>[</span>j<span>]</span><span>[</span>i<span>]</span> <span>=</span> matrix<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>;</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res<span>;</span>
<span>}</span>
<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><h2 id="_868-二进制间距"> 868.二进制间距</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=868 lang=typescript
 *
 * [868] 二进制间距
 */</span>

<span>// @lc code=start</span>
<span>// function binaryGap(n: number): number {</span>
<span>//   const s = n.toString(2),</span>
<span>//     arr: number[] = [];</span>
<span>//   for (let i = 0; i &lt; s.length; i++) {</span>
<span>//     if (s[i] === "1") arr.push(i);</span>
<span>//   }</span>
<span>//   if (arr.length &lt; 2) return 0;</span>
<span>//   let max = 0;</span>
<span>//   for (let i = 1; i &lt; arr.length; i++) {</span>
<span>//     max = Math.max(max, arr[i] - arr[i - 1]);</span>
<span>//   }</span>
<span>//   return max;</span>
<span>// }</span>

<span>function</span> <span>binaryGap</span><span>(</span>n<span>:</span> <span>number</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>const</span> s <span>=</span> n<span>.</span><span>toString</span><span>(</span><span>2</span><span>)</span><span>,</span>
    arr<span>:</span> <span>number</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>]</span><span>;</span>
  <span>let</span> max <span>=</span> <span>0</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>s<span>[</span>i<span>]</span> <span>===</span> <span>"1"</span><span>)</span> <span>{</span>
      <span>const</span> last <span>=</span> arr<span>.</span><span>shift</span><span>(</span><span>)</span><span>;</span>
      <span>if</span> <span>(</span>last <span>||</span> last <span>===</span> <span>0</span><span>)</span> max <span>=</span> Math<span>.</span><span>max</span><span>(</span>max<span>,</span> i <span>-</span> last<span>)</span><span>;</span>
      arr<span>.</span><span>push</span><span>(</span>i<span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> max<span>;</span>
<span>}</span>
<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><h2 id="_876-链表的中间结点"> 876.链表的中间结点</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=876 lang=typescript
 *
 * [876] 链表的中间结点
 */</span>

<span>// @lc code=start</span>
<span>/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */</span>

<span>function</span> <span>middleNode</span><span>(</span>head<span>:</span> ListNode <span>|</span> <span>null</span><span>)</span><span>:</span> ListNode <span>|</span> <span>null</span> <span>{</span>
  <span>const</span> arr<span>:</span> <span>any</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>]</span><span>;</span>
  <span>while</span> <span>(</span>head<span>)</span> <span>{</span>
    arr<span>.</span><span>push</span><span>(</span>head<span>)</span><span>;</span>
    head <span>=</span> head<span>.</span>next<span>;</span>
  <span>}</span>
  <span>return</span> arr<span>[</span>Math<span>.</span><span>floor</span><span>(</span>arr<span>.</span>length <span>/</span> <span>2</span><span>)</span><span>]</span><span>;</span>
<span>}</span>
<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h2 id="_883-三维形体投影面积"> 883.三维形体投影面积</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=883 lang=typescript

在 n x n 的网格 grid 中，我们放置了一些与 x，y，z 三轴对齐的 1 x 1 x 1 立方体。

每个值 v = grid[i][j] 表示 v 个正方体叠放在单元格 (i, j) 上。

现在，我们查看这些立方体在 xy 、yz 和 zx 平面上的投影。

投影 就像影子，将 三维 形体映射到一个 二维 平面上。从顶部、前面和侧面看立方体时，我们会看到“影子”。

返回 所有三个投影的总面积 。

 

示例 1：



输入：[[1,2],[3,4]]
输出：17
解释：这里有该形体在三个轴对齐平面上的三个投影(“阴影部分”)。
示例 2:

输入：grid = [[2]]
输出：5
示例 3：

输入：[[1,0],[0,2]]
输出：8
 
 *
 * [883] 三维形体投影面积
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>projectionArea</span><span>(</span>grid<span>:</span> <span>number</span><span>[</span><span>]</span><span>[</span><span>]</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>let</span> x <span>=</span> <span>0</span><span>,</span>
    y <span>=</span> <span>0</span><span>,</span>
    z <span>=</span> <span>0</span><span>;</span>
  <span>const</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> grid<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    x <span>+=</span> Math<span>.</span><span>max</span><span>(</span><span>...</span>grid<span>[</span>i<span>]</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> grid<span>[</span>i<span>]</span><span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>grid<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>)</span> z<span>++</span><span>;</span>
      map<span>.</span><span>set</span><span>(</span>j<span>,</span> map<span>.</span><span>has</span><span>(</span>j<span>)</span> <span>?</span> Math<span>.</span><span>max</span><span>(</span>map<span>.</span><span>get</span><span>(</span>j<span>)</span><span>,</span> grid<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>)</span> <span>:</span> grid<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>
  <span>for</span> <span>(</span><span>const</span> v <span>of</span> map<span>.</span><span>values</span><span>(</span><span>)</span><span>)</span> <span>{</span>
    y <span>+=</span> v<span>;</span>
  <span>}</span>
  <span>return</span> x <span>+</span> y <span>+</span> z<span>;</span>
<span>}</span>
<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><h2 id="_884-两句话中的不常见单词"> 884.两句话中的不常见单词</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=884 lang=javascript
 *
 * [884] 两句话中的不常见单词
 * 
 * 句子 是一串由空格分隔的单词。每个 单词 仅由小写字母组成。

如果某个单词在其中一个句子中恰好出现一次，在另一个句子中却 没有出现 ，那么这个单词就是 不常见的 。

给你两个 句子 s1 和 s2 ，返回所有 不常用单词 的列表。返回列表中单词可以按 任意顺序 组织。

 

示例 1：

输入：s1 = "this apple is sweet", s2 = "this apple is sour"
输出：["sweet","sour"]
示例 2：

输入：s1 = "apple apple", s2 = "banana"
输出：["banana"]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s1
 * @param {string} s2
 * @return {string[]}
 */</span>
<span>var</span> <span>uncommonFromSentences</span> <span>=</span> <span>function</span><span>(</span><span>s1<span>,</span> s2</span><span>)</span> <span>{</span>
  s1 <span>=</span> s1<span>.</span><span>split</span><span>(</span><span>" "</span><span>)</span>
  s2 <span>=</span> s2<span>.</span><span>split</span><span>(</span><span>" "</span><span>)</span>
  <span>const</span> len <span>=</span> Math<span>.</span><span>max</span><span>(</span>s1<span>.</span>length<span>,</span>s2<span>.</span>length<span>)</span><span>,</span>res <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span><span>(</span>s1<span>[</span>i<span>]</span> <span>&amp;&amp;</span> s1<span>.</span><span>indexOf</span><span>(</span>s1<span>[</span>i<span>]</span><span>)</span><span>===</span>s1<span>.</span><span>lastIndexOf</span><span>(</span>s1<span>[</span>i<span>]</span><span>)</span><span>&amp;&amp;</span><span>!</span>s2<span>.</span><span>includes</span><span>(</span>s1<span>[</span>i<span>]</span><span>)</span><span>)</span> res<span>.</span><span>push</span><span>(</span>s1<span>[</span>i<span>]</span><span>)</span>
    <span>if</span><span>(</span>s2<span>[</span>i<span>]</span> <span>&amp;&amp;</span> s2<span>.</span><span>indexOf</span><span>(</span>s2<span>[</span>i<span>]</span><span>)</span><span>===</span>s2<span>.</span><span>lastIndexOf</span><span>(</span>s2<span>[</span>i<span>]</span><span>)</span><span>&amp;&amp;</span><span>!</span>s1<span>.</span><span>includes</span><span>(</span>s2<span>[</span>i<span>]</span><span>)</span><span>)</span> res<span>.</span><span>push</span><span>(</span>s2<span>[</span>i<span>]</span><span>)</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><h2 id="_888-公平的糖果棒交换"> 888.公平的糖果棒交换</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=888 lang=javascript
 *
 * [888] 公平的糖果棒交换
 * 
 * 爱丽丝和鲍勃拥有不同总数量的糖果。给你两个数组 aliceSizes 和 bobSizes ，aliceSizes[i] 是爱丽丝拥有的第 i 盒糖果中的糖果数量，bobSizes[j] 是鲍勃拥有的第 j 盒糖果中的糖果数量。

两人想要互相交换一盒糖果，这样在交换之后，他们就可以拥有相同总数量的糖果。一个人拥有的糖果总数量是他们每盒糖果数量的总和。

返回一个整数数组 answer，其中 answer[0] 是爱丽丝必须交换的糖果盒中的糖果的数目，answer[1] 是鲍勃必须交换的糖果盒中的糖果的数目。如果存在多个答案，你可以返回其中 任何一个 。题目测试用例保证存在与输入对应的答案。

 

示例 1：

输入：aliceSizes = [1,1], bobSizes = [2,2]
输出：[1,2]
示例 2：

输入：aliceSizes = [1,2], bobSizes = [2,3]
输出：[1,2]
示例 3：

输入：aliceSizes = [2], bobSizes = [1,3]
输出：[2,3]
示例 4：

输入：aliceSizes = [1,2,5], bobSizes = [2,4]
输出：[5,4]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} aliceSizes
 * @param {number[]} bobSizes
 * @return {number[]}
 */</span>
<span>var</span> <span>fairCandySwap</span> <span>=</span> <span>function</span> <span>(</span><span>aliceSizes<span>,</span> bobSizes</span><span>)</span> <span>{</span>
  <span>const</span> a <span>=</span> aliceSizes<span>.</span><span>reduce</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a <span>+</span> b<span>,</span> <span>0</span><span>)</span><span>,</span> b <span>=</span> bobSizes<span>.</span><span>reduce</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a <span>+</span> b<span>,</span> <span>0</span><span>)</span><span>,</span> diff <span>=</span> <span>(</span>a <span>-</span> b<span>)</span> <span>>></span> <span>1</span><span>,</span> set <span>=</span> <span>new</span> <span>Set</span><span>(</span>aliceSizes<span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> bobSizes<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span><span>(</span>set<span>.</span><span>has</span><span>(</span>bobSizes<span>[</span>i<span>]</span><span>+</span>diff<span>)</span><span>)</span>  <span>return</span> <span>[</span>bobSizes<span>[</span>i<span>]</span><span>+</span>diff<span>,</span>bobSizes<span>[</span>i<span>]</span><span>]</span>  
  <span>}</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><h2 id="_892-三维形体的表面积"> 892.三维形体的表面积</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=892 lang=typescript

给你一个 n * n 的网格 grid ，上面放置着一些 1 x 1 x 1 的正方体。每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。

放置好正方体后，任何直接相邻的正方体都会互相粘在一起，形成一些不规则的三维形体。

请你返回最终这些形体的总表面积。

注意：每个形体的底面也需要计入表面积中。

 

示例 1：


输入：grid = [[1,2],[3,4]]
输出：34
示例 2：


输入：grid = [[1,1,1],[1,0,1],[1,1,1]]
输出：32
示例 3：


输入：grid = [[2,2,2],[2,1,2],[2,2,2]]
输出：46
 
 *
 * [892] 三维形体的表面积
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>surfaceArea</span><span>(</span>grid<span>:</span> <span>number</span><span>[</span><span>]</span><span>[</span><span>]</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>let</span> x <span>=</span> <span>0</span><span>,</span>
    y <span>=</span> <span>0</span><span>,</span>
    z <span>=</span> <span>0</span><span>,</span>
    v <span>=</span> <span>0</span><span>;</span>
  <span>const</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> grid<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> grid<span>[</span>i<span>]</span><span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
      v <span>+=</span> grid<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>;</span>
      <span>if</span> <span>(</span>j <span>&lt;</span> grid<span>[</span>i<span>]</span><span>.</span>length <span>-</span> <span>1</span><span>)</span> x <span>+=</span> Math<span>.</span><span>min</span><span>(</span>grid<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>,</span> grid<span>[</span>i<span>]</span><span>[</span>j <span>+</span> <span>1</span><span>]</span><span>)</span><span>;</span>
      <span>if</span> <span>(</span>grid<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>)</span> z <span>+=</span> grid<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>-</span> <span>1</span><span>;</span>
      <span>if</span> <span>(</span>map<span>.</span><span>has</span><span>(</span>j<span>)</span><span>)</span> y <span>+=</span> Math<span>.</span><span>min</span><span>(</span>map<span>.</span><span>get</span><span>(</span>j<span>)</span><span>,</span> grid<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>)</span><span>;</span>
      map<span>.</span><span>set</span><span>(</span>j<span>,</span> grid<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>6</span> <span>*</span> v <span>-</span> <span>(</span>x <span>+</span> y <span>+</span> z<span>)</span> <span>*</span> <span>2</span><span>;</span>
<span>}</span>
<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><h2 id="_896-单调数列"> 896.单调数列</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=896 lang=javascript
 *
 * [896] 单调数列
 * 
 * 如果数组是单调递增或单调递减的，那么它是 单调 的。

如果对于所有 i &lt;= j，nums[i] &lt;= nums[j]，那么数组 nums 是单调递增的。 如果对于所有 i &lt;= j，nums[i]> = nums[j]，那么数组 nums 是单调递减的。

当给定的数组 nums 是单调数组时返回 true，否则返回 false。

 

示例 1：

输入：nums = [1,2,2,3]
输出：true
示例 2：

输入：nums = [6,5,4,4]
输出：true
示例 3：

输入：nums = [1,3,2]
输出：false
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {boolean}
 */</span>
<span>var</span> <span>isMonotonic</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
  <span>let</span> state <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>state <span>||</span> state <span>===</span> <span>2</span><span>)</span> <span>{</span>
      state <span>=</span> nums<span>[</span>i <span>+</span> <span>1</span><span>]</span> <span>></span> nums<span>[</span>i<span>]</span> <span>?</span> <span>1</span> <span>:</span> nums<span>[</span>i <span>+</span> <span>1</span><span>]</span> <span>===</span> nums<span>[</span>i<span>]</span> <span>?</span> <span>2</span> <span>:</span> <span>3</span>
      <span>continue</span>
    <span>}</span>
    <span>if</span> <span>(</span><span>(</span>state <span>===</span> <span>1</span> <span>&amp;&amp;</span> <span>(</span>nums<span>[</span>i <span>+</span> <span>1</span><span>]</span> <span>&lt;</span> nums<span>[</span>i<span>]</span><span>)</span><span>)</span> <span>||</span> <span>(</span>state <span>===</span> <span>3</span> <span>&amp;&amp;</span> <span>(</span>nums<span>[</span>i <span>+</span> <span>1</span><span>]</span> <span>></span> nums<span>[</span>i<span>]</span><span>)</span><span>)</span><span>)</span> <span>return</span> <span>false</span>
  <span>}</span>
  <span>return</span> <span>true</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><h2 id="_905-按奇偶排序数组"> 905.按奇偶排序数组</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=905 lang=javascript
 *
 * [905] 按奇偶排序数组
 * 
 * 给你一个整数数组 nums，将 nums 中的的所有偶数元素移动到数组的前面，后跟所有奇数元素。

返回满足此条件的 任一数组 作为答案。

 

示例 1：

输入：nums = [3,1,2,4]
输出：[2,4,3,1]
解释：[4,2,3,1]、[2,4,1,3] 和 [4,2,1,3] 也会被视作正确答案。
示例 2：

输入：nums = [0]
输出：[0]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number[]}
 */</span>
<span>var</span> <span>sortArrayByParity</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>%</span> <span>2</span> <span>===</span> <span>0</span><span>)</span> res<span>.</span><span>unshift</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span>
    <span>else</span> res<span>.</span><span>push</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><h2 id="_908-最小差值-i"> 908.最小差值-i</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=908 lang=javascript
 *
 * [908] 最小差值 I
 * 
 * 给你一个整数数组 nums，和一个整数 k 。

在一个操作中，您可以选择 0 &lt;= i &lt; nums.length 的任何索引 i 。将 nums[i] 改为 nums[i] + x ，其中 x 是一个范围为 [-k, k] 的整数。对于每个索引 i ，最多 只能 应用 一次 此操作。

nums 的 分数 是 nums 中最大和最小元素的差值。 

在对  nums 中的每个索引最多应用一次上述操作后，返回 nums 的最低 分数 。

 

示例 1：

输入：nums = [1], k = 0
输出：0
解释：分数是 max(nums) - min(nums) = 1 - 1 = 0。
示例 2：

输入：nums = [0,10], k = 2
输出：6
解释：将 nums 改为 [2,8]。分数是 max(nums) - min(nums) = 8 - 2 = 6。
示例 3：

输入：nums = [1,3,6], k = 3
输出：0
解释：将 nums 改为 [4,4,4]。分数是 max(nums) - min(nums) = 4 - 4 = 0。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */</span>
<span>var</span> <span>smallestRangeI</span> <span>=</span> <span>function</span> <span>(</span><span>nums<span>,</span> k</span><span>)</span> <span>{</span>
  <span>const</span> min <span>=</span> Math<span>.</span><span>min</span><span>(</span><span>...</span>nums<span>)</span><span>,</span> max <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>...</span>nums<span>)</span><span>,</span> res <span>=</span> max <span>-</span> min <span>-</span> <span>(</span><span>2</span> <span>*</span> k<span>)</span>
  <span>return</span> res <span>></span> <span>0</span> <span>?</span> res <span>:</span> <span>0</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h2 id="_914-卡牌分组"> 914.卡牌分组</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=914 lang=javascript
 *
 * [914] 卡牌分组
 * 
 * 给定一副牌，每张牌上都写着一个整数。

此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：

每组都有 X 张牌。
组内所有的牌上都写着相同的整数。
仅当你可选的 X >= 2 时返回 true。

 

示例 1：

输入：deck = [1,2,3,4,4,3,2,1]
输出：true
解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]
示例 2：

输入：deck = [1,1,1,2,2,2,3,3]
输出：false
解释：没有满足要求的分组。

 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} deck
 * @return {boolean}
 */</span>
<span>var</span> <span>hasGroupsSizeX</span> <span>=</span> <span>function</span> <span>(</span><span>deck</span><span>)</span> <span>{</span>
  <span>const</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span>
  <span>let</span> max <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> deck<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>map<span>.</span><span>has</span><span>(</span>deck<span>[</span>i<span>]</span><span>)</span><span>)</span> map<span>.</span><span>set</span><span>(</span>deck<span>[</span>i<span>]</span><span>,</span> <span>1</span><span>)</span>
    <span>else</span> map<span>.</span><span>set</span><span>(</span>deck<span>[</span>i<span>]</span><span>,</span> map<span>.</span><span>get</span><span>(</span>deck<span>[</span>i<span>]</span><span>)</span> <span>+</span> <span>1</span><span>)</span>
    max <span>=</span> Math<span>.</span><span>max</span><span>(</span>max<span>,</span> map<span>.</span><span>get</span><span>(</span>deck<span>[</span>i<span>]</span><span>)</span><span>)</span>
  <span>}</span>

  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;=</span> max<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>let</span> flag <span>=</span> <span>true</span>
    <span>for</span> <span>(</span><span>const</span> j <span>of</span> map<span>.</span><span>values</span><span>(</span><span>)</span><span>)</span> <span>{</span>
      <span>const</span> item <span>=</span> j <span>%</span> i <span>===</span> <span>0</span>
      flag <span>&amp;&amp;=</span> item
      <span>if</span> <span>(</span><span>!</span>item<span>)</span> <span>break</span>
    <span>}</span>
    <span>if</span> <span>(</span>flag<span>)</span> <span>return</span> <span>true</span>
  <span>}</span>
  <span>return</span> <span>false</span>
<span>}</span><span>;</span>

<span>// var checkNum = function (num, k) {</span>
<span>//   while (num > 1) {</span>
<span>//     if (num % k === 0) num /= k</span>
<span>//     else return false</span>
<span>//   }</span>
<span>//   return true</span>
<span>// }</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br></div></div><h2 id="_917-仅仅反转字母"> 917.仅仅反转字母</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=917 lang=javascript
 *
 * [917] 仅仅反转字母
 * 
 * 给你一个字符串 s ，根据下述规则反转字符串：

所有非英文字母保留在原有位置。
所有英文字母（小写或大写）位置反转。
返回反转后的 s 。

 

示例 1：

输入：s = "ab-cd"
输出："dc-ba"
示例 2：

输入：s = "a-bC-dEf-ghIj"
输出："j-Ih-gfE-dCba"
示例 3：

输入：s = "Test1ng-Leet=code-Q!"
输出："Qedo1ct-eeLg=ntse-T!"
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @return {string}
 */</span>
<span>var</span> <span>reverseOnlyLetters</span> <span>=</span> <span>function</span> <span>(</span><span>s</span><span>)</span> <span>{</span>
  s <span>=</span> s<span>.</span><span>split</span><span>(</span><span>""</span><span>)</span>
  <span>let</span> start <span>=</span> <span>0</span><span>,</span> end <span>=</span> s<span>.</span>length <span>-</span> <span>1</span>
  <span>while</span> <span>(</span>start <span>&lt;</span> end<span>)</span> <span>{</span>
    <span>const</span> flagStart <span>=</span> <span><span>/</span><span>[a-z]</span><span>/</span><span>i</span></span><span>.</span><span>test</span><span>(</span>s<span>[</span>start<span>]</span><span>)</span><span>,</span>
      flagEnd <span>=</span> <span><span>/</span><span>[a-z]</span><span>/</span><span>i</span></span><span>.</span><span>test</span><span>(</span>s<span>[</span>end<span>]</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>flagStart <span>&amp;&amp;</span> flagEnd<span>)</span> <span>{</span>
      <span>[</span>s<span>[</span>start<span>]</span><span>,</span> s<span>[</span>end<span>]</span><span>]</span> <span>=</span> <span>[</span>s<span>[</span>end<span>]</span><span>,</span> s<span>[</span>start<span>]</span><span>]</span>
      start<span>++</span>
      end<span>--</span>
      <span>continue</span>
    <span>}</span>
    <span>if</span> <span>(</span><span>!</span>flagStart<span>)</span> start<span>++</span>
    <span>if</span> <span>(</span><span>!</span>flagEnd<span>)</span> end<span>--</span>
  <span>}</span>
  <span>return</span> s<span>.</span><span>join</span><span>(</span><span>""</span><span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><h2 id="_922-按奇偶排序数组-ii"> 922.按奇偶排序数组-ii</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=922 lang=javascript
 *
 * [922] 按奇偶排序数组 II
 * 
 * 给定一个非负整数数组 nums，  nums 中一半整数是 奇数 ，一半整数是 偶数 。

对数组进行排序，以便当 nums[i] 为奇数时，i 也是 奇数 ；当 nums[i] 为偶数时， i 也是 偶数 。

你可以返回 任何满足上述条件的数组作为答案 。

 

示例 1：

输入：nums = [4,2,5,7]
输出：[4,5,2,7]
解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。
示例 2：

输入：nums = [2,3]
输出：[2,3]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number[]}
 */</span>
<span>var</span> <span>sortArrayByParityII</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span>
  <span>while</span> <span>(</span>nums<span>.</span>length <span>></span> <span>0</span><span>)</span> <span>{</span>
    <span>const</span> item <span>=</span> nums<span>.</span><span>shift</span><span>(</span><span>)</span>
    <span>if</span> <span>(</span><span>(</span>res<span>.</span>length <span>%</span> <span>2</span> <span>===</span> <span>0</span> <span>&amp;&amp;</span> item <span>%</span> <span>2</span> <span>===</span> <span>0</span><span>)</span> <span>||</span> res<span>.</span>length <span>%</span> <span>2</span> <span>===</span> <span>1</span> <span>&amp;&amp;</span> item <span>%</span> <span>2</span> <span>===</span> <span>1</span><span>)</span> <span>{</span>
      res<span>.</span><span>push</span><span>(</span>item<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      nums<span>.</span><span>push</span><span>(</span>item<span>)</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><h2 id="_925-长按键入"> 925.长按键入</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=925 lang=typescript
 *
 * [925] 长按键入
 * 
 * 你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。

你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。

 

示例 1：

输入：name = "alex", typed = "aaleex"
输出：true
解释：'alex' 中的 'a' 和 'e' 被长按。
示例 2：

输入：name = "saeed", typed = "ssaaedd"
输出：false
解释：'e' 一定需要被键入两次，但在 typed 的输出中不是这样。
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>isLongPressedName</span><span>(</span>name<span>:</span> <span>string</span><span>,</span> typed<span>:</span> <span>string</span><span>)</span><span>:</span> <span>boolean</span> <span>{</span>
  <span>let</span> i1 <span>=</span> <span>0</span><span>,</span> i2 <span>=</span> <span>0</span>
  <span>while</span> <span>(</span>i1 <span>&lt;</span> name<span>.</span>length <span>||</span> i2 <span>&lt;</span> typed<span>.</span>length<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>name<span>[</span>i1<span>]</span> <span>===</span> typed<span>[</span>i2<span>]</span><span>)</span> <span>{</span>
      i1<span>++</span>
      i2<span>++</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>if</span> <span>(</span>typed<span>[</span>i2<span>]</span> <span>===</span> name<span>[</span>i1 <span>-</span> <span>1</span><span>]</span><span>)</span> i2<span>++</span>
      <span>else</span> <span>return</span> <span>false</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>true</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id="_929-独特的电子邮件地址"> 929.独特的电子邮件地址</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=929 lang=javascript
 *
 * [929] 独特的电子邮件地址
 * 
 * 每个 有效电子邮件地址 都由一个 本地名 和一个 域名 组成，以 '@' 符号分隔。除小写字母之外，电子邮件地址还可以含有一个或多个 '.' 或 '+' 。

例如，在 alice@leetcode.com中， alice 是 本地名 ，而 leetcode.com 是 域名 。
如果在电子邮件地址的 本地名 部分中的某些字符之间添加句点（'.'），则发往那里的邮件将会转发到本地名中没有点的同一地址。请注意，此规则 不适用于域名 。

例如，"alice.z@leetcode.com” 和 “alicez@leetcode.com” 会转发到同一电子邮件地址。
如果在 本地名 中添加加号（'+'），则会忽略第一个加号后面的所有内容。这允许过滤某些电子邮件。同样，此规则 不适用于域名 。

例如 m.y+name@email.com 将转发到 my@email.com。
可以同时使用这两个规则。

给你一个字符串数组 emails，我们会向每个 emails[i] 发送一封电子邮件。返回实际收到邮件的不同地址数目。

 

示例 1：

输入：emails = ["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"]
输出：2
解释：实际收到邮件的是 "testemail@leetcode.com" 和 "testemail@lee.tcode.com"。
示例 2：

输入：emails = ["a@leetcode.com","b@leetcode.com","c@leetcode.com"]
输出：3

 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string[]} emails
 * @return {number}
 */</span>
<span>var</span> <span>numUniqueEmails</span> <span>=</span> <span>function</span><span>(</span><span>emails</span><span>)</span> <span>{</span>
  emails <span>=</span> emails<span>.</span><span>map</span><span>(</span><span>item</span><span>=></span><span>{</span>
    <span>const</span> arr <span>=</span> item<span>.</span><span>split</span><span>(</span><span>"@"</span><span>)</span>
    arr<span>[</span><span>0</span><span>]</span> <span>=</span> arr<span>[</span><span>0</span><span>]</span><span>.</span><span>split</span><span>(</span><span>"+"</span><span>)</span><span>[</span><span>0</span><span>]</span><span>.</span><span>replace</span><span>(</span><span><span>/</span><span>\.</span><span>/</span><span>g</span></span><span>,</span><span>""</span><span>)</span>
    <span>return</span> arr<span>.</span><span>join</span><span>(</span><span>"@"</span><span>)</span>
  <span>}</span><span>)</span>
  <span>return</span> <span>new</span> <span>Set</span><span>(</span>emails<span>)</span><span>.</span>size
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><h2 id="_933-最近的请求次数"> 933.最近的请求次数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=933 lang=javascript
 *
 * [933] 最近的请求次数
 * 
 * 写一个 RecentCounter 类来计算特定时间范围内最近的请求。

请你实现 RecentCounter 类：

RecentCounter() 初始化计数器，请求数为 0 。
int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。
保证 每次对 ping 的调用都使用比之前更大的 t 值。

 

示例 1：

输入：
["RecentCounter", "ping", "ping", "ping", "ping"]
[[], [1], [100], [3001], [3002]]
输出：
[null, 1, 2, 3, 3]

解释：
RecentCounter recentCounter = new RecentCounter();
recentCounter.ping(1);     // requests = [1]，范围是 [-2999,1]，返回 1
recentCounter.ping(100);   // requests = [1, 100]，范围是 [-2900,100]，返回 2
recentCounter.ping(3001);  // requests = [1, 100, 3001]，范围是 [1,3001]，返回 3
recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3
 
 */</span>

<span>// @lc code=start</span>

<span>var</span> <span>RecentCounter</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span>set <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>)</span>
<span>}</span><span>;</span>

<span>/** 
 * @param {number} t
 * @return {number}
 */</span>
<span>RecentCounter</span><span>.</span>prototype<span>.</span><span>ping</span> <span>=</span> <span>function</span> <span>(</span><span>t</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>const</span> i <span>of</span> <span>this</span><span>.</span>set<span>.</span><span>keys</span><span>(</span><span>)</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>i <span>+</span> <span>3000</span> <span>&lt;</span> t<span>)</span> <span>this</span><span>.</span>set<span>.</span><span>delete</span><span>(</span>i<span>)</span>
    <span>else</span> <span>break</span>
  <span>}</span>
  <span>this</span><span>.</span>set<span>.</span><span>add</span><span>(</span>t<span>)</span>
  <span>return</span> <span>this</span><span>.</span>set<span>.</span>size
<span>}</span><span>;</span>

<span>/**
 * Your RecentCounter object will be instantiated and called as such:
 * var obj = new RecentCounter()
 * var param_1 = obj.ping(t)
 */</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br></div></div><h2 id="_937-重新排列日志文件"> 937.重新排列日志文件</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=937 lang=javascript
 *
 * [937] 重新排列日志文件
 * 
 * 给你一个日志数组 logs。每条日志都是以空格分隔的字串，其第一个字为字母与数字混合的 标识符 。

有两种不同类型的日志：

字母日志：除标识符之外，所有字均由小写字母组成
数字日志：除标识符之外，所有字均由数字组成
请按下述规则将日志重新排序：

所有 字母日志 都排在 数字日志 之前。
字母日志 在内容不同时，忽略标识符后，按内容字母顺序排序；在内容相同时，按标识符排序。
数字日志 应该保留原来的相对顺序。
返回日志的最终顺序。

 

示例 1：

输入：logs = ["dig1 8 1 5 1","let1 art can","dig2 3 6","let2 own kit dig","let3 art zero"]
输出：["let1 art can","let3 art zero","let2 own kit dig","dig1 8 1 5 1","dig2 3 6"]
解释：
字母日志的内容都不同，所以顺序为 "art can", "art zero", "own kit dig" 。
数字日志保留原来的相对顺序 "dig1 8 1 5 1", "dig2 3 6" 。
示例 2：

输入：logs = ["a1 9 2 3 1","g1 act car","zo4 4 7","ab1 off key dog","a8 act zoo"]
输出：["g1 act car","a8 act zoo","ab1 off key dog","a1 9 2 3 1","zo4 4 7"]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string[]} logs
 * @return {string[]}
 */</span>
<span>var</span> <span>reorderLogFiles</span> <span>=</span> <span>function</span> <span>(</span><span>logs</span><span>)</span> <span>{</span>
  <span>let</span> zimu <span>=</span> <span>[</span><span>]</span><span>,</span> shuzi <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> logs<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> str <span>=</span> logs<span>[</span>i<span>]</span><span>.</span><span>slice</span><span>(</span>logs<span>[</span>i<span>]</span><span>.</span><span>indexOf</span><span>(</span><span>" "</span><span>)</span> <span>+</span> <span>1</span><span>)</span>
    <span>if</span> <span>(</span><span><span>/</span><span>\d</span><span>/</span></span><span>.</span><span>test</span><span>(</span>str<span>[</span><span>0</span><span>]</span><span>)</span><span>)</span> <span>{</span>
      shuzi<span>.</span><span>push</span><span>(</span>logs<span>[</span>i<span>]</span><span>)</span>
      <span>continue</span>
    <span>}</span>
    zimu<span>.</span><span>push</span><span>(</span>logs<span>[</span>i<span>]</span><span>)</span>
  <span>}</span>
  zimu <span>=</span> zimu<span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> <span>{</span>
    <span>const</span> a1 <span>=</span> a<span>.</span><span>slice</span><span>(</span>a<span>.</span><span>indexOf</span><span>(</span><span>" "</span><span>)</span> <span>+</span> <span>1</span><span>)</span><span>,</span> b1 <span>=</span> b<span>.</span><span>slice</span><span>(</span>b<span>.</span><span>indexOf</span><span>(</span><span>" "</span><span>)</span> <span>+</span> <span>1</span><span>)</span>
    <span>const</span> n <span>=</span> a1<span>.</span><span>localeCompare</span><span>(</span>b1<span>)</span>
    <span>if</span> <span>(</span>n <span>===</span> <span>0</span><span>)</span> <span>return</span> a<span>.</span><span>localeCompare</span><span>(</span>b<span>)</span>
    <span>else</span> <span>return</span> n
  <span>}</span><span>)</span>
  <span>return</span> <span>[</span><span>...</span>zimu<span>,</span> <span>...</span>shuzi<span>]</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br></div></div><h2 id="_941-有效的山脉数组"> 941.有效的山脉数组</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=941 lang=typescript
 *
 * [941] 有效的山脉数组
 * 
 * 给定一个整数数组 arr，如果它是有效的山脉数组就返回 true，否则返回 false。

让我们回顾一下，如果 arr 满足下述条件，那么它是一个山脉数组：

arr.length >= 3
在 0 &lt; i &lt; arr.length - 1 条件下，存在 i 使得：
arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i] 
arr[i] > arr[i+1] > ... > arr[arr.length - 1]
 



 

示例 1：

输入：arr = [2,1]
输出：false
示例 2：

输入：arr = [3,5,5]
输出：false
示例 3：

输入：arr = [0,3,2,1]
输出：true
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>validMountainArray</span><span>(</span>arr<span>:</span> <span>number</span><span>[</span><span>]</span><span>)</span><span>:</span> <span>boolean</span> <span>{</span>
  <span>if</span> <span>(</span>arr<span>.</span>length <span>&lt;</span> <span>3</span><span>)</span> <span>return</span> <span>false</span>
  <span>const</span> max <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>...</span>arr<span>)</span>
  <span>const</span> maxI <span>=</span> arr<span>.</span><span>indexOf</span><span>(</span>max<span>)</span>
  <span>if</span> <span>(</span>maxI <span>===</span> <span>0</span> <span>||</span> maxI <span>===</span> arr<span>.</span>length <span>-</span> <span>1</span><span>)</span> <span>return</span> <span>false</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>i <span>&lt;</span> maxI<span>)</span> <span>{</span>
      <span>if</span> <span>(</span>arr<span>[</span>i<span>]</span> <span>&lt;=</span> arr<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span> <span>return</span> <span>false</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>i <span>></span> maxI<span>)</span> <span>{</span>
      <span>if</span> <span>(</span>arr<span>[</span>i<span>]</span> <span>>=</span> arr<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span> <span>return</span> <span>false</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>true</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><h2 id="_942-增减字符串匹配"> 942.增减字符串匹配</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=942 lang=javascript
 *
 * [942] 增减字符串匹配
 * 
 * 由范围 [0,n] 内所有整数组成的 n + 1 个整数的排列序列可以表示为长度为 n 的字符串 s ，其中:

如果 perm[i] &lt; perm[i + 1] ，那么 s[i] == 'I' 
如果 perm[i] > perm[i + 1] ，那么 s[i] == 'D' 
给定一个字符串 s ，重构排列 perm 并返回它。如果有多个有效排列perm，则返回其中 任何一个 。

 

示例 1：

输入：s = "IDID"
输出：[0,4,1,3,2]
示例 2：

输入：s = "III"
输出：[0,1,2,3]
示例 3：

输入：s = "DDI"
输出：[3,2,0,1]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @return {number[]}
 */</span>
<span>var</span> <span>diStringMatch</span> <span>=</span> <span>function</span> <span>(</span><span>s</span><span>)</span> <span>{</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span><span>,</span> len <span>=</span> s<span>.</span>length<span>,</span> arr <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;=</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    arr<span>.</span><span>push</span><span>(</span>i<span>)</span>
  <span>}</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>let</span> item
    <span>if</span> <span>(</span>s<span>[</span>i<span>]</span> <span>===</span> <span>"I"</span><span>)</span> <span>{</span>
      item <span>=</span> arr<span>.</span><span>shift</span><span>(</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      item <span>=</span> arr<span>.</span><span>pop</span><span>(</span><span>)</span>
    <span>}</span>
    res<span>.</span><span>push</span><span>(</span>item<span>)</span>
  <span>}</span>
  res<span>.</span><span>push</span><span>(</span>arr<span>[</span><span>0</span><span>]</span><span>)</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><h2 id="_944-删列造序"> 944.删列造序</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=944 lang=javascript
 *
 * [944] 删列造序
 * 
 * 给你由 n 个小写字母字符串组成的数组 strs，其中每个字符串长度相等。

这些字符串可以每个一行，排成一个网格。例如，strs = ["abc", "bce", "cae"] 可以排列为：

abc
bce
cae
你需要找出并删除 不是按字典序升序排列的 列。在上面的例子（下标从 0 开始）中，列 0（'a', 'b', 'c'）和列 2（'c', 'e', 'e'）都是按升序排列的，而列 1（'b', 'c', 'a'）不是，所以要删除列 1 。

返回你需要删除的列数。

 

示例 1：

输入：strs = ["cba","daf","ghi"]
输出：1
解释：网格示意如下：
  cba
  daf
  ghi
列 0 和列 2 按升序排列，但列 1 不是，所以只需要删除列 1 。
示例 2：

输入：strs = ["a","b"]
输出：0
解释：网格示意如下：
  a
  b
只有列 0 这一列，且已经按升序排列，所以不用删除任何列。
示例 3：

输入：strs = ["zyx","wvu","tsr"]
输出：3
解释：网格示意如下：
  zyx
  wvu
  tsr
所有 3 列都是非升序排列的，所以都要删除。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string[]} strs
 * @return {number}
 */</span>
<span>var</span> <span>minDeletionSize</span> <span>=</span> <span>function</span> <span>(</span><span>strs</span><span>)</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> strs<span>[</span><span>0</span><span>]</span><span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> strs<span>.</span>length <span>-</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>strs<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>></span> strs<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>[</span>j<span>]</span><span>)</span> <span>{</span>
        res<span>++</span>
        <span>break</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br></div></div><h2 id="_953-验证外星语词典"> 953.验证外星语词典</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=953 lang=typescript
 *
 * [953] 验证外星语词典
 * 
 * 某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。

给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false。

 

示例 1：

输入：words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"
输出：true
解释：在该语言的字母表中，'h' 位于 'l' 之前，所以单词序列是按字典序排列的。
示例 2：

输入：words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz"
输出：false
解释：在该语言的字母表中，'d' 位于 'l' 之后，那么 words[0] > words[1]，因此单词序列不是按字典序排列的。
示例 3：

输入：words = ["apple","app"], order = "abcdefghijklmnopqrstuvwxyz"
输出：false
解释：当前三个字符 "app" 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 "apple" > "app"，因为 'l' > '∅'，其中 '∅' 是空白字符，定义为比任何其他字符都小（更多信息）。
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>isAlienSorted</span><span>(</span>words<span>:</span> <span>string</span><span>[</span><span>]</span><span>,</span> order<span>:</span> <span>string</span><span>)</span><span>:</span> <span>boolean</span> <span>{</span>
  <span>const</span> alphabets <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>;</span>
  <span>for</span><span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> order<span>.</span>length<span>;</span> i<span>++</span><span>)</span><span>{</span>
      alphabets<span>.</span><span>set</span><span>(</span>order<span>[</span>i<span>]</span><span>,</span> String<span>.</span><span>fromCharCode</span><span>(</span>i<span>+</span><span>97</span><span>)</span><span>)</span>
  <span>}</span>
  <span>const</span> <span>transformWord</span> <span>=</span> <span>(</span>word<span>:</span> <span>string</span><span>)</span><span>=></span> word<span>.</span><span>split</span><span>(</span><span>''</span><span>)</span><span>.</span><span>map</span><span>(</span>alp <span>=></span> alphabets<span>.</span><span>get</span><span>(</span>alp<span>)</span><span>)</span><span>.</span><span>join</span><span>(</span><span>''</span><span>)</span>
  <span>for</span><span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> words<span>.</span>length<span>;</span> i<span>++</span><span>)</span><span>{</span>
      <span>if</span><span>(</span><span>transformWord</span><span>(</span>words<span>[</span>i<span>-</span><span>1</span><span>]</span><span>)</span> <span>></span> <span>transformWord</span><span>(</span>words<span>[</span>i<span>]</span><span>)</span><span>)</span> <span>return</span> <span>false</span>
  <span>}</span>
  <span>return</span> <span>true</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h2 id="_961-在长度-2-n-的数组中找出重复-n-次的元素"> 961.在长度-2-n-的数组中找出重复-n-次的元素</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=961 lang=javascript
 *
 * [961] 在长度 2N 的数组中找出重复 N 次的元素
 * 
 * 给你一个整数数组 nums ，该数组具有以下属性：

nums.length == 2 * n.
nums 包含 n + 1 个 不同的 元素
nums 中恰有一个元素重复 n 次
找出并返回重复了 n 次的那个元素。

 

示例 1：

输入：nums = [1,2,3,3]
输出：3
示例 2：

输入：nums = [2,1,2,5,3,2]
输出：2
示例 3：

输入：nums = [5,1,5,2,5,3,5,4]
输出：5
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number}
 */</span>
<span>var</span> <span>repeatedNTimes</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
  <span>const</span> n <span>=</span> nums<span>.</span>length <span>/</span> <span>2</span><span>,</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>map<span>.</span><span>has</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span><span>)</span> map<span>.</span><span>set</span><span>(</span>nums<span>[</span>i<span>]</span><span>,</span> <span>1</span><span>)</span>
    <span>else</span> <span>{</span>
      <span>const</span> a <span>=</span> map<span>.</span><span>get</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span> <span>+</span> <span>1</span>
      <span>if</span> <span>(</span>a <span>===</span> n<span>)</span> <span>return</span> nums<span>[</span>i<span>]</span>
      map<span>.</span><span>set</span><span>(</span>nums<span>[</span>i<span>]</span><span>,</span> a<span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><h2 id="_976-三角形的最大周长"> 976.三角形的最大周长</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=976 lang=javascript
 *
 * [976] 三角形的最大周长
 * 
 * 给定由一些正数（代表长度）组成的数组 nums ，返回 由其中三个长度组成的、面积不为零的三角形的最大周长 。如果不能形成任何面积不为零的三角形，返回 0。

 

示例 1：

输入：nums = [2,1,2]
输出：5
解释：你可以用三个边长组成一个三角形:1 2 2。
示例 2：

输入：nums = [1,2,1,10]
输出：0
解释：
你不能用边长 1,1,2 来组成三角形。
不能用边长 1,1,10 来构成三角形。
不能用边长 1、2 和 10 来构成三角形。
因为我们不能用任何三条边长来构成一个非零面积的三角形，所以我们返回 0。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number}
 */</span>
<span>var</span> <span>largestPerimeter</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
  nums <span>=</span> nums<span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> b <span>-</span> a<span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>+</span> nums<span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>></span> nums<span>[</span>i <span>-</span> <span>2</span><span>]</span><span>)</span> <span>{</span>
      <span>return</span> nums<span>[</span>i<span>]</span> <span>+</span> nums<span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>+</span> nums<span>[</span>i <span>-</span> <span>2</span><span>]</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>0</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><h2 id="_977-有序数组的平方"> 977.有序数组的平方</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=977 lang=javascript
 *
 * [977] 有序数组的平方
 * 
 * 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

 

示例 1：

输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
示例 2：

输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number[]}
 */</span>
<span>const</span> <span>sortedSquares</span> <span>=</span> <span>nums</span> <span>=></span> nums<span>.</span><span>map</span><span>(</span><span>item</span> <span>=></span> Math<span>.</span><span>pow</span><span>(</span>item<span>,</span> <span>2</span><span>)</span><span>)</span><span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a <span>-</span> b<span>)</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><h2 id="_989-数组形式的整数加法"> 989.数组形式的整数加法</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=989 lang=javascript
 *
 * [989] 数组形式的整数加法
 * 
 * 整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。

例如，对于 num = 1321 ，数组形式是 [1,3,2,1] 。
给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。

 

示例 1：

输入：num = [1,2,0,0], k = 34
输出：[1,2,3,4]
解释：1200 + 34 = 1234
示例 2：

输入：num = [2,7,4], k = 181
输出：[4,5,5]
解释：274 + 181 = 455
示例 3：

输入：num = [2,1,5], k = 806
输出：[1,0,2,1]
解释：215 + 806 = 1021
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} num
 * @param {number} k
 * @return {number[]}
 */</span>
<span>var</span> <span>addToArrayForm</span> <span>=</span> <span>function</span> <span>(</span><span>num<span>,</span> k</span><span>)</span> <span>{</span>
  num<span>[</span>num<span>.</span>length <span>-</span> <span>1</span><span>]</span> <span>=</span> num<span>[</span>num<span>.</span>length <span>-</span> <span>1</span><span>]</span> <span>+</span> k
  <span>let</span> flag <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> num<span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
    <span>const</span> i <span>=</span> num<span>.</span>length <span>-</span> <span>1</span> <span>-</span> j
    num<span>[</span>i<span>]</span> <span>=</span> num<span>[</span>i<span>]</span> <span>+</span> flag
    flag <span>=</span> <span>0</span>
    <span>if</span> <span>(</span>num<span>[</span>i<span>]</span> <span>></span> <span>9</span><span>)</span> <span>{</span>
      flag <span>=</span> <span>parseInt</span><span>(</span>num<span>[</span>i<span>]</span> <span>/</span> <span>10</span><span>)</span>
      num<span>[</span>i<span>]</span> <span>=</span> num<span>[</span>i<span>]</span> <span>%</span> <span>10</span>
      <span>if</span> <span>(</span>i <span>===</span> <span>0</span><span>)</span> <span>{</span>
        num<span>.</span><span>unshift</span><span>(</span>flag<span>)</span>
        flag <span>=</span> <span>0</span>
      <span>}</span>
      <span>continue</span>
    <span>}</span>
    <span>return</span> num
  <span>}</span>
<span>}</span><span>;</span>

<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div><h2 id="_997-找到小镇的法官"> 997.找到小镇的法官</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=997 lang=javascript
 *
 * [997] 找到小镇的法官
 * 
 * 小镇里有 n 个人，按从 1 到 n 的顺序编号。传言称，这些人中有一个暗地里是小镇法官。

如果小镇法官真的存在，那么：

小镇法官不会信任任何人。
每个人（除了小镇法官）都信任这位小镇法官。
只有一个人同时满足属性 1 和属性 2 。
给你一个数组 trust ，其中 trust[i] = [ai, bi] 表示编号为 ai 的人信任编号为 bi 的人。

如果小镇法官存在并且可以确定他的身份，请返回该法官的编号；否则，返回 -1 。

 

示例 1：

输入：n = 2, trust = [[1,2]]
输出：2
示例 2：

输入：n = 3, trust = [[1,3],[2,3]]
输出：3
示例 3：

输入：n = 3, trust = [[1,3],[2,3],[3,1]]
输出：-1
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} n
 * @param {number[][]} trust
 * @return {number}
 */</span>
<span>var</span> <span>findJudge</span> <span>=</span> <span>function</span> <span>(</span><span>n<span>,</span> trust</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>trust<span>.</span>length <span>===</span> <span>0</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>n <span>===</span> <span>1</span><span>)</span> <span>return</span> <span>1</span>
    <span>else</span> <span>return</span> <span>-</span><span>1</span>
  <span>}</span>
  <span>const</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>,</span> map2 <span>=</span> <span>new</span> <span>Map</span><span>(</span>trust<span>)</span>
  <span>let</span> max <span>=</span> trust<span>[</span><span>0</span><span>]</span><span>[</span><span>1</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> trust<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>map<span>.</span><span>has</span><span>(</span>trust<span>[</span>i<span>]</span><span>[</span><span>1</span><span>]</span><span>)</span><span>)</span> <span>{</span>
      map<span>.</span><span>set</span><span>(</span>trust<span>[</span>i<span>]</span><span>[</span><span>1</span><span>]</span><span>,</span> <span>[</span>trust<span>[</span>i<span>]</span><span>[</span><span>0</span><span>]</span><span>]</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      map<span>.</span><span>get</span><span>(</span>trust<span>[</span>i<span>]</span><span>[</span><span>1</span><span>]</span><span>)</span><span>.</span><span>push</span><span>(</span>trust<span>[</span>i<span>]</span><span>[</span><span>0</span><span>]</span><span>)</span>
    <span>}</span>
    <span>if</span> <span>(</span>map<span>.</span><span>get</span><span>(</span>trust<span>[</span>i<span>]</span><span>[</span><span>1</span><span>]</span><span>)</span><span>.</span>length <span>></span> map<span>.</span><span>get</span><span>(</span>max<span>)</span><span>.</span>length<span>)</span> max <span>=</span> trust<span>[</span>i<span>]</span><span>[</span><span>1</span><span>]</span>
  <span>}</span>
  <span>if</span> <span>(</span>map2<span>.</span><span>get</span><span>(</span>max<span>)</span><span>)</span> <span>return</span> <span>-</span><span>1</span>
  <span>return</span> map<span>.</span><span>get</span><span>(</span>max<span>)</span><span>.</span>length <span>===</span> n <span>-</span> <span>1</span> <span>?</span> max <span>:</span> <span>-</span><span>1</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div><h2 id="_999-可以被一步捕获的棋子数"> 999.可以被一步捕获的棋子数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=999 lang=javascript
 *
 * [999] 可以被一步捕获的棋子数
 * 
 * 在一个 8 x 8 的棋盘上，有一个白色的车（Rook），用字符 'R' 表示。棋盘上还可能存在空方块，白色的象（Bishop）以及黑色的卒（pawn），分别用字符 '.'，'B' 和 'p' 表示。不难看出，大写字符表示的是白棋，小写字符表示的是黑棋。

车按国际象棋中的规则移动。东，西，南，北四个基本方向任选其一，然后一直向选定的方向移动，直到满足下列四个条件之一：

棋手选择主动停下来。
棋子因到达棋盘的边缘而停下。
棋子移动到某一方格来捕获位于该方格上敌方（黑色）的卒，停在该方格内。
车不能进入/越过已经放有其他友方棋子（白色的象）的方格，停在友方棋子前。
你现在可以控制车移动一次，请你统计有多少敌方的卒处于你的捕获范围内（即，可以被一步捕获的棋子数）。

 

示例 1：



输入：[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","R",".",".",".","p"],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
输出：3
解释：
在本例中，车能够捕获所有的卒。
示例 2：



输入：[[".",".",".",".",".",".",".","."],[".","p","p","p","p","p",".","."],[".","p","p","B","p","p",".","."],[".","p","B","R","B","p",".","."],[".","p","p","B","p","p",".","."],[".","p","p","p","p","p",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
输出：0
解释：
象阻止了车捕获任何卒。
示例 3：



输入：[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","p",".",".",".","."],["p","p",".","R",".","p","B","."],[".",".",".",".",".",".",".","."],[".",".",".","B",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."]]
输出：3
解释： 
车可以捕获位置 b5，d6 和 f5 的卒。
 


 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {character[][]} board
 * @return {number}
 */</span>
<span>var</span> <span>numRookCaptures</span> <span>=</span> <span>function</span> <span>(</span><span>board</span><span>)</span> <span>{</span>
  <span>let</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>[</span><span>[</span><span>"R"</span><span>,</span> <span>[</span><span>]</span><span>]</span><span>,</span> <span>[</span><span>"B"</span><span>,</span> <span>[</span><span>]</span><span>]</span><span>,</span> <span>[</span><span>"p"</span><span>,</span> <span>[</span><span>]</span><span>]</span><span>]</span><span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>8</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> <span>8</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>board<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>!==</span> <span>"."</span><span>)</span> map<span>.</span><span>get</span><span>(</span>board<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>)</span><span>.</span><span>push</span><span>(</span><span>[</span>j<span>,</span> i<span>]</span><span>)</span>
    <span>}</span>
  <span>}</span>
  <span>const</span> params <span>=</span> <span>[</span>
    map<span>.</span><span>get</span><span>(</span><span>"R"</span><span>)</span><span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span><span>,</span>
    map<span>.</span><span>get</span><span>(</span><span>"R"</span><span>)</span><span>[</span><span>0</span><span>]</span><span>[</span><span>1</span><span>]</span><span>,</span>
    map<span>.</span><span>get</span><span>(</span><span>"B"</span><span>)</span><span>,</span>
    map<span>.</span><span>get</span><span>(</span><span>"p"</span><span>)</span>
  <span>]</span>
  <span>return</span> <span>checkEast</span><span>(</span><span>...</span>params<span>)</span> <span>+</span> <span>checkNorth</span><span>(</span><span>...</span>params<span>)</span> <span>+</span> <span>checkSouth</span><span>(</span><span>...</span>params<span>)</span> <span>+</span> <span>checkWest</span><span>(</span><span>...</span>params<span>)</span>
<span>}</span><span>;</span>

<span>/**
 * @param {number} x
 * @param {number} y
 * @param {number[][]} BList
 * @param {number[][]} pList
 * @return {number}
 */</span>
<span>var</span> <span>checkEast</span> <span>=</span> <span>function</span> <span>(</span><span>x<span>,</span> y<span>,</span> BList<span>,</span> pList</span><span>)</span> <span>{</span>
  <span>let</span> step <span>=</span> <span>1</span>
  <span>while</span> <span>(</span>x <span>+</span> step <span>&lt;</span> <span>8</span><span>)</span> <span>{</span>
    <span>const</span> flagB <span>=</span> BList<span>.</span><span>some</span><span>(</span><span>item</span> <span>=></span> <span>{</span>
      <span>return</span> <span>(</span>item<span>[</span><span>1</span><span>]</span> <span>===</span> y <span>&amp;&amp;</span> item<span>[</span><span>0</span><span>]</span> <span>===</span> x <span>+</span> step<span>)</span>
    <span>}</span><span>)</span>
    <span>if</span> <span>(</span>flagB<span>)</span> <span>return</span> <span>0</span>
    <span>const</span> flagp <span>=</span> pList<span>.</span><span>some</span><span>(</span><span>item</span> <span>=></span> <span>{</span>
      <span>return</span> <span>(</span>item<span>[</span><span>1</span><span>]</span> <span>===</span> y <span>&amp;&amp;</span> item<span>[</span><span>0</span><span>]</span> <span>===</span> x <span>+</span> step<span>)</span>
    <span>}</span><span>)</span>
    <span>if</span> <span>(</span>flagp<span>)</span> <span>return</span> <span>1</span>
    step<span>++</span>
  <span>}</span>
  <span>return</span> <span>0</span>
<span>}</span>

<span>/**
 * @param {number} x
 * @param {number} y
 * @param {number[][]} BList
 * @param {number[][]} pList
 * @return {number}
 */</span>
<span>var</span> <span>checkSouth</span> <span>=</span> <span>function</span> <span>(</span><span>x<span>,</span> y<span>,</span> BList<span>,</span> pList</span><span>)</span> <span>{</span>
  <span>let</span> step <span>=</span> <span>1</span>
  <span>while</span> <span>(</span>y <span>+</span> step <span>&lt;</span> <span>8</span><span>)</span> <span>{</span>
    <span>const</span> flagB <span>=</span> BList<span>.</span><span>some</span><span>(</span><span>item</span> <span>=></span> <span>{</span>
      <span>return</span> <span>(</span>item<span>[</span><span>1</span><span>]</span> <span>===</span> y <span>+</span> step <span>&amp;&amp;</span> item<span>[</span><span>0</span><span>]</span> <span>===</span> x<span>)</span>
    <span>}</span><span>)</span>
    <span>if</span> <span>(</span>flagB<span>)</span> <span>return</span> <span>0</span>
    <span>const</span> flagp <span>=</span> pList<span>.</span><span>some</span><span>(</span><span>item</span> <span>=></span> <span>{</span>
      <span>return</span> <span>(</span>item<span>[</span><span>1</span><span>]</span> <span>===</span> y <span>+</span> step <span>&amp;&amp;</span> item<span>[</span><span>0</span><span>]</span> <span>===</span> x<span>)</span>
    <span>}</span><span>)</span>
    <span>if</span> <span>(</span>flagp<span>)</span> <span>return</span> <span>1</span>
    step<span>++</span>
  <span>}</span>
  <span>return</span> <span>0</span>
<span>}</span>

<span>/**
 * @param {number} x
 * @param {number} y
 * @param {number[][]} BList
 * @param {number[][]} pList
 * @return {number}
 */</span>
<span>var</span> <span>checkWest</span> <span>=</span> <span>function</span> <span>(</span><span>x<span>,</span> y<span>,</span> BList<span>,</span> pList</span><span>)</span> <span>{</span>
  <span>let</span> step <span>=</span> <span>1</span>
  <span>while</span> <span>(</span>x <span>-</span> step <span>>=</span> <span>0</span><span>)</span> <span>{</span>
    <span>const</span> flagB <span>=</span> BList<span>.</span><span>some</span><span>(</span><span>item</span> <span>=></span> <span>{</span>
      <span>return</span> <span>(</span>item<span>[</span><span>1</span><span>]</span> <span>===</span> y <span>&amp;&amp;</span> item<span>[</span><span>0</span><span>]</span> <span>===</span> x <span>-</span> step<span>)</span>
    <span>}</span><span>)</span>
    <span>if</span> <span>(</span>flagB<span>)</span> <span>return</span> <span>0</span>
    <span>const</span> flagp <span>=</span> pList<span>.</span><span>some</span><span>(</span><span>item</span> <span>=></span> <span>{</span>
      <span>return</span> <span>(</span>item<span>[</span><span>1</span><span>]</span> <span>===</span> y <span>&amp;&amp;</span> item<span>[</span><span>0</span><span>]</span> <span>===</span> x <span>-</span> step<span>)</span>
    <span>}</span><span>)</span>
    <span>if</span> <span>(</span>flagp<span>)</span> <span>return</span> <span>1</span>
    step<span>++</span>
  <span>}</span>
  <span>return</span> <span>0</span>
<span>}</span>

<span>/**
 * @param {number} x
 * @param {number} y
 * @param {number[][]} BList
 * @param {number[][]} pList
 * @return {number}
 */</span>
<span>var</span> <span>checkNorth</span> <span>=</span> <span>function</span> <span>(</span><span>x<span>,</span> y<span>,</span> BList<span>,</span> pList</span><span>)</span> <span>{</span>
  <span>let</span> step <span>=</span> <span>1</span>
  <span>while</span> <span>(</span>y <span>-</span> step <span>>=</span> <span>0</span><span>)</span> <span>{</span>
    <span>const</span> flagB <span>=</span> BList<span>.</span><span>some</span><span>(</span><span>item</span> <span>=></span> <span>{</span>
      <span>return</span> <span>(</span>item<span>[</span><span>1</span><span>]</span> <span>===</span> y <span>-</span> step <span>&amp;&amp;</span> item<span>[</span><span>0</span><span>]</span> <span>===</span> x<span>)</span>
    <span>}</span><span>)</span>
    <span>if</span> <span>(</span>flagB<span>)</span> <span>return</span> <span>0</span>
    <span>const</span> flagp <span>=</span> pList<span>.</span><span>some</span><span>(</span><span>item</span> <span>=></span> <span>{</span>
      <span>return</span> <span>(</span>item<span>[</span><span>1</span><span>]</span> <span>===</span> y <span>-</span> step <span>&amp;&amp;</span> item<span>[</span><span>0</span><span>]</span> <span>===</span> x<span>)</span>
    <span>}</span><span>)</span>
    <span>if</span> <span>(</span>flagp<span>)</span> <span>return</span> <span>1</span>
    step<span>++</span>
  <span>}</span>
  <span>return</span> <span>0</span>
<span>}</span>
<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br></div></div><h2 id="_1002-查找共用字符"> 1002.查找共用字符</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1002 lang=javascript
 *
 * [1002] 查找共用字符
 * 
 * 给你一个字符串数组 words ，请你找出所有在 words 的每个字符串中都出现的共用字符（ 包括重复字符），并以数组形式返回。你可以按 任意顺序 返回答案。
 

示例 1：

输入：words = ["bella","label","roller"]
输出：["e","l","l"]
示例 2：

输入：words = ["cool","lock","cook"]
输出：["c","o"]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string[]} words
 * @return {string[]}
 */</span>
<span>var</span> <span>commonChars</span> <span>=</span> <span>function</span> <span>(</span><span>words</span><span>)</span> <span>{</span>
  words <span>=</span> words<span>.</span><span>map</span><span>(</span><span>item</span> <span>=></span> item<span>.</span><span>split</span><span>(</span><span>""</span><span>)</span><span>)</span>
  <span>if</span> <span>(</span>words<span>.</span>length <span>===</span> <span>1</span><span>)</span> <span>return</span> words<span>[</span><span>0</span><span>]</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> words<span>[</span><span>0</span><span>]</span><span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    res<span>.</span><span>push</span><span>(</span>words<span>[</span><span>0</span><span>]</span><span>[</span>i<span>]</span><span>)</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>1</span><span>;</span> j <span>&lt;</span> words<span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
      <span>const</span> index <span>=</span> words<span>[</span>j<span>]</span><span>.</span><span>indexOf</span><span>(</span>words<span>[</span><span>0</span><span>]</span><span>[</span>i<span>]</span><span>)</span>
      <span>if</span> <span>(</span>index <span>===</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
        res<span>.</span><span>pop</span><span>(</span><span>)</span>
        <span>break</span>
      <span>}</span> <span>else</span> <span>{</span>
        words<span>[</span>j<span>]</span><span>.</span><span>splice</span><span>(</span>index<span>,</span> <span>1</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><h2 id="_1005-k-次取反后最大化的数组和"> 1005.k-次取反后最大化的数组和</h2>
<div><pre><code>
<span>/*
 * @lc app=leetcode.cn id=1005 lang=javascript
 *
 * [1005] K 次取反后最大化的数组和
 * 
 * 给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：

选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。
重复这个过程恰好 k 次。可以多次选择同一个下标 i 。

以这种方式修改数组后，返回数组 可能的最大和 。

 

示例 1：

输入：nums = [4,2,3], k = 1
输出：5
解释：选择下标 1 ，nums 变为 [4,-2,3] 。
示例 2：

输入：nums = [3,-1,0,2], k = 3
输出：6
解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。
示例 3：

输入：nums = [2,-3,-1,5,-4], k = 2
输出：13
解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */</span>
<span>var</span> <span>largestSumAfterKNegations</span> <span>=</span> <span>function</span> <span>(</span><span>nums<span>,</span> k</span><span>)</span> <span>{</span>
  <span>while</span> <span>(</span>k <span>></span> <span>0</span><span>)</span> <span>{</span>
    <span>const</span> min <span>=</span> Math<span>.</span><span>min</span><span>(</span><span>...</span>nums<span>)</span>
    <span>const</span> i <span>=</span> nums<span>.</span><span>indexOf</span><span>(</span>min<span>)</span>
    nums<span>[</span>i<span>]</span> <span>=</span> <span>-</span>nums<span>[</span>i<span>]</span>
    k<span>--</span>
  <span>}</span>
  <span>return</span> nums<span>.</span><span>reduce</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a <span>+</span> b<span>,</span> <span>0</span><span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><h2 id="_1009-十进制整数的反码"> 1009.十进制整数的反码</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1009 lang=typescript
每个非负整数 N 都有其二进制表示。例如， 5 可以被表示为二进制 "101"，11 可以用二进制 "1011" 表示，依此类推。注意，除 N = 0 外，任何二进制表示中都不含前导零。

二进制的反码表示是将每个 1 改为 0 且每个 0 变为 1。例如，二进制数 "101" 的二进制反码为 "010"。

给你一个十进制数 N，请你返回其二进制表示的反码所对应的十进制整数。

 

示例 1：

输入：5
输出：2
解释：5 的二进制表示为 "101"，其二进制反码为 "010"，也就是十进制中的 2 。
示例 2：

输入：7
输出：0
解释：7 的二进制表示为 "111"，其二进制反码为 "000"，也就是十进制中的 0 。
示例 3：

输入：10
输出：5
解释：10 的二进制表示为 "1010"，其二进制反码为 "0101"，也就是十进制中的 5 。
 
 *
 * [1009] 十进制整数的反码
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>bitwiseComplement</span><span>(</span>n<span>:</span> <span>number</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>const</span> s <span>=</span> n<span>.</span><span>toString</span><span>(</span><span>2</span><span>)</span><span>;</span>
  <span>let</span> res <span>=</span> <span>""</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    res <span>+=</span> s<span>[</span>i<span>]</span> <span>===</span> <span>"1"</span> <span>?</span> <span>"0"</span> <span>:</span> <span>"1"</span><span>;</span>
  <span>}</span>
  <span>return</span> <span>parseInt</span><span>(</span>res<span>,</span> <span>2</span><span>)</span><span>;</span>
<span>}</span>
<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id="_1013-将数组分成和相等的三个部分"> 1013.将数组分成和相等的三个部分</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1013 lang=javascript
 *
 * [1013] 将数组分成和相等的三个部分
 * 
 * 给你一个整数数组 arr，只有可以将其划分为三个和相等的 非空 部分时才返回 true，否则返回 false。

形式上，如果可以找出索引 i + 1 &lt; j 且满足 (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1]) 就可以将数组三等分。

 

示例 1：

输入：arr = [0,2,1,-6,6,-7,9,1,2,0,1]
输出：true
解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1
示例 2：

输入：arr = [0,2,1,-6,6,7,9,-1,2,0,1]
输出：false
示例 3：

输入：arr = [3,3,6,5,-2,2,5,1,-9,4]
输出：true
解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} arr
 * @return {boolean}
 */</span>
<span>var</span> <span>canThreePartsEqualSum</span> <span>=</span> <span>function</span> <span>(</span><span>arr</span><span>)</span> <span>{</span>
  <span>const</span> count <span>=</span> arr<span>.</span><span>reduce</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a <span>+</span> b<span>,</span> <span>0</span><span>)</span>
  <span>const</span> area <span>=</span> count <span>/</span> <span>3</span>
  <span>let</span> res <span>=</span> <span>0</span><span>,</span> time <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    res <span>+=</span> arr<span>[</span>i<span>]</span>
    <span>if</span> <span>(</span>res <span>===</span> area<span>)</span> <span>{</span>
      res <span>=</span> <span>0</span>
      time<span>++</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> time <span>>=</span> <span>3</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><h2 id="_1018-可被-5-整除的二进制前缀"> 1018.可被-5-整除的二进制前缀</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1018 lang=typescript
 *
 * [1018] 可被 5 整除的二进制前缀
 * 
 * 给定一个二进制数组 nums ( 索引从0开始 )。

我们将xi 定义为其二进制表示形式为子数组 nums[0..i] (从最高有效位到最低有效位)。

例如，如果 nums =[1,0,1] ，那么 x0 = 1, x1 = 2, 和 x2 = 5。
返回布尔值列表 answer，只有当 xi 可以被 5 整除时，答案 answer[i] 为 true，否则为 false。

 

示例 1：

输入：nums = [0,1,1]
输出：[true,false,false]
解释：
输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为 true 。
示例 2：

输入：nums = [1,1,1]
输出：[false,false,false]
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>prefixesDivBy5</span><span>(</span>nums<span>:</span> <span>number</span><span>[</span><span>]</span><span>)</span><span>:</span> <span>boolean</span><span>[</span><span>]</span> <span>{</span>
  <span>const</span> res<span>:</span> <span>boolean</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>]</span><span>;</span>
  <span>let</span> s <span>=</span> <span>0</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>===</span> <span>0</span><span>)</span> <span>{</span>
      s <span>*=</span> <span>2</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      s <span>=</span> s <span>*</span> <span>2</span> <span>+</span> <span>1</span><span>;</span>
    <span>}</span>
    res<span>.</span><span>push</span><span>(</span>s <span>%</span> <span>5</span> <span>===</span> <span>0</span><span>)</span><span>;</span>
    s <span>></span> <span>9</span> <span>&amp;&amp;</span> <span>(</span>s <span>-=</span> <span>10</span><span>)</span><span>;</span>
  <span>}</span>
  <span>return</span> res<span>;</span>
<span>}</span>

<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><h2 id="_1021-删除最外层的括号"> 1021.删除最外层的括号</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1021 lang=javascript
 *
 * [1021] 删除最外层的括号
 * 
 * 有效括号字符串为空 ""、"(" + A + ")" 或 A + B ，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。

例如，""，"()"，"(())()" 和 "(()(()))" 都是有效的括号字符串。
如果有效字符串 s 非空，且不存在将其拆分为 s = A + B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。

给出一个非空有效字符串 s，考虑将其进行原语化分解，使得：s = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。

对 s 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 s 。

 

示例 1：

输入：s = "(()())(())"
输出："()()()"
解释：
输入字符串为 "(()())(())"，原语化分解得到 "(()())" + "(())"，
删除每个部分中的最外层括号后得到 "()()" + "()" = "()()()"。
示例 2：

输入：s = "(()())(())(()(()))"
输出："()()()()(())"
解释：
输入字符串为 "(()())(())(()(()))"，原语化分解得到 "(()())" + "(())" + "(()(()))"，
删除每个部分中的最外层括号后得到 "()()" + "()" + "()(())" = "()()()()(())"。
示例 3：

输入：s = "()()"
输出：""
解释：
输入字符串为 "()()"，原语化分解得到 "()" + "()"，
删除每个部分中的最外层括号后得到 "" + "" = ""。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @return {string}
 */</span>
<span>var</span> <span>removeOuterParentheses</span> <span>=</span> <span>function</span> <span>(</span><span>s</span><span>)</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>""</span><span>,</span> count <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>s<span>[</span>i<span>]</span> <span>===</span> <span>"("</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>count<span>)</span> res <span>+=</span> s<span>[</span>i<span>]</span>
      count<span>++</span>
    <span>}</span> <span>else</span> <span>{</span>
      count<span>--</span>
      <span>if</span> <span>(</span>count<span>)</span> res <span>+=</span> s<span>[</span>i<span>]</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br></div></div><h2 id="_1025-除数博弈"> 1025.除数博弈</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1025 lang=javascript
 *
 * [1025] 除数博弈
 * 
 * 爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。

最初，黑板上有一个数字 n 。在每个玩家的回合，玩家需要执行以下操作：

选出任一 x，满足 0 &lt; x &lt; n 且 n % x == 0 。
用 n - x 替换黑板上的数字 n 。
如果玩家无法执行这些操作，就会输掉游戏。

只有在爱丽丝在游戏中取得胜利时才返回 true 。假设两个玩家都以最佳状态参与游戏。

 

示例 1：

输入：n = 2
输出：true
解释：爱丽丝选择 1，鲍勃无法进行操作。
示例 2：

输入：n = 3
输出：false
解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} n
 * @return {boolean}
 */</span>
<span>var</span> <span>divisorGame</span> <span>=</span> <span>function</span> <span>(</span><span>n</span><span>)</span> <span>{</span>
  <span>return</span> n <span>%</span> <span>2</span> <span>===</span> <span>0</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id="_1030-距离顺序排列矩阵单元格"> 1030.距离顺序排列矩阵单元格</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1030 lang=javascript
 *
 * [1030] 距离顺序排列矩阵单元格
 * 
 * 给定四个整数 rows ,   cols ,  rCenter 和 cCenter 。有一个 rows x cols 的矩阵，你在单元格上的坐标是 (rCenter, cCenter) 。

返回矩阵中的所有单元格的坐标，并按与 (rCenter, cCenter) 的 距离 从最小到最大的顺序排。你可以按 任何 满足此条件的顺序返回答案。

单元格(r1, c1) 和 (r2, c2) 之间的距离为|r1 - r2| + |c1 - c2|。

 

示例 1：

输入：rows = 1, cols = 2, rCenter = 0, cCenter = 0
输出：[[0,0],[0,1]]
解释：从 (r0, c0) 到其他单元格的距离为：[0,1]
示例 2：

输入：rows = 2, cols = 2, rCenter = 0, cCenter = 1
输出：[[0,1],[0,0],[1,1],[1,0]]
解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2]
[[0,1],[1,1],[0,0],[1,0]] 也会被视作正确答案。
示例 3：

输入：rows = 2, cols = 3, rCenter = 1, cCenter = 2
输出：[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]
解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2,2,3]
其他满足题目要求的答案也会被视为正确，例如 [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} rows
 * @param {number} cols
 * @param {number} rCenter
 * @param {number} cCenter
 * @return {number[][]}
 */</span>
<span>var</span> <span>allCellsDistOrder</span> <span>=</span> <span>function</span> <span>(</span><span>rows<span>,</span> cols<span>,</span> rCenter<span>,</span> cCenter</span><span>)</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> rows<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> cols<span>;</span> j<span>++</span><span>)</span> <span>{</span>
      res<span>.</span><span>push</span><span>(</span><span>[</span>i<span>,</span> j<span>]</span><span>)</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res<span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> Math<span>.</span><span>abs</span><span>(</span>a<span>[</span><span>0</span><span>]</span> <span>-</span> rCenter<span>)</span> <span>+</span> Math<span>.</span><span>abs</span><span>(</span>a<span>[</span><span>1</span><span>]</span> <span>-</span> cCenter<span>)</span> <span>-</span> Math<span>.</span><span>abs</span><span>(</span>b<span>[</span><span>0</span><span>]</span> <span>-</span> rCenter<span>)</span> <span>-</span> Math<span>.</span><span>abs</span><span>(</span>b<span>[</span><span>1</span><span>]</span> <span>-</span> cCenter<span>)</span><span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><h2 id="_1037-有效的回旋镖"> 1037.有效的回旋镖</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1037 lang=typescript
 *
 * [1037] 有效的回旋镖
 * 
 * 给定一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点，如果这些点构成一个 回旋镖 则返回 true 。

回旋镖 定义为一组三个点，这些点 各不相同 且 不在一条直线上 。

 

示例 1：

输入：points = [[1,1],[2,3],[3,2]]
输出：true
示例 2：

输入：points = [[1,1],[2,2],[3,3]]
输出：false
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>isBoomerang</span><span>(</span>points<span>:</span> <span>number</span><span>[</span><span>]</span><span>[</span><span>]</span><span>)</span><span>:</span> <span>boolean</span> <span>{</span>
  <span>if</span> <span>(</span>
    <span>(</span>points<span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span> <span>===</span> points<span>[</span><span>1</span><span>]</span><span>[</span><span>0</span><span>]</span> <span>&amp;&amp;</span> points<span>[</span><span>1</span><span>]</span><span>[</span><span>0</span><span>]</span> <span>===</span> points<span>[</span><span>2</span><span>]</span><span>[</span><span>0</span><span>]</span><span>)</span> <span>||</span>
    <span>(</span>points<span>[</span><span>0</span><span>]</span><span>[</span><span>1</span><span>]</span> <span>===</span> points<span>[</span><span>1</span><span>]</span><span>[</span><span>1</span><span>]</span> <span>&amp;&amp;</span> points<span>[</span><span>1</span><span>]</span><span>[</span><span>1</span><span>]</span> <span>===</span> points<span>[</span><span>2</span><span>]</span><span>[</span><span>1</span><span>]</span><span>)</span>
  <span>)</span>
    <span>return</span> <span>false</span><span>;</span>
  <span>const</span> k1 <span>=</span> <span>(</span>points<span>[</span><span>1</span><span>]</span><span>[</span><span>0</span><span>]</span> <span>-</span> points<span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span><span>)</span> <span>/</span> <span>(</span>points<span>[</span><span>1</span><span>]</span><span>[</span><span>1</span><span>]</span> <span>-</span> points<span>[</span><span>0</span><span>]</span><span>[</span><span>1</span><span>]</span><span>)</span><span>,</span>
    k2 <span>=</span> <span>(</span>points<span>[</span><span>2</span><span>]</span><span>[</span><span>0</span><span>]</span> <span>-</span> points<span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span><span>)</span> <span>/</span> <span>(</span>points<span>[</span><span>2</span><span>]</span><span>[</span><span>1</span><span>]</span> <span>-</span> points<span>[</span><span>0</span><span>]</span><span>[</span><span>1</span><span>]</span><span>)</span><span>;</span>
  <span>if</span> <span>(</span>Number<span>.</span><span>isNaN</span><span>(</span>k1<span>)</span> <span>||</span> Number<span>.</span><span>isNaN</span><span>(</span>k2<span>)</span><span>)</span> <span>return</span> <span>false</span><span>;</span>
  <span>return</span> k1 <span>!==</span> k2<span>;</span>
<span>}</span>
<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><h2 id="_1046-最后一块石头的重量"> 1046.最后一块石头的重量</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1046 lang=javascript
 *
 * [1046] 最后一块石头的重量
 * 
 * 有一堆石头，每块石头的重量都是正整数。

每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。

 

示例：

输入：[2,7,4,1,8,1]
输出：1
解释：
先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，
再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，
接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，
最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} stones
 * @return {number}
 */</span>
<span>var</span> <span>lastStoneWeight</span> <span>=</span> <span>function</span> <span>(</span><span>stones</span><span>)</span> <span>{</span>
  <span>while</span> <span>(</span>stones<span>.</span>length <span>></span> <span>1</span><span>)</span> <span>{</span>
    stones <span>=</span> stones<span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> b <span>-</span> a<span>)</span>
    <span>const</span> y <span>=</span> stones<span>.</span><span>shift</span><span>(</span><span>)</span>
    <span>const</span> x <span>=</span> stones<span>.</span><span>shift</span><span>(</span><span>)</span>
    <span>if</span> <span>(</span>x <span>!==</span> y<span>)</span> stones<span>.</span><span>push</span><span>(</span>y <span>-</span> x<span>)</span>
  <span>}</span>
  <span>return</span> stones<span>.</span>length <span>></span> <span>0</span> <span>?</span> stones<span>[</span><span>0</span><span>]</span> <span>:</span> <span>0</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h2 id="_1047-删除字符串中的所有相邻重复项"> 1047.删除字符串中的所有相邻重复项</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1047 lang=javascript
 *
 * [1047] 删除字符串中的所有相邻重复项
 * 
 * 给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

 

示例：

输入："abbaca"
输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @return {string}
 */</span>
<span>var</span> <span>removeDuplicates</span> <span>=</span> <span>function</span> <span>(</span><span>s</span><span>)</span> <span>{</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>res<span>[</span>res<span>.</span>length <span>-</span> <span>1</span><span>]</span> <span>!==</span> s<span>[</span>i<span>]</span><span>)</span> <span>{</span>
      res<span>.</span><span>push</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      res<span>.</span><span>pop</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res<span>.</span><span>join</span><span>(</span><span>""</span><span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id="_1051-高度检查器"> 1051.高度检查器</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1051 lang=javascript
 *
 * [1051] 高度检查器
 * 
 * 学校打算为全体学生拍一张年度纪念照。根据要求，学生需要按照 非递减 的高度顺序排成一行。

排序后的高度情况用整数数组 expected 表示，其中 expected[i] 是预计排在这一行中第 i 位的学生的高度（下标从 0 开始）。

给你一个整数数组 heights ，表示 当前学生站位 的高度情况。heights[i] 是这一行中第 i 位学生的高度（下标从 0 开始）。

返回满足 heights[i] != expected[i] 的 下标数量 。

 

示例：

输入：heights = [1,1,4,2,1,3]
输出：3 
解释：
高度：[1,1,4,2,1,3]
预期：[1,1,1,2,3,4]
下标 2 、4 、5 处的学生高度不匹配。
示例 2：

输入：heights = [5,1,2,3,4]
输出：5
解释：
高度：[5,1,2,3,4]
预期：[1,2,3,4,5]
所有下标的对应学生高度都不匹配。
示例 3：

输入：heights = [1,2,3,4,5]
输出：0
解释：
高度：[1,2,3,4,5]
预期：[1,2,3,4,5]
所有下标的对应学生高度都匹配。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} heights
 * @return {number}
 */</span>
<span>var</span> <span>heightChecker</span> <span>=</span> <span>function</span> <span>(</span><span>heights</span><span>)</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>0</span>
  <span>const</span> arr <span>=</span> heights<span>.</span><span>slice</span><span>(</span><span>0</span><span>)</span><span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a <span>-</span> b<span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> heights<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>arr<span>[</span>i<span>]</span> <span>!==</span> heights<span>[</span>i<span>]</span><span>)</span> res<span>++</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div><h2 id="_1071-字符串的最大公因子"> 1071.字符串的最大公因子</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1071 lang=javascript
 *
 * [1071] 字符串的最大公因子
 * 
 * 对于字符串 s 和 t，只有在 s = t + ... + t（t 自身连接 1 次或多次）时，我们才认定 “t 能除尽 s”。

给定两个字符串 str1 和 str2 。返回 最长字符串 x，要求满足 x 能除尽 str1 且 X 能除尽 str2 。

 

示例 1：

输入：str1 = "ABCABC", str2 = "ABC"
输出："ABC"
示例 2：

输入：str1 = "ABABAB", str2 = "ABAB"
输出："AB"
示例 3：

输入：str1 = "LEET", str2 = "CODE"
输出：""
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} str1
 * @param {string} str2
 * @return {string}
 */</span>
<span>var</span> <span>gcdOfStrings</span> <span>=</span> <span>function</span> <span>(</span><span>str1<span>,</span> str2</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> str2<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> str <span>=</span> str2<span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span> str2<span>.</span>length <span>-</span> i<span>)</span>
    <span>if</span> <span>(</span>str1<span>.</span><span>split</span><span>(</span>str<span>)</span><span>.</span><span>findIndex</span><span>(</span><span>j</span> <span>=></span> j <span>!==</span> <span>""</span><span>)</span> <span>===</span> <span>-</span><span>1</span> <span>&amp;&amp;</span> str2<span>.</span><span>split</span><span>(</span>str<span>)</span><span>.</span><span>findIndex</span><span>(</span><span>j</span> <span>=></span> j <span>!==</span> <span>""</span><span>)</span> <span>===</span> <span>-</span><span>1</span><span>)</span> <span>return</span> str
  <span>}</span>
  <span>return</span> <span>""</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h2 id="_1078-bigram-分词"> 1078.bigram-分词</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1078 lang=javascript
 *
 * [1078] Bigram 分词
 * 
 * 给出第一个词 first 和第二个词 second，考虑在某些文本 text 中可能以 "first second third" 形式出现的情况，其中 second 紧随 first 出现，third 紧随 second 出现。

对于每种这样的情况，将第三个词 "third" 添加到答案中，并返回答案。

 

示例 1：

输入：text = "alice is a good girl she is a good student", first = "a", second = "good"
输出：["girl","student"]
示例 2：

输入：text = "we will we will rock you", first = "we", second = "will"
输出：["we","rock"]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} text
 * @param {string} first
 * @param {string} second
 * @return {string[]}
 */</span>
<span>var</span> <span>findOcurrences</span> <span>=</span> <span>function</span> <span>(</span><span>text<span>,</span> first<span>,</span> second</span><span>)</span> <span>{</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span>
  text <span>=</span> text<span>.</span><span>split</span><span>(</span><span>" "</span><span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> text<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>text<span>[</span>i <span>+</span> <span>2</span><span>]</span><span>)</span> <span>break</span>
    <span>if</span> <span>(</span>text<span>[</span>i<span>]</span> <span>===</span> first <span>&amp;&amp;</span> text<span>[</span>i <span>+</span> <span>1</span><span>]</span> <span>===</span> second<span>)</span> res<span>.</span><span>push</span><span>(</span>text<span>[</span>i <span>+</span> <span>2</span><span>]</span><span>)</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id="_1089-复写零"> 1089.复写零</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1089 lang=javascript
 *
 * [1089] 复写零
 * 
 * 给你一个长度固定的整数数组 arr ，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。

注意：请不要在超过该数组长度的位置写入元素。请对输入的数组 就地 进行上述修改，不要从函数返回任何东西。

 

示例 1：

输入：arr = [1,0,2,3,0,4,5,0]
输出：[1,0,0,2,3,0,0,4]
解释：调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]
示例 2：

输入：arr = [1,2,3]
输出：[1,2,3]
解释：调用函数后，输入的数组将被修改为：[1,2,3]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} arr
 * @return {void} Do not return anything, modify arr in-place instead.
 */</span>
<span>var</span> <span>duplicateZeros</span> <span>=</span> <span>function</span> <span>(</span><span>arr</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length <span>-</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>arr<span>[</span>i<span>]</span> <span>===</span> <span>0</span><span>)</span> <span>{</span>
      arr<span>.</span><span>splice</span><span>(</span>i<span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span>
      arr<span>.</span><span>pop</span><span>(</span><span>)</span>
      i<span>++</span>
    <span>}</span>
  <span>}</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id="_1103-分糖果-ii"> 1103.分糖果-ii</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1103 lang=javascript
 *
 * [1103] 分糖果 II
 * 
 * 排排坐，分糖果。

我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。

给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。

然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。

重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。

返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。

 

示例 1：

输入：candies = 7, num_people = 4
输出：[1,2,3,1]
解释：
第一次，ans[0] += 1，数组变为 [1,0,0,0]。
第二次，ans[1] += 2，数组变为 [1,2,0,0]。
第三次，ans[2] += 3，数组变为 [1,2,3,0]。
第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。
示例 2：

输入：candies = 10, num_people = 3
输出：[5,2,3]
解释：
第一次，ans[0] += 1，数组变为 [1,0,0]。
第二次，ans[1] += 2，数组变为 [1,2,0]。
第三次，ans[2] += 3，数组变为 [1,2,3]。
第四次，ans[0] += 4，最终数组变为 [5,2,3]。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} candies
 * @param {number} num_people
 * @return {number[]}
 */</span>
<span>var</span> <span>distributeCandies</span> <span>=</span> <span>function</span> <span>(</span><span>candies<span>,</span> num_people</span><span>)</span> <span>{</span>
  <span>let</span> n <span>=</span> <span>1</span><span>,</span> i <span>=</span> <span>0</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span>
  res<span>.</span>length <span>=</span> num_people
  res<span>.</span><span>fill</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> num_people<span>)</span>
  <span>while</span> <span>(</span>candies <span>></span> <span>0</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>candies <span>&lt;=</span> n<span>)</span> <span>{</span>
      res<span>[</span>i<span>]</span> <span>+=</span> candies
      <span>break</span>
    <span>}</span>
    res<span>[</span>i<span>]</span> <span>+=</span> n
    candies <span>-=</span> n
    n<span>++</span>
    <span>if</span> <span>(</span>i <span>===</span> num_people <span>-</span> <span>1</span><span>)</span> <span>{</span>
      i <span>=</span> <span>0</span>
    <span>}</span> <span>else</span> <span>{</span>
      i<span>++</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br></div></div><h2 id="_1108-ip-地址无效化"> 1108.ip-地址无效化</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1108 lang=javascript
 *
 * [1108] IP 地址无效化
 * 
 * 给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。

所谓无效化 IP 地址，其实就是用 "[.]" 代替了每个 "."。

 

示例 1：

输入：address = "1.1.1.1"
输出："1[.]1[.]1[.]1"
示例 2：

输入：address = "255.100.50.0"
输出："255[.]100[.]50[.]0"
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} address
 * @return {string}
 */</span>
<span>var</span> <span>defangIPaddr</span> <span>=</span> <span>function</span><span>(</span><span>address</span><span>)</span> <span>{</span>
  <span>return</span> address<span>.</span><span>replace</span><span>(</span><span><span>/</span><span>\.</span><span>/</span><span>g</span></span><span>,</span><span>"[.]"</span><span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h2 id="_1122-数组的相对排序"> 1122.数组的相对排序</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1122 lang=javascript
 *
 * [1122] 数组的相对排序
 * 
 * 给你两个数组，arr1 和 arr2，arr2 中的元素各不相同，arr2 中的每个元素都出现在 arr1 中。

对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。

 

示例 1：

输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
输出：[2,2,2,1,4,3,3,9,6,7,19]
示例  2:

输入：arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]
输出：[22,28,8,6,17,44]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} arr1
 * @param {number[]} arr2
 * @return {number[]}
 */</span>
<span>var</span> <span>relativeSortArray</span> <span>=</span> <span>function</span> <span>(</span><span>arr1<span>,</span> arr2</span><span>)</span> <span>{</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr2<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> arr1<span>.</span>length<span>;</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>arr1<span>[</span>j<span>]</span> <span>===</span> arr2<span>[</span>i<span>]</span><span>)</span> <span>{</span>
        res<span>.</span><span>push</span><span>(</span>arr1<span>[</span>j<span>]</span><span>)</span>
        arr1<span>.</span><span>splice</span><span>(</span>j<span>,</span> <span>1</span><span>)</span>
      <span>}</span> <span>else</span> <span>{</span>
        j<span>++</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  arr1<span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a <span>-</span> b<span>)</span>
  <span>return</span> <span>[</span><span>...</span>res<span>,</span> <span>...</span>arr1<span>]</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h2 id="_1128-等价多米诺骨牌对的数量"> 1128.等价多米诺骨牌对的数量</h2>
<div><pre><code>
<span>/*
 * @lc app=leetcode.cn id=1128 lang=javascript
 *
 * [1128] 等价多米诺骨牌对的数量
 * 
 * 给你一个由一些多米诺骨牌组成的列表 dominoes。

如果其中某一张多米诺骨牌可以通过旋转 0 度或 180 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。

形式上，dominoes[i] = [a, b] 和 dominoes[j] = [c, d] 等价的前提是 a==c 且 b==d，或是 a==d 且 b==c。

在 0 &lt;= i &lt; j &lt; dominoes.length 的前提下，找出满足 dominoes[i] 和 dominoes[j] 等价的骨牌对 (i, j) 的数量。

 

示例：

输入：dominoes = [[1,2],[2,1],[3,4],[5,6]]
输出：1
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[][]} dominoes
 * @return {number}
 */</span>
<span>var</span> <span>numEquivDominoPairs</span> <span>=</span> <span>function</span> <span>(</span><span>dominoes</span><span>)</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>0</span><span>,</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> dominoes<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> s <span>=</span> dominoes<span>[</span>i<span>]</span><span>[</span><span>0</span><span>]</span> <span>&lt;</span> dominoes<span>[</span>i<span>]</span><span>[</span><span>1</span><span>]</span> <span>?</span> <span><span>`</span><span><span>${</span>dominoes<span>[</span>i<span>]</span><span>[</span><span>0</span><span>]</span><span>}</span></span><span><span>${</span>dominoes<span>[</span>i<span>]</span><span>[</span><span>1</span><span>]</span><span>}</span></span><span>`</span></span> <span>:</span> <span><span>`</span><span><span>${</span>dominoes<span>[</span>i<span>]</span><span>[</span><span>1</span><span>]</span><span>}</span></span><span><span>${</span>dominoes<span>[</span>i<span>]</span><span>[</span><span>0</span><span>]</span><span>}</span></span><span>`</span></span>
    <span>if</span> <span>(</span><span>!</span>map<span>.</span><span>has</span><span>(</span>s<span>)</span><span>)</span> <span>{</span>
      map<span>.</span><span>set</span><span>(</span>s<span>,</span> <span>0</span><span>)</span>
      <span>continue</span>
    <span>}</span>
    <span>const</span> c <span>=</span> map<span>.</span><span>get</span><span>(</span>s<span>)</span> <span>+</span> <span>1</span>
    map<span>.</span><span>set</span><span>(</span>s<span>,</span> c<span>)</span>
    res <span>+=</span> c
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>

<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h2 id="_1137-第-n-个泰波那契数"> 1137.第-n-个泰波那契数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1137 lang=javascript
 *
 * [1137] 第 N 个泰波那契数
 * 
 * 泰波那契序列 Tn 定义如下： 

T0 = 0, T1 = 1, T2 = 1, 且在 n >= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2

给你整数 n，请返回第 n 个泰波那契数 Tn 的值。

 

示例 1：

输入：n = 4
输出：4
解释：
T_3 = 0 + 1 + 1 = 2
T_4 = 1 + 1 + 2 = 4
示例 2：

输入：n = 25
输出：1389537
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} n
 * @return {number}
 */</span>
<span>var</span> <span>tribonacci</span> <span>=</span> <span>function</span> <span>(</span><span>n</span><span>)</span> <span>{</span>
  <span>const</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>[</span><span>[</span><span>0</span><span>,</span> <span>0</span><span>]</span><span>,</span> <span>[</span><span>1</span><span>,</span> <span>1</span><span>]</span><span>,</span> <span>[</span><span>2</span><span>,</span> <span>1</span><span>]</span><span>]</span><span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>3</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    map<span>.</span><span>set</span><span>(</span>i<span>,</span> map<span>.</span><span>get</span><span>(</span>i <span>-</span> <span>3</span><span>)</span> <span>+</span> map<span>.</span><span>get</span><span>(</span>i <span>-</span> <span>2</span><span>)</span> <span>+</span> map<span>.</span><span>get</span><span>(</span>i <span>-</span> <span>1</span><span>)</span><span>)</span>
  <span>}</span>
  <span>return</span> map<span>.</span><span>get</span><span>(</span>n<span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h2 id="_1154-一年中的第几天"> 1154.一年中的第几天</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1154 lang=javascript
 *
 * [1154] 一年中的第几天
 * 
 * 给你一个字符串 date ，按 YYYY-MM-DD 格式表示一个 现行公元纪年法 日期。返回该日期是当年的第几天。

 

示例 1：

输入：date = "2019-01-09"
输出：9
解释：给定日期是2019年的第九天。
示例 2：

输入：date = "2019-02-10"
输出：41
 


 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} date
 * @return {number}
 */</span>
<span>var</span> <span>dayOfYear</span> <span>=</span> <span>function</span> <span>(</span><span>date</span><span>)</span> <span>{</span>
  date <span>=</span> date<span>.</span><span>split</span><span>(</span><span>"-"</span><span>)</span>
  <span>return</span> <span>(</span><span>(</span><span>(</span><span>(</span><span>(</span><span>(</span><span>new</span> <span>Date</span><span>(</span>date<span>)</span><span>.</span><span>getTime</span><span>(</span><span>)</span> <span>-</span> <span>new</span> <span>Date</span><span>(</span><span><span>`</span><span><span>${</span>date<span>[</span><span>0</span><span>]</span><span>}</span></span><span>-01-01</span><span>`</span></span><span>)</span><span>.</span><span>getTime</span><span>(</span><span>)</span><span>)</span> <span>/</span> <span>1000</span><span>)</span> <span>/</span> <span>60</span><span>)</span> <span>/</span> <span>60</span><span>)</span> <span>/</span> <span>24</span><span>)</span> <span>+</span> <span>1</span><span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><h2 id="_1160-拼写单词"> 1160.拼写单词</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1160 lang=javascript
 *
 * [1160] 拼写单词
 * 
 * 给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。

假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。

注意：每次拼写（指拼写词汇表中的一个单词）时，chars 中的每个字母都只能用一次。

返回词汇表 words 中你掌握的所有单词的 长度之和。

 

示例 1：

输入：words = ["cat","bt","hat","tree"], chars = "atach"
输出：6
解释： 
可以形成字符串 "cat" 和 "hat"，所以答案是 3 + 3 = 6。
示例 2：

输入：words = ["hello","world","leetcode"], chars = "welldonehoneyr"
输出：10
解释：
可以形成字符串 "hello" 和 "world"，所以答案是 5 + 5 = 10。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string[]} words
 * @param {string} chars
 * @return {number}
 */</span>
<span>var</span> <span>countCharacters</span> <span>=</span> <span>function</span> <span>(</span><span>words<span>,</span> chars</span><span>)</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> words<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> c <span>=</span> chars<span>.</span><span>split</span><span>(</span><span>""</span><span>)</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> words<span>[</span>i<span>]</span><span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
      <span>const</span> index <span>=</span> c<span>.</span><span>indexOf</span><span>(</span>words<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>)</span>
      <span>if</span> <span>(</span>index <span>===</span> <span>-</span><span>1</span><span>)</span> <span>break</span>
      <span>if</span> <span>(</span>j <span>===</span> words<span>[</span>i<span>]</span><span>.</span>length <span>-</span> <span>1</span><span>)</span> <span>{</span>
        res <span>+=</span> words<span>[</span>i<span>]</span><span>.</span>length
        <span>break</span>
      <span>}</span>
      c<span>.</span><span>splice</span><span>(</span>index<span>,</span> <span>1</span><span>)</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><h2 id="_1175-质数排列"> 1175.质数排列</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1175 lang=typescript
 *
 * [1175] 质数排列
 * 
 * 请你帮忙给从 1 到 n 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。

让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。

由于答案可能会很大，所以请你返回答案 模 mod 10^9 + 7 之后的结果即可。

 

示例 1：

输入：n = 5
输出：12
解释：举个例子，[1,2,5,4,3] 是一个有效的排列，但 [5,2,3,4,1] 不是，因为在第二种情况里质数 5 被错误地放在索引为 1 的位置上。
示例 2：

输入：n = 100
输出：682289015
 
 */</span>

<span>// @lc code=start</span>

<span>const</span> primeArr<span>:</span><span>number</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>]</span>

<span>const</span> <span>MOD</span> <span>=</span> <span>10</span> <span>**</span> <span>9</span> <span>+</span> <span>7</span><span>;</span>

<span>function</span> <span>numPrimeArrangements</span><span>(</span>n<span>:</span> <span>number</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>let</span> count <span>=</span> <span>0</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>isPrime</span><span>(</span>i<span>)</span><span>)</span> count<span>++</span><span>;</span>
  <span>}</span>
  <span>let</span> res <span>=</span> <span>1</span><span>;</span>
  <span>let</span> m <span>=</span> n <span>-</span> count<span>;</span>
  <span>while</span> <span>(</span>count <span>></span> <span>0</span><span>)</span> <span>{</span>
      res <span>=</span> res <span>%</span> <span>MOD</span><span>;</span>
      res <span>*=</span> count<span>;</span>
      count<span>--</span><span>;</span>
  <span>}</span>
  <span>while</span> <span>(</span>m <span>></span> <span>0</span><span>)</span> <span>{</span>
      res <span>=</span> res <span>%</span> <span>MOD</span><span>;</span>
      res <span>*=</span> m<span>;</span>
      m<span>--</span><span>;</span>
  <span>}</span>
  <span>return</span> res<span>;</span>
<span>}</span>

<span>function</span> <span>factorial</span><span>(</span>n<span>:</span> <span>number</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>1</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    res <span>=</span> <span>(</span>res <span>*</span> i<span>)</span> <span>%</span> <span>MOD</span><span>;</span>
  <span>}</span>
  <span>return</span> res<span>;</span>
<span>}</span>

<span>function</span> <span>isPrime</span><span>(</span>n<span>:</span> <span>number</span><span>)</span><span>:</span> <span>boolean</span> <span>{</span>
  <span>if</span><span>(</span>primeArr<span>.</span><span>includes</span><span>(</span>n<span>)</span><span>)</span> <span>return</span> <span>true</span>
  <span>if</span> <span>(</span>n <span>&lt;=</span> <span>1</span><span>)</span> <span>return</span> <span>false</span><span>;</span>
  <span>if</span> <span>(</span>n <span>&lt;=</span> <span>3</span><span>)</span> <span>{</span>
    primeArr<span>.</span><span>push</span><span>(</span>n<span>)</span>
    <span>return</span> <span>true</span><span>;</span>
  <span>}</span><span>;</span>
  <span>if</span> <span>(</span>n <span>%</span> <span>2</span> <span>===</span> <span>0</span> <span>||</span> n <span>%</span> <span>3</span> <span>===</span> <span>0</span><span>)</span> <span>return</span> <span>false</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>5</span><span>;</span> i <span>*</span> i <span>&lt;=</span> n<span>;</span> i <span>+=</span> <span>6</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>n <span>%</span> i <span>===</span> <span>0</span> <span>||</span> n <span>%</span> <span>(</span>i <span>+</span> <span>2</span><span>)</span> <span>===</span> <span>0</span><span>)</span> <span>return</span> <span>false</span><span>;</span>
  <span>}</span>
  primeArr<span>.</span><span>push</span><span>(</span>n<span>)</span><span>;</span>
  <span>return</span> <span>true</span><span>;</span>
<span>}</span>

<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br></div></div><h2 id="_1184-公交站间的距离"> 1184.公交站间的距离</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1184 lang=javascript
 *
 * [1184] 公交站间的距离
 * 
 * 环形公交路线上有 n 个站，按次序从 0 到 n - 1 进行编号。我们已知每一对相邻公交站之间的距离，distance[i] 表示编号为 i 的车站和编号为 (i + 1) % n 的车站之间的距离。

环线上的公交车都可以按顺时针和逆时针的方向行驶。

返回乘客从出发点 start 到目的地 destination 之间的最短距离。

 

示例 1：



输入：distance = [1,2,3,4], start = 0, destination = 1
输出：1
解释：公交站 0 和 1 之间的距离是 1 或 9，最小值是 1。
 

示例 2：



输入：distance = [1,2,3,4], start = 0, destination = 2
输出：3
解释：公交站 0 和 2 之间的距离是 3 或 7，最小值是 3。
 

示例 3：



输入：distance = [1,2,3,4], start = 0, destination = 3
输出：4
解释：公交站 0 和 3 之间的距离是 6 或 4，最小值是 4。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} distance
 * @param {number} start
 * @param {number} destination
 * @return {number}
 */</span>
<span>var</span> <span>distanceBetweenBusStops</span> <span>=</span> <span>function</span> <span>(</span><span>distance<span>,</span> start<span>,</span> destination</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>start <span>===</span> destination<span>)</span> <span>return</span> <span>0</span>
  <span>if</span> <span>(</span>start <span>></span> destination<span>)</span> <span>[</span>start<span>,</span> destination<span>]</span> <span>=</span> <span>[</span>destination<span>,</span> start<span>]</span><span>;</span>
  <span>const</span> total <span>=</span> distance<span>.</span><span>reduce</span><span>(</span><span>(</span><span>acc<span>,</span> cur</span><span>)</span> <span>=></span> acc <span>+</span> cur<span>)</span><span>,</span>route <span>=</span> distance<span>.</span><span>slice</span><span>(</span>start<span>,</span> destination<span>)</span><span>.</span><span>reduce</span><span>(</span><span>(</span><span>acc<span>,</span> cur</span><span>)</span> <span>=></span> acc <span>+</span> cur<span>)</span><span>;</span>
  <span>return</span> Math<span>.</span><span>min</span><span>(</span>route<span>,</span> total <span>-</span> route<span>)</span><span>;</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div><h2 id="_1185-一周中的第几天"> 1185.一周中的第几天</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1185 lang=javascript
 *
 * [1185] 一周中的第几天
 * 
 * 给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。

输入为三个整数：day、month 和 year，分别表示日、月、年。

您返回的结果必须是这几个值中的一个 {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}。

 

示例 1：

输入：day = 31, month = 8, year = 2019
输出："Saturday"
示例 2：

输入：day = 18, month = 7, year = 1999
输出："Sunday"
示例 3：

输入：day = 15, month = 8, year = 1993
输出："Sunday"
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} day
 * @param {number} month
 * @param {number} year
 * @return {string}
 */</span>
<span>var</span> <span>dayOfTheWeek</span> <span>=</span> <span>function</span> <span>(</span><span>day<span>,</span> month<span>,</span> year</span><span>)</span> <span>{</span>
  <span>const</span> a <span>=</span> <span>[</span><span>"Sunday"</span><span>,</span> <span>"Monday"</span><span>,</span> <span>"Tuesday"</span><span>,</span> <span>"Wednesday"</span><span>,</span> <span>"Thursday"</span><span>,</span> <span>"Friday"</span><span>,</span> <span>"Saturday"</span><span>]</span>
  <span>return</span> a<span>[</span><span>new</span> <span>Date</span><span>(</span><span><span>`</span><span><span>${</span>year<span>}</span></span><span>-</span><span><span>${</span>month<span>}</span></span><span>-</span><span><span>${</span>day<span>}</span></span><span>`</span></span><span>)</span><span>.</span><span>getDay</span><span>(</span><span>)</span><span>]</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h2 id="_1189-气球-的最大数量"> 1189.气球-的最大数量</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1189 lang=javascript
 *
 * [1189] “气球” 的最大数量
 * 
 * 给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 "balloon"（气球）。

字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 "balloon"。

 

示例 1：



输入：text = "nlaebolko"
输出：1
示例 2：



输入：text = "loonbalxballpoon"
输出：2
示例 3：

输入：text = "leetcode"
输出：0
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} text
 * @return {number}
 */</span>
<span>var</span> <span>maxNumberOfBalloons</span> <span>=</span> <span>function</span> <span>(</span><span>text</span><span>)</span> <span>{</span>
  <span>const</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>[</span><span>[</span><span>'b'</span><span>,</span> <span>0</span><span>]</span><span>,</span> <span>[</span><span>'a'</span><span>,</span> <span>0</span><span>]</span><span>,</span> <span>[</span><span>'l'</span><span>,</span> <span>0</span><span>]</span><span>,</span> <span>[</span><span>'o'</span><span>,</span> <span>0</span><span>]</span><span>,</span> <span>[</span><span>'n'</span><span>,</span> <span>0</span><span>]</span><span>]</span><span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> text<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>map<span>.</span><span>has</span><span>(</span>text<span>[</span>i<span>]</span><span>)</span><span>)</span> map<span>.</span><span>set</span><span>(</span>text<span>[</span>i<span>]</span><span>,</span> map<span>.</span><span>get</span><span>(</span>text<span>[</span>i<span>]</span><span>)</span> <span>+</span> <span>1</span><span>)</span>
  <span>}</span>
  <span>let</span> res <span>=</span> <span>0</span>
  <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>map<span>.</span><span>get</span><span>(</span><span>'b'</span><span>)</span> <span>>=</span> <span>1</span> <span>&amp;&amp;</span> map<span>.</span><span>get</span><span>(</span><span>'a'</span><span>)</span> <span>>=</span> <span>1</span> <span>&amp;&amp;</span> map<span>.</span><span>get</span><span>(</span><span>'l'</span><span>)</span> <span>>=</span> <span>2</span> <span>&amp;&amp;</span> map<span>.</span><span>get</span><span>(</span><span>'o'</span><span>)</span> <span>>=</span> <span>2</span> <span>&amp;&amp;</span> map<span>.</span><span>get</span><span>(</span><span>'n'</span><span>)</span> <span>>=</span> <span>1</span><span>)</span> <span>{</span>
      res<span>++</span>
      map<span>.</span><span>set</span><span>(</span><span>'b'</span><span>,</span> map<span>.</span><span>get</span><span>(</span><span>'b'</span><span>)</span> <span>-</span> <span>1</span><span>)</span>
      map<span>.</span><span>set</span><span>(</span><span>'a'</span><span>,</span> map<span>.</span><span>get</span><span>(</span><span>'a'</span><span>)</span> <span>-</span> <span>1</span><span>)</span>
      map<span>.</span><span>set</span><span>(</span><span>'l'</span><span>,</span> map<span>.</span><span>get</span><span>(</span><span>'l'</span><span>)</span> <span>-</span> <span>2</span><span>)</span>
      map<span>.</span><span>set</span><span>(</span><span>'o'</span><span>,</span> map<span>.</span><span>get</span><span>(</span><span>'o'</span><span>)</span> <span>-</span> <span>2</span><span>)</span>
      map<span>.</span><span>set</span><span>(</span><span>'n'</span><span>,</span> map<span>.</span><span>get</span><span>(</span><span>'n'</span><span>)</span> <span>-</span> <span>1</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>return</span> res
    <span>}</span>
  <span>}</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div><h2 id="_1200-最小绝对差"> 1200.最小绝对差</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1200 lang=javascript
 *
 * [1200] 最小绝对差
 * 
 * 给你个整数数组 arr，其中每个元素都 不相同。

请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。

每对元素对 [a,b] 如下：

a , b 均为数组 arr 中的元素
a &lt; b
b - a 等于 arr 中任意两个元素的最小绝对差
 

示例 1：

输入：arr = [4,2,1,3]
输出：[[1,2],[2,3],[3,4]]
示例 2：

输入：arr = [1,3,6,10,15]
输出：[[1,3]]
示例 3：

输入：arr = [3,8,-10,23,19,-4,-14,27]
输出：[[-14,-10],[19,23],[23,27]]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} arr
 * @return {number[][]}
 */</span>
<span>var</span> <span>minimumAbsDifference</span> <span>=</span> <span>function</span> <span>(</span><span>arr</span><span>)</span> <span>{</span>
  arr <span>=</span> arr<span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a <span>-</span> b<span>)</span>
  <span>let</span> c <span>=</span> Number<span>.</span><span>MAX_VALUE</span><span>,</span> res <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> v <span>=</span> arr<span>[</span>i<span>]</span> <span>-</span> arr<span>[</span>i <span>-</span> <span>1</span><span>]</span>
    <span>if</span> <span>(</span>v <span>></span> c<span>)</span> <span>continue</span>
    <span>else</span> <span>if</span> <span>(</span>v <span>&lt;</span> c<span>)</span> <span>{</span>
      res <span>=</span> <span>[</span><span>]</span>
      c <span>=</span> v
    <span>}</span>
    res<span>.</span><span>push</span><span>(</span><span>[</span>arr<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>,</span> arr<span>[</span>i<span>]</span><span>]</span><span>)</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><h2 id="_1207-独一无二的出现次数"> 1207.独一无二的出现次数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1207 lang=javascript
 *
 * [1207] 独一无二的出现次数
 * 
 * 给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。

如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。

 

示例 1：

输入：arr = [1,2,2,1,1,3]
输出：true
解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。
示例 2：

输入：arr = [1,2]
输出：false
示例 3：

输入：arr = [-3,0,1,-3,1,1,1,-3,10,0]
输出：true
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} arr
 * @return {boolean}
 */</span>
<span>var</span> <span>uniqueOccurrences</span> <span>=</span> <span>function</span> <span>(</span><span>arr</span><span>)</span> <span>{</span>
  arr <span>=</span> arr<span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a <span>-</span> b<span>)</span>
  <span>const</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span>
  <span>let</span> curr <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    curr<span>++</span>
    <span>if</span> <span>(</span>arr<span>[</span>i<span>]</span> <span>===</span> arr<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>)</span> <span>continue</span>
    <span>if</span> <span>(</span>map<span>.</span><span>has</span><span>(</span>curr<span>)</span><span>)</span> <span>return</span> <span>false</span>
    map<span>.</span><span>set</span><span>(</span>curr<span>,</span> arr<span>[</span>i<span>]</span><span>)</span>
    curr <span>=</span> <span>0</span>
  <span>}</span>
  <span>return</span> <span>true</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><h2 id="_1217-玩筹码"> 1217.玩筹码</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1217 lang=typescript
 *
 * [1217] 玩筹码
 * 
 * 有 n 个筹码。第 i 个筹码的位置是 position[i] 。

我们需要把所有筹码移到同一个位置。在一步中，我们可以将第 i 个筹码的位置从 position[i] 改变为:

position[i] + 2 或 position[i] - 2 ，此时 cost = 0
position[i] + 1 或 position[i] - 1 ，此时 cost = 1
返回将所有筹码移动到同一位置上所需要的 最小代价 。

 

示例 1：



输入：position = [1,2,3]
输出：1
解释：第一步:将位置3的筹码移动到位置1，成本为0。
第二步:将位置2的筹码移动到位置1，成本= 1。
总成本是1。
示例 2：



输入：position = [2,2,2,3,3]
输出：2
解释：我们可以把位置3的两个筹码移到位置2。每一步的成本为1。总成本= 2。
示例 3:

输入：position = [1,1000000000]
输出：1
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>minCostToMoveChips</span><span>(</span>position<span>:</span> <span>number</span><span>[</span><span>]</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>let</span> j <span>=</span> <span>0</span><span>,</span>
    o <span>=</span> <span>0</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> position<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>position<span>[</span>i<span>]</span> <span>%</span> <span>2</span> <span>===</span> <span>0</span><span>)</span> <span>{</span>
      o<span>++</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      j<span>++</span><span>;</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> Math<span>.</span><span>min</span><span>(</span>j<span>,</span> o<span>)</span><span>;</span>
<span>}</span>
<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><h2 id="_1221-分割平衡字符串"> 1221.分割平衡字符串</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1221 lang=javascript
 *
 * [1221] 分割平衡字符串
 * 
 * 平衡字符串 中，'L' 和 'R' 字符的数量是相同的。

给你一个平衡字符串 s，请你将它分割成尽可能多的子字符串，并满足：

每个子字符串都是平衡字符串。
返回可以通过分割得到的平衡字符串的 最大数量 。

 

示例 1：

输入：s = "RLRRLLRLRL"
输出：4
解释：s 可以分割为 "RL"、"RRLL"、"RL"、"RL" ，每个子字符串中都包含相同数量的 'L' 和 'R' 。
示例 2：

输入：s = "RLRRRLLRLL"
输出：2
解释：s 可以分割为 "RL"、"RRRLLRLL"，每个子字符串中都包含相同数量的 'L' 和 'R' 。
注意，s 无法分割为 "RL"、"RR"、"RL"、"LR"、"LL" 因为第 2 个和第 5 个子字符串不是平衡字符串。
示例 3：

输入：s = "LLLLRRRR"
输出：1
解释：s 只能保持原样 "LLLLRRRR" 。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @return {number}
 */</span>
<span>var</span> <span>balancedStringSplit</span> <span>=</span> <span>function</span> <span>(</span><span>s</span><span>)</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>0</span><span>,</span> r <span>=</span> <span>0</span><span>,</span> l <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>s<span>[</span>i<span>]</span> <span>===</span> <span>'R'</span><span>)</span> r<span>++</span>
    <span>else</span> l<span>++</span>
    <span>if</span> <span>(</span>r <span>===</span> l<span>)</span> <span>{</span>
      res<span>++</span>
      r <span>=</span> <span>0</span>
      l <span>=</span> <span>0</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div><h2 id="_1232-缀点成线"> 1232.缀点成线</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1232 lang=javascript
 *
 * [1232] 缀点成线
 * 
 * 给定一个数组 coordinates ，其中 coordinates[i] = [x, y] ， [x, y] 表示横坐标为 x、纵坐标为 y 的点。请你来判断，这些点是否在该坐标系中属于同一条直线上。

 

示例 1：



输入：coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]
输出：true
示例 2：



输入：coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]
输出：false
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[][]} coordinates
 * @return {boolean}
 */</span>
<span>var</span> <span>checkStraightLine</span> <span>=</span> <span>function</span> <span>(</span><span>coordinates</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;</span> coordinates<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> x <span>=</span> <span>(</span>coordinates<span>[</span>i<span>]</span><span>[</span><span>0</span><span>]</span> <span>-</span> coordinates<span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span><span>)</span> <span>/</span> <span>(</span>coordinates<span>[</span>i<span>]</span><span>[</span><span>1</span><span>]</span> <span>-</span> coordinates<span>[</span><span>0</span><span>]</span><span>[</span><span>1</span><span>]</span><span>)</span><span>,</span> y <span>=</span> <span>(</span>coordinates<span>[</span>i<span>]</span><span>[</span><span>0</span><span>]</span> <span>-</span> coordinates<span>[</span><span>1</span><span>]</span><span>[</span><span>0</span><span>]</span><span>)</span> <span>/</span> <span>(</span>coordinates<span>[</span>i<span>]</span><span>[</span><span>1</span><span>]</span> <span>-</span> coordinates<span>[</span><span>1</span><span>]</span><span>[</span><span>1</span><span>]</span><span>)</span>
    <span>if</span> <span>(</span>x <span>!==</span> y <span>&amp;&amp;</span> <span>!</span><span>(</span><span>(</span>x <span>===</span> <span>Infinity</span> <span>||</span> x <span>===</span> <span>-</span><span>Infinity</span><span>)</span> <span>&amp;&amp;</span> <span>(</span>y <span>===</span> <span>Infinity</span> <span>||</span> y <span>===</span> <span>-</span><span>Infinity</span><span>)</span><span>)</span><span>)</span> <span>{</span>
      <span>return</span> <span>false</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>true</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id="_1252-奇数值单元格的数目"> 1252.奇数值单元格的数目</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1252 lang=javascript
 *
 * [1252] 奇数值单元格的数目
 * 
 * 给你一个 m x n 的矩阵，最开始的时候，每个单元格中的值都是 0。

另有一个二维索引数组 indices，indices[i] = [ri, ci] 指向矩阵中的某个位置，其中 ri 和 ci 分别表示指定的行和列（从 0 开始编号）。

对 indices[i] 所指向的每个位置，应同时执行下述增量操作：

ri 行上的所有单元格，加 1 。
ci 列上的所有单元格，加 1 。
给你 m、n 和 indices 。请你在执行完所有 indices 指定的增量操作后，返回矩阵中 奇数值单元格 的数目。

 

示例 1：



输入：m = 2, n = 3, indices = [[0,1],[1,1]]
输出：6
解释：最开始的矩阵是 [[0,0,0],[0,0,0]]。
第一次增量操作后得到 [[1,2,1],[0,1,0]]。
最后的矩阵是 [[1,3,1],[1,3,1]]，里面有 6 个奇数。
示例 2：



输入：m = 2, n = 2, indices = [[1,1],[0,0]]
输出：0
解释：最后的矩阵是 [[2,2],[2,2]]，里面没有奇数。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} m
 * @param {number} n
 * @param {number[][]} indices
 * @return {number}
 */</span>
<span>var</span> <span>oddCells</span> <span>=</span> <span>function</span> <span>(</span><span>m<span>,</span> n<span>,</span> indices</span><span>)</span> <span>{</span>
  <span>const</span> arr <span>=</span> <span>[</span><span>]</span><span>;</span>
  <span>let</span> res <span>=</span> <span>0</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> indices<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> <span>[</span>x<span>,</span> y<span>]</span> <span>=</span> indices<span>[</span>i<span>]</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> m<span>;</span> j<span>++</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>i <span>===</span> <span>0</span><span>)</span> arr<span>.</span><span>push</span><span>(</span><span>[</span><span>]</span><span>)</span>
      <span>for</span> <span>(</span><span>let</span> z <span>=</span> <span>0</span><span>;</span> z <span>&lt;</span> n<span>;</span> z<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>i <span>===</span> <span>0</span><span>)</span> arr<span>[</span>j<span>]</span><span>.</span><span>push</span><span>(</span><span>0</span><span>)</span>
        <span>if</span> <span>(</span>x <span>===</span> j <span>||</span> y <span>===</span> z<span>)</span> <span>{</span>
          arr<span>[</span>j<span>]</span><span>[</span>z<span>]</span> <span>+=</span> <span>1</span>
        <span>}</span>
        <span>if</span> <span>(</span>x <span>===</span> j <span>&amp;&amp;</span> y <span>===</span> z<span>)</span> <span>{</span>
          arr<span>[</span>j<span>]</span><span>[</span>z<span>]</span> <span>+=</span> <span>1</span>
        <span>}</span>
        <span>if</span> <span>(</span>i <span>===</span> indices<span>.</span>length <span>-</span> <span>1</span><span>)</span> <span>{</span>
          <span>if</span> <span>(</span>arr<span>[</span>j<span>]</span><span>[</span>z<span>]</span> <span>%</span> <span>2</span> <span>!==</span> <span>0</span><span>)</span> res<span>++</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br></div></div><h2 id="_1260-二维网格迁移"> 1260.二维网格迁移</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1260 lang=typescript
 *
 * [1260] 二维网格迁移
 * 
 * 给你一个 m 行 n 列的二维网格 grid 和一个整数 k。你需要将 grid 迁移 k 次。

每次「迁移」操作将会引发下述活动：

位于 grid[i][j] 的元素将会移动到 grid[i][j + 1]。
位于 grid[i][n - 1] 的元素将会移动到 grid[i + 1][0]。
位于 grid[m - 1][n - 1] 的元素将会移动到 grid[0][0]。
请你返回 k 次迁移操作后最终得到的 二维网格。

 

示例 1：



输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1
输出：[[9,1,2],[3,4,5],[6,7,8]]
示例 2：



输入：grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4
输出：[[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]
示例 3：

输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9
输出：[[1,2,3],[4,5,6],[7,8,9]]
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>shiftGrid</span><span>(</span>grid<span>:</span> <span>number</span><span>[</span><span>]</span><span>[</span><span>]</span><span>,</span> k<span>:</span> <span>number</span><span>)</span><span>:</span> <span>number</span><span>[</span><span>]</span><span>[</span><span>]</span> <span>{</span>
  <span>let</span> curr <span>=</span> <span>0</span><span>;</span>
  <span>while</span> <span>(</span>curr <span>&lt;</span> k<span>)</span> <span>{</span>
    curr<span>++</span><span>;</span>
    <span>const</span> arr<span>:</span> <span>number</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>]</span><span>;</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> grid<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      arr<span>.</span><span>push</span><span>(</span>grid<span>[</span>i<span>]</span><span>.</span><span>pop</span><span>(</span><span>)</span><span>!</span><span>)</span><span>;</span>
    <span>}</span>
    grid<span>[</span><span>0</span><span>]</span><span>.</span><span>unshift</span><span>(</span>arr<span>.</span><span>pop</span><span>(</span><span>)</span><span>!</span><span>)</span><span>;</span>
    <span>if</span><span>(</span>grid<span>.</span>length <span>&lt;</span> <span>2</span><span>)</span> <span>continue</span><span>;</span>
    grid<span>[</span><span>1</span><span>]</span><span>.</span><span>unshift</span><span>(</span>arr<span>.</span><span>shift</span><span>(</span><span>)</span><span>!</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      grid<span>[</span>i <span>+</span> <span>2</span><span>]</span><span>.</span><span>unshift</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> grid<span>;</span>
<span>}</span>
<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><h2 id="_1266-访问所有点的最小时间"> 1266.访问所有点的最小时间</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1266 lang=typescript
 *
 * [1266] 访问所有点的最小时间
 * 
 * 平面上有 n 个点，点的位置用整数坐标表示 points[i] = [xi, yi] 。请你计算访问所有这些点需要的 最小时间（以秒为单位）。

你需要按照下面的规则在平面上移动：

每一秒内，你可以：
沿水平方向移动一个单位长度，或者
沿竖直方向移动一个单位长度，或者
跨过对角线移动 sqrt(2) 个单位长度（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。
必须按照数组中出现的顺序来访问这些点。
在访问某个点时，可以经过该点后面出现的点，但经过的那些点不算作有效访问。
 

示例 1：



输入：points = [[1,1],[3,4],[-1,0]]
输出：7
解释：一条最佳的访问路径是： [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0]   
从 [1,1] 到 [3,4] 需要 3 秒 
从 [3,4] 到 [-1,0] 需要 4 秒
一共需要 7 秒
示例 2：

输入：points = [[3,2],[-2,2]]
输出：5
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>minTimeToVisitAllPoints</span><span>(</span>points<span>:</span> <span>number</span><span>[</span><span>]</span><span>[</span><span>]</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>let</span> res<span>:</span> <span>number</span> <span>=</span> <span>0</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> points<span>.</span>length <span>-</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> x <span>=</span> Math<span>.</span><span>abs</span><span>(</span>points<span>[</span>i<span>]</span><span>[</span><span>0</span><span>]</span> <span>-</span> points<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
    <span>const</span> y <span>=</span> Math<span>.</span><span>abs</span><span>(</span>points<span>[</span>i<span>]</span><span>[</span><span>1</span><span>]</span> <span>-</span> points<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>[</span><span>1</span><span>]</span><span>)</span><span>;</span>
    res <span>+=</span> Math<span>.</span><span>max</span><span>(</span>x<span>,</span> y<span>)</span><span>;</span>
  <span>}</span>
  <span>return</span> res<span>;</span>
<span>}</span>
<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h2 id="_1281-整数的各位积和之差"> 1281.整数的各位积和之差</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1281 lang=javascript
 *
 * [1281] 整数的各位积和之差
 * 
 * 给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。

 

示例 1：

输入：n = 234
输出：15 
解释：
各位数之积 = 2 * 3 * 4 = 24 
各位数之和 = 2 + 3 + 4 = 9 
结果 = 24 - 9 = 15
示例 2：

输入：n = 4421
输出：21
解释： 
各位数之积 = 4 * 4 * 2 * 1 = 32 
各位数之和 = 4 + 4 + 2 + 1 = 11 
结果 = 32 - 11 = 21
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} n
 * @return {number}
 */</span>
<span>var</span> <span>subtractProductAndSum</span> <span>=</span> <span>function</span> <span>(</span><span>n</span><span>)</span> <span>{</span>
  n <span>=</span> n<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
  <span>let</span> a <span>=</span> <span>1</span><span>,</span> b <span>=</span> <span>0</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    a <span>*=</span> <span>Number</span><span>(</span>n<span>[</span>i<span>]</span><span>)</span>
    b <span>+=</span> <span>Number</span><span>(</span>n<span>[</span>i<span>]</span><span>)</span>
  <span>}</span>
  <span>return</span> a <span>-</span> b
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><h2 id="_1287-有序数组中出现次数超过-25-的元素"> 1287.有序数组中出现次数超过-25-的元素</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1287 lang=javascript
 *
 * [1287] 有序数组中出现次数超过25%的元素
 * 
 * 给你一个非递减的 有序 整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。

请你找到并返回这个整数

 

示例：

输入：arr = [1,2,2,6,6,6,6,7,10]
输出：6
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} arr
 * @return {number}
 */</span>
<span>var</span> <span>findSpecialInteger</span> <span>=</span> <span>function</span> <span>(</span><span>arr</span><span>)</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>0</span><span>,</span> count <span>=</span> <span>1</span>
  <span>if</span> <span>(</span>arr<span>.</span>length <span>&lt;</span> <span>3</span><span>)</span> <span>return</span> arr<span>[</span><span>0</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>arr<span>[</span>i<span>]</span> <span>===</span> arr<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span> <span>{</span>
      count<span>++</span>
      res <span>=</span> arr<span>[</span>i<span>]</span>
      <span>if</span> <span>(</span>count <span>></span> arr<span>.</span>length <span>/</span> <span>4</span><span>)</span> <span>return</span> res
    <span>}</span> <span>else</span> <span>{</span>
      res <span>=</span> <span>0</span>
      count <span>=</span> <span>1</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id="_1290-二进制链表转整数"> 1290.二进制链表转整数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1290 lang=javascript
 *
 * [1290] 二进制链表转整数
 * 
 * 给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。

请你返回该链表所表示数字的 十进制值 。

 

示例 1：



输入：head = [1,0,1]
输出：5
解释：二进制数 (101) 转化为十进制数 (5)
示例 2：

输入：head = [0]
输出：0
示例 3：

输入：head = [1]
输出：1
示例 4：

输入：head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]
输出：18880
示例 5：

输入：head = [0,0]
输出：0
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */</span>
<span>/**
 * @param {ListNode} head
 * @return {number}
 */</span>
<span>var</span> <span>getDecimalValue</span> <span>=</span> <span>function</span> <span>(</span><span>head</span><span>)</span> <span>{</span>
  <span>let</span> num <span>=</span> <span>''</span>
  <span>while</span> <span>(</span>head<span>)</span> <span>{</span>
    num <span>+=</span> head<span>.</span>val
    head <span>=</span> head<span>.</span>next
  <span>}</span>
  <span>return</span> <span>parseInt</span><span>(</span>num<span>,</span> <span>2</span><span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br></div></div><h2 id="_1295-统计位数为偶数的数字"> 1295.统计位数为偶数的数字</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1295 lang=javascript
 *
 * [1295] 统计位数为偶数的数字
 * 
 * 给你一个整数数组 nums，请你返回其中位数为 偶数 的数字的个数。

 

示例 1：

输入：nums = [12,345,2,6,7896]
输出：2
解释：
12 是 2 位数字（位数为偶数） 
345 是 3 位数字（位数为奇数）  
2 是 1 位数字（位数为奇数） 
6 是 1 位数字 位数为奇数） 
7896 是 4 位数字（位数为偶数）  
因此只有 12 和 7896 是位数为偶数的数字
示例 2：

输入：nums = [555,901,482,1771]
输出：1 
解释： 
只有 1771 是位数为偶数的数字。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number}
 */</span>
<span>var</span> <span>findNumbers</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span>length <span>%</span> <span>2</span> <span>===</span> <span>0</span><span>)</span> res<span>++</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h2 id="_1299-将每个元素替换为右侧最大元素"> 1299.将每个元素替换为右侧最大元素</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1299 lang=javascript
 *
 * [1299] 将每个元素替换为右侧最大元素
 * 
 * 给你一个数组 arr ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 -1 替换。

完成所有替换操作后，请你返回这个数组。

 

示例 1：

输入：arr = [17,18,5,4,6,1]
输出：[18,6,6,6,1,-1]
解释：
- 下标 0 的元素 --> 右侧最大元素是下标 1 的元素 (18)
- 下标 1 的元素 --> 右侧最大元素是下标 4 的元素 (6)
- 下标 2 的元素 --> 右侧最大元素是下标 4 的元素 (6)
- 下标 3 的元素 --> 右侧最大元素是下标 4 的元素 (6)
- 下标 4 的元素 --> 右侧最大元素是下标 5 的元素 (1)
- 下标 5 的元素 --> 右侧没有其他元素，替换为 -1
示例 2：

输入：arr = [400]
输出：[-1]
解释：下标 0 的元素右侧没有其他元素。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} arr
 * @return {number[]}
 */</span>
<span>var</span> <span>replaceElements</span> <span>=</span> <span>function</span> <span>(</span><span>arr</span><span>)</span> <span>{</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length <span>-</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
    res<span>.</span><span>push</span><span>(</span>Math<span>.</span><span>max</span><span>(</span><span>...</span>arr<span>.</span><span>slice</span><span>(</span>i <span>+</span> <span>1</span><span>,</span> arr<span>.</span>length<span>)</span><span>)</span><span>)</span>
  <span>}</span>
  res<span>.</span><span>push</span><span>(</span><span>-</span><span>1</span><span>)</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h2 id="_1304-和为零的n个唯一整数"> 1304.和为零的n个唯一整数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1304 lang=javascript
 *
 * [1304] 和为零的N个唯一整数
 * 
 * 给你一个整数 n，请你返回 任意 一个由 n 个 各不相同 的整数组成的数组，并且这 n 个数相加和为 0 。

 

示例 1：

输入：n = 5
输出：[-7,-1,1,3,4]
解释：这些数组也是正确的 [-5,-1,1,2,3]，[-3,-1,2,-2,4]。
示例 2：

输入：n = 3
输出：[-1,0,1]
示例 3：

输入：n = 1
输出：[0]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} n
 * @return {number[]}
 */</span>
<span>var</span> <span>sumZero</span> <span>=</span> <span>function</span> <span>(</span><span>n</span><span>)</span> <span>{</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span>
  <span>let</span> count <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    res<span>.</span><span>push</span><span>(</span>i<span>)</span>
    count <span>+=</span> i
  <span>}</span>
  res<span>.</span><span>push</span><span>(</span><span>-</span>count<span>)</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><h2 id="_1309-解码字母到整数映射"> 1309.解码字母到整数映射</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1309 lang=javascript
 *
 * [1309] 解码字母到整数映射
 * 
 * 给你一个字符串 s，它由数字（'0' - '9'）和 '#' 组成。我们希望按下述规则将 s 映射为一些小写英文字符：

字符（'a' - 'i'）分别用（'1' - '9'）表示。
字符（'j' - 'z'）分别用（'10#' - '26#'）表示。 
返回映射之后形成的新字符串。

题目数据保证映射始终唯一。

 

示例 1：

输入：s = "10#11#12"
输出："jkab"
解释："j" -> "10#" , "k" -> "11#" , "a" -> "1" , "b" -> "2".
示例 2：

输入：s = "1326#"
输出："acz"
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @return {string}
 */</span>
<span>var</span> <span>freqAlphabets</span> <span>=</span> <span>function</span> <span>(</span><span>s</span><span>)</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>''</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>s<span>[</span>i <span>+</span> <span>2</span><span>]</span> <span>===</span> <span>"#"</span><span>)</span> <span>{</span>
      res <span>+=</span> String<span>.</span><span>fromCharCode</span><span>(</span><span>Number</span><span>(</span>s<span>[</span>i<span>]</span> <span>+</span> s<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>)</span> <span>+</span> <span>96</span><span>)</span>
      i <span>+=</span> <span>2</span>
    <span>}</span> <span>else</span> <span>{</span>
      res <span>+=</span> String<span>.</span><span>fromCharCode</span><span>(</span><span>Number</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span> <span>+</span> <span>96</span><span>)</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><h2 id="_1313-解压缩编码列表"> 1313.解压缩编码列表</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1313 lang=javascript
 *
 * [1313] 解压缩编码列表
 * 
 * 给你一个以行程长度编码压缩的整数列表 nums 。

考虑每对相邻的两个元素 [freq, val] = [nums[2*i], nums[2*i+1]] （其中 i >= 0 ），每一对都表示解压后子列表中有 freq 个值为 val 的元素，你需要从左到右连接所有子列表以生成解压后的列表。

请你返回解压后的列表。

 

示例 1：

输入：nums = [1,2,3,4]
输出：[2,4,4,4]
解释：第一对 [1,2] 代表着 2 的出现频次为 1，所以生成数组 [2]。
第二对 [3,4] 代表着 4 的出现频次为 3，所以生成数组 [4,4,4]。
最后将它们串联到一起 [2] + [4,4,4] = [2,4,4,4]。
示例 2：

输入：nums = [1,1,2,3]
输出：[1,3,3]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number[]}
 */</span>
<span>var</span> <span>decompressRLElist</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i <span>+=</span> <span>2</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> nums<span>[</span>i<span>]</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>
      res<span>.</span><span>push</span><span>(</span>nums<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>)</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h2 id="_1317-将整数转换为两个无零整数的和"> 1317.将整数转换为两个无零整数的和</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1317 lang=javascript
 *
 * [1317] 将整数转换为两个无零整数的和
 * 
 * 「无零整数」是十进制表示中 不含任何 0 的正整数。

给你一个整数 n，请你返回一个 由两个整数组成的列表 [A, B]，满足：

A 和 B 都是无零整数
A + B = n
题目数据保证至少有一个有效的解决方案。

如果存在多个有效解决方案，你可以返回其中任意一个。

 

示例 1：

输入：n = 2
输出：[1,1]
解释：A = 1, B = 1. A + B = n 并且 A 和 B 的十进制表示形式都不包含任何 0 。
示例 2：

输入：n = 11
输出：[2,9]
示例 3：

输入：n = 10000
输出：[1,9999]
示例 4：

输入：n = 69
输出：[1,68]
示例 5：

输入：n = 1010
输出：[11,999]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} n
 * @return {number[]}
 */</span>
<span>var</span> <span>getNoZeroIntegers</span> <span>=</span> <span>function</span> <span>(</span><span>n</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> <span>(</span>n <span>/</span> <span>2</span><span>)</span> <span>+</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>i<span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span><span>includes</span><span>(</span><span>'0'</span><span>)</span> <span>&amp;&amp;</span> <span>!</span><span>(</span>n <span>-</span> i<span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span><span>includes</span><span>(</span><span>'0'</span><span>)</span><span>)</span> <span>return</span> <span>[</span>i<span>,</span> n <span>-</span> i<span>]</span>
  <span>}</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div><h2 id="_1323-6-和-9-组成的最大数字"> 1323.6-和-9-组成的最大数字</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1323 lang=javascript
 *
 * [1323] 6 和 9 组成的最大数字
 * 
 * 给你一个仅由数字 6 和 9 组成的正整数 num。

你最多只能翻转一位数字，将 6 变成 9，或者把 9 变成 6 。

请返回你可以得到的最大数字。

 

示例 1：

输入：num = 9669
输出：9969
解释：
改变第一位数字可以得到 6669 。
改变第二位数字可以得到 9969 。
改变第三位数字可以得到 9699 。
改变第四位数字可以得到 9666 。
其中最大的数字是 9969 。
示例 2：

输入：num = 9996
输出：9999
解释：将最后一位从 6 变到 9，其结果 9999 是最大的数。
示例 3：

输入：num = 9999
输出：9999
解释：无需改变就已经是最大的数字了。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} num
 * @return {number}
 */</span>
<span>var</span> <span>maximum69Number</span>  <span>=</span> <span>function</span><span>(</span><span>num</span><span>)</span> <span>{</span>
  <span>return</span> <span>Number</span><span>(</span>num<span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span><span>replace</span><span>(</span><span>'6'</span><span>,</span><span>'9'</span><span>)</span><span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><h2 id="_1331-数组序号转换"> 1331.数组序号转换</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1331 lang=javascript
 *
 * [1331] 数组序号转换
 * 
 * 给你一个整数数组 arr ，请你将数组中的每个元素替换为它们排序后的序号。

序号代表了一个元素有多大。序号编号的规则如下：

序号从 1 开始编号。
一个元素越大，那么序号越大。如果两个元素相等，那么它们的序号相同。
每个数字的序号都应该尽可能地小。
 

示例 1：

输入：arr = [40,10,20,30]
输出：[4,1,2,3]
解释：40 是最大的元素。 10 是最小的元素。 20 是第二小的数字。 30 是第三小的数字。
示例 2：

输入：arr = [100,100,100]
输出：[1,1,1]
解释：所有元素有相同的序号。
示例 3：

输入：arr = [37,12,28,9,100,56,80,5,12]
输出：[5,3,4,2,8,6,7,1,3]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} arr
 * @return {number[]}
 */</span>
<span>var</span> <span>arrayRankTransform</span> <span>=</span> <span>function</span> <span>(</span><span>arr</span><span>)</span> <span>{</span>
  <span>const</span> a <span>=</span> <span>[</span><span>...</span><span>new</span> <span>Set</span><span>(</span><span>[</span><span>...</span>arr<span>]</span><span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a <span>-</span> b<span>)</span><span>)</span><span>]</span><span>,</span> res <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    res<span>.</span><span>push</span><span>(</span>a<span>.</span><span>indexOf</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span> <span>+</span> <span>1</span><span>)</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h2 id="_1332-删除回文子序列"> 1332.删除回文子序列</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1332 lang=javascript
 *
 * [1332] 删除回文子序列
 * 
 * 给你一个字符串 s，它仅由字母 'a' 和 'b' 组成。每一次删除操作都可以从 s 中删除一个回文 子序列。

返回删除给定字符串中所有字符（字符串为空）的最小删除次数。

「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。

「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。

 

示例 1：

输入：s = "ababa"
输出：1
解释：字符串本身就是回文序列，只需要删除一次。
示例 2：

输入：s = "abb"
输出：2
解释："abb" -> "bb" -> "". 
先删除回文子序列 "a"，然后再删除 "bb"。
示例 3：

输入：s = "baabb"
输出：2
解释："baabb" -> "b" -> "". 
先删除回文子序列 "baab"，然后再删除 "b"。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
//  * @param {string} s
//  * @return {number}
//  */</span>
<span>// const removePalindromeSub = (s) => {</span>
<span>//   let res = 0, i = 0</span>
<span>//   while (s.length > 0) {</span>
<span>//     const a = s.substring(0, s.length - i)</span>
<span>//     if (a.split('').reverse().join('')) {</span>
<span>//       res++</span>
<span>//       s = s.substring(s.length - i, s.length)</span>
<span>//       i = 0</span>
<span>//     } else {</span>
<span>//       i++</span>
<span>//     }</span>
<span>//   }</span>
<span>//   return res</span>
<span>// };</span>

<span>/**
 * @param {string} s
 * @return {number}
 */</span>
<span>const</span> <span>removePalindromeSub</span> <span>=</span> <span>s</span> <span>=></span> s <span>===</span> s<span>.</span><span>split</span><span>(</span><span>''</span><span>)</span><span>.</span><span>reverse</span><span>(</span><span>)</span><span>.</span><span>join</span><span>(</span><span>''</span><span>)</span> <span>?</span> <span>1</span> <span>:</span> <span>2</span>

<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br></div></div><h2 id="_1337-矩阵中战斗力最弱的-k-行"> 1337.矩阵中战斗力最弱的-k-行</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1337 lang=javascript
 *
 * [1337] 矩阵中战斗力最弱的 K 行
 * 
 * 给你一个大小为 m * n 的矩阵 mat，矩阵由若干军人和平民组成，分别用 1 和 0 表示。

请你返回矩阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。

如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱。

军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。

 

示例 1：

输入：mat = 
[[1,1,0,0,0],
 [1,1,1,1,0],
 [1,0,0,0,0],
 [1,1,0,0,0],
 [1,1,1,1,1]], 
k = 3
输出：[2,0,3]
解释：
每行中的军人数目：
行 0 -> 2 
行 1 -> 4 
行 2 -> 1 
行 3 -> 2 
行 4 -> 5 
从最弱到最强对这些行排序后得到 [2,0,3,1,4]
示例 2：

输入：mat = 
[[1,0,0,0],
 [1,1,1,1],
 [1,0,0,0],
 [1,0,0,0]], 
k = 2
输出：[0,2]
解释： 
每行中的军人数目：
行 0 -> 1 
行 1 -> 4 
行 2 -> 1 
行 3 -> 1 
从最弱到最强对这些行排序后得到 [0,2,3,1]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[][]} mat
 * @param {number} k
 * @return {number[]}
 */</span>
<span>var</span> <span>kWeakestRows</span> <span>=</span> <span>function</span> <span>(</span><span>mat<span>,</span> k</span><span>)</span> <span>{</span>
  <span>const</span> arr <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> mat<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>let</span> c <span>=</span> <span>0</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> mat<span>[</span>i<span>]</span><span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>mat<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>===</span> <span>0</span><span>)</span> <span>{</span>
        arr<span>.</span><span>push</span><span>(</span><span>{</span> i<span>,</span> c <span>}</span><span>)</span>
        c <span>=</span> <span>0</span>
        <span>break</span>
      <span>}</span> <span>else</span> <span>{</span>
        c<span>++</span>
        <span>if</span> <span>(</span>c <span>===</span> mat<span>[</span>i<span>]</span><span>.</span>length<span>)</span> <span>{</span>
          arr<span>.</span><span>push</span><span>(</span><span>{</span> i<span>,</span> c <span>}</span><span>)</span>
          c <span>=</span> <span>0</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> arr<span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a<span>.</span>c <span>-</span> b<span>.</span>c<span>)</span><span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span> k<span>)</span><span>.</span><span>map</span><span>(</span><span>(</span><span>item</span><span>)</span> <span>=></span> item<span>.</span>i<span>)</span>

<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br></div></div><h2 id="_1342-将数字变成-0-的操作次数"> 1342.将数字变成-0-的操作次数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1342 lang=javascript
 *
 * [1342] 将数字变成 0 的操作次数
 * 
 * 给你一个非负整数 num ，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。

 

示例 1：

输入：num = 14
输出：6
解释：
步骤 1) 14 是偶数，除以 2 得到 7 。
步骤 2） 7 是奇数，减 1 得到 6 。
步骤 3） 6 是偶数，除以 2 得到 3 。
步骤 4） 3 是奇数，减 1 得到 2 。
步骤 5） 2 是偶数，除以 2 得到 1 。
步骤 6） 1 是奇数，减 1 得到 0 。
示例 2：

输入：num = 8
输出：4
解释：
步骤 1） 8 是偶数，除以 2 得到 4 。
步骤 2） 4 是偶数，除以 2 得到 2 。
步骤 3） 2 是偶数，除以 2 得到 1 。
步骤 4） 1 是奇数，减 1 得到 0 。
示例 3：

输入：num = 123
输出：12
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} num
 * @return {number}
 */</span>
<span>var</span> <span>numberOfSteps</span> <span>=</span> <span>function</span> <span>(</span><span>num</span><span>)</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>0</span>
  <span>while</span> <span>(</span>num <span>></span> <span>0</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>num <span>%</span> <span>2</span> <span>===</span> <span>0</span><span>)</span> num <span>=</span> num <span>/</span> <span>2</span>
    <span>else</span> num<span>--</span>
    res<span>++</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><h2 id="_1346-检查整数及其两倍数是否存在"> 1346.检查整数及其两倍数是否存在</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1346 lang=javascript
 *
 * [1346] 检查整数及其两倍数是否存在
 * 
 * 给你一个整数数组 arr，请你检查是否存在两个整数 N 和 M，满足 N 是 M 的两倍（即，N = 2 * M）。

更正式地，检查是否存在两个下标 i 和 j 满足：

i != j
0 &lt;= i, j &lt; arr.length
arr[i] == 2 * arr[j]
 

示例 1：

输入：arr = [10,2,5,3]
输出：true
解释：N = 10 是 M = 5 的两倍，即 10 = 2 * 5 。
示例 2：

输入：arr = [7,1,14,11]
输出：true
解释：N = 14 是 M = 7 的两倍，即 14 = 2 * 7 。
示例 3：

输入：arr = [3,1,7,11]
输出：false
解释：在该情况下不存在 N 和 M 满足 N = 2 * M 。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} arr
 * @return {boolean}
 */</span>
<span>// var checkIfExist = function (arr) {</span>
<span>//   for (let i = 0; i &lt; arr.length - 1; i++) {</span>
<span>//     for (let j = i + 1; j &lt; arr.length; j++) {</span>
<span>//       if (arr[i] * 2 === arr[j] || arr[i] === arr[j] * 2) return true</span>
<span>//     }</span>
<span>//   }</span>
<span>//   return false</span>
<span>// };</span>

<span>var</span> <span>checkIfExist</span> <span>=</span> <span>function</span> <span>(</span><span>arr</span><span>)</span> <span>{</span>
  <span>const</span> set <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>set<span>.</span><span>has</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span><span>)</span> <span>return</span> <span>true</span>
    <span>else</span> <span>{</span>
      set<span>.</span><span>add</span><span>(</span>arr<span>[</span>i<span>]</span> <span>*</span> <span>2</span><span>)</span>
      set<span>.</span><span>add</span><span>(</span>arr<span>[</span>i<span>]</span> <span>/</span> <span>2</span><span>)</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>false</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br></div></div><h2 id="_1351-统计有序矩阵中的负数"> 1351.统计有序矩阵中的负数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1351 lang=javascript
 *
 * [1351] 统计有序矩阵中的负数
 * 
 * 给你一个 m * n 的矩阵 grid，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。 请你统计并返回 grid 中 负数 的数目。

 

示例 1：

输入：grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]
输出：8
解释：矩阵中共有 8 个负数。
示例 2：

输入：grid = [[3,2],[1,0]]
输出：0
 


 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[][]} grid
 * @return {number}
 */</span>
<span>var</span> <span>countNegatives</span> <span>=</span> <span>function</span> <span>(</span><span>grid</span><span>)</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> grid<span>.</span>length <span>-</span> <span>1</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>grid<span>[</span>i<span>]</span><span>[</span>grid<span>[</span>i<span>]</span><span>.</span>length <span>-</span> <span>1</span><span>]</span> <span>></span> <span>-</span><span>1</span><span>)</span> <span>break</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> grid<span>[</span>i<span>]</span><span>.</span>length <span>-</span> <span>1</span><span>;</span> j <span>>=</span> <span>0</span><span>;</span> j<span>--</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>grid<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>&lt;</span> <span>0</span><span>)</span> res<span>++</span>
      <span>else</span> <span>continue</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h2 id="_1356-根据数字二进制下-1-的数目排序"> 1356.根据数字二进制下-1-的数目排序</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1356 lang=javascript
 *
 * [1356] 根据数字二进制下 1 的数目排序
 * 
 * 给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。

如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。

请你返回排序后的数组。

 

示例 1：

输入：arr = [0,1,2,3,4,5,6,7,8]
输出：[0,1,2,4,8,3,5,6,7]
解释：[0] 是唯一一个有 0 个 1 的数。
[1,2,4,8] 都有 1 个 1 。
[3,5,6] 有 2 个 1 。
[7] 有 3 个 1 。
按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]
示例 2：

输入：arr = [1024,512,256,128,64,32,16,8,4,2,1]
输出：[1,2,4,8,16,32,64,128,256,512,1024]
解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。
示例 3：

输入：arr = [10000,10000]
输出：[10000,10000]
示例 4：

输入：arr = [2,3,5,7,11,13,17,19]
输出：[2,3,5,17,7,11,13,19]
示例 5：

输入：arr = [10,100,1000,10000]
输出：[10,100,10000,1000]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} arr
 * @return {number[]}
 */</span>
<span>const</span> <span>sortByBits</span> <span>=</span> <span>(</span><span>arr</span><span>)</span> <span>=></span> arr<span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> <span>count</span><span>(</span>a<span>)</span> <span>-</span> <span>count</span><span>(</span>b<span>)</span> <span>||</span> a <span>-</span> b<span>)</span><span>;</span>

<span>const</span> <span>count</span> <span>=</span> <span>(</span><span>num</span><span>)</span> <span>=></span> num<span>.</span><span>toString</span><span>(</span><span>2</span><span>)</span><span>.</span><span>split</span><span>(</span><span>""</span><span>)</span><span>.</span><span>reduce</span><span>(</span><span>(</span><span>p<span>,</span> c</span><span>)</span> <span>=></span> <span>{</span>
  <span>if</span> <span>(</span>c <span>===</span> <span>"1"</span><span>)</span> p<span>++</span>
  <span>return</span> p
<span>}</span><span>,</span> <span>0</span><span>)</span>

<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div><h2 id="_1360-日期之间隔几天"> 1360.日期之间隔几天</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1360 lang=javascript
 *
 * [1360] 日期之间隔几天
 * 
 * 请你编写一个程序来计算两个日期之间隔了多少天。

日期以字符串形式给出，格式为 YYYY-MM-DD，如示例所示。

 

示例 1：

输入：date1 = "2019-06-29", date2 = "2019-06-30"
输出：1
示例 2：

输入：date1 = "2020-01-15", date2 = "2019-12-31"
输出：15
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} date1
 * @param {string} date2
 * @return {number}
 */</span>
<span>var</span> <span>daysBetweenDates</span> <span>=</span> <span>(</span><span>date1<span>,</span> date2</span><span>)</span> <span>=></span> Math<span>.</span><span>abs</span><span>(</span><span>(</span><span>new</span> <span>Date</span><span>(</span>date1<span>)</span><span>.</span><span>getTime</span><span>(</span><span>)</span> <span>-</span> <span>new</span> <span>Date</span><span>(</span>date2<span>)</span><span>.</span><span>getTime</span><span>(</span><span>)</span><span>)</span> <span>/</span> <span>86400000</span><span>)</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><h2 id="_1365-有多少小于当前数字的数字"> 1365.有多少小于当前数字的数字</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1365 lang=javascript
 *
 * [1365] 有多少小于当前数字的数字
 * 
 * 给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。

换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] &lt; nums[i] 。

以数组形式返回答案。

 

示例 1：

输入：nums = [8,1,2,2,3]
输出：[4,0,1,1,3]
解释： 
对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 
对于 nums[1]=1 不存在比它小的数字。
对于 nums[2]=2 存在一个比它小的数字：（1）。 
对于 nums[3]=2 存在一个比它小的数字：（1）。 
对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。
示例 2：

输入：nums = [6,5,4,8]
输出：[2,1,0,3]
示例 3：

输入：nums = [7,7,7,7]
输出：[0,0,0,0]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number[]}
 */</span>
<span>var</span> <span>smallerNumbersThanCurrent</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>let</span> c <span>=</span> <span>0</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> nums<span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>i <span>!==</span> j <span>&amp;&amp;</span> nums<span>[</span>i<span>]</span> <span>></span> nums<span>[</span>j<span>]</span><span>)</span> c<span>++</span>
      <span>if</span> <span>(</span>j <span>===</span> nums<span>.</span>length <span>-</span> <span>1</span><span>)</span> <span>{</span>
        res<span>.</span><span>push</span><span>(</span>c<span>)</span>
        c <span>=</span> <span>0</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br></div></div><h2 id="_1370-上升下降字符串"> 1370.上升下降字符串</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1370 lang=javascript
 *
 * [1370] 上升下降字符串
 * 
 * 给你一个字符串 s ，请你根据下面的算法重新构造字符串：

从 s 中选出 最小 的字符，将它 接在 结果字符串的后面。
从 s 剩余字符中选出 最小 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。
重复步骤 2 ，直到你没法从 s 中选择字符。
从 s 中选出 最大 的字符，将它 接在 结果字符串的后面。
从 s 剩余字符中选出 最大 的字符，且该字符比上一个添加的字符小，将它 接在 结果字符串后面。
重复步骤 5 ，直到你没法从 s 中选择字符。
重复步骤 1 到 6 ，直到 s 中所有字符都已经被选过。
在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。

请你返回将 s 中字符重新排序后的 结果字符串 。

 

示例 1：

输入：s = "aaaabbbbcccc"
输出："abccbaabccba"
解释：第一轮的步骤 1，2，3 后，结果字符串为 result = "abc"
第一轮的步骤 4，5，6 后，结果字符串为 result = "abccba"
第一轮结束，现在 s = "aabbcc" ，我们再次回到步骤 1
第二轮的步骤 1，2，3 后，结果字符串为 result = "abccbaabc"
第二轮的步骤 4，5，6 后，结果字符串为 result = "abccbaabccba"
示例 2：

输入：s = "rat"
输出："art"
解释：单词 "rat" 在上述算法重排序以后变成 "art"
示例 3：

输入：s = "leetcode"
输出："cdelotee"
示例 4：

输入：s = "ggggggg"
输出："ggggggg"
示例 5：

输入：s = "spo"
输出："ops"
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @return {string}
 */</span>
<span>var</span> <span>sortString</span> <span>=</span> <span>function</span> <span>(</span><span>s</span><span>)</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>''</span><span>,</span> flag <span>=</span> <span>true</span>
  <span>const</span> arr <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> j <span>=</span> s<span>[</span>i<span>]</span><span>.</span><span>charCodeAt</span><span>(</span><span>)</span> <span>-</span> <span>97</span>
    arr<span>[</span>j<span>]</span> <span>=</span> arr<span>[</span>j<span>]</span> <span>?</span> arr<span>[</span>j<span>]</span> <span>+</span> <span>1</span> <span>:</span> <span>1</span>
  <span>}</span>
  <span>while</span> <span>(</span>res<span>.</span>length <span>&lt;</span> s<span>.</span>length<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>flag<span>)</span> <span>{</span>
      <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>arr<span>[</span>i<span>]</span> <span>&amp;&amp;</span> arr<span>[</span>i<span>]</span> <span>></span> <span>0</span><span>)</span> <span>{</span>
          res <span>+=</span> String<span>.</span><span>fromCharCode</span><span>(</span>i <span>+</span> <span>97</span><span>)</span>
          arr<span>[</span>i<span>]</span> <span>-=</span> <span>1</span>
        <span>}</span>
      <span>}</span>
      flag <span>=</span> <span>false</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>for</span> <span>(</span><span>let</span> i <span>=</span> arr<span>.</span>length <span>-</span> <span>1</span><span>;</span> i <span>></span> <span>-</span><span>1</span><span>;</span> i<span>--</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>arr<span>[</span>i<span>]</span> <span>&amp;&amp;</span> arr<span>[</span>i<span>]</span> <span>></span> <span>0</span><span>)</span> <span>{</span>
          res <span>+=</span> String<span>.</span><span>fromCharCode</span><span>(</span>i <span>+</span> <span>97</span><span>)</span>
          arr<span>[</span>i<span>]</span> <span>-=</span> <span>1</span>
        <span>}</span>
      <span>}</span>
      flag <span>=</span> <span>true</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br></div></div><h2 id="_1374-生成每种字符都是奇数个的字符串"> 1374.生成每种字符都是奇数个的字符串</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1374 lang=javascript
 *
 * [1374] 生成每种字符都是奇数个的字符串
 * 
 * 给你一个整数 n，请你返回一个含 n 个字符的字符串，其中每种字符在该字符串中都恰好出现 奇数次 。

返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。

 

示例 1：

输入：n = 4
输出："pppz"
解释："pppz" 是一个满足题目要求的字符串，因为 'p' 出现 3 次，且 'z' 出现 1 次。当然，还有很多其他字符串也满足题目要求，比如："ohhh" 和 "love"。
示例 2：

输入：n = 2
输出："xy"
解释："xy" 是一个满足题目要求的字符串，因为 'x' 和 'y' 各出现 1 次。当然，还有很多其他字符串也满足题目要求，比如："ag" 和 "ur"。
示例 3：

输入：n = 7
输出："holasss"
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} n
 * @return {string}
 */</span>
<span>var</span> <span>generateTheString</span> <span>=</span> <span>function</span> <span>(</span><span>n</span><span>)</span> <span>{</span>
  <span>return</span> n <span>%</span> <span>2</span> <span>===</span> <span>0</span> <span>?</span> <span>'a'</span><span>.</span><span>repeat</span><span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>+</span> <span>'b'</span> <span>:</span> <span>'a'</span><span>.</span><span>repeat</span><span>(</span>n<span>)</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><h2 id="_1380-矩阵中的幸运数"> 1380.矩阵中的幸运数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1380 lang=javascript
 *
 * [1380] 矩阵中的幸运数
 * 
 * 给你一个 m * n 的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。

幸运数 是指矩阵中满足同时下列两个条件的元素：

在同一行的所有元素中最小
在同一列的所有元素中最大
 

示例 1：

输入：matrix = [[3,7,8],[9,11,13],[15,16,17]]
输出：[15]
解释：15 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。
示例 2：

输入：matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]
输出：[12]
解释：12 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。
示例 3：

输入：matrix = [[7,8],[1,2]]
输出：[7]
解释：7是唯一的幸运数字，因为它是行中的最小值，列中的最大值。
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[][]} matrix
 * @return {number[]}
 */</span>
<span>var</span> <span>luckyNumbers</span> <span>=</span> <span>function</span> <span>(</span><span>matrix</span><span>)</span> <span>{</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> matrix<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> item <span>=</span> Math<span>.</span><span>min</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> matrix<span>[</span>i<span>]</span><span>)</span><span>,</span> index <span>=</span> matrix<span>[</span>i<span>]</span><span>.</span><span>indexOf</span><span>(</span>item<span>)</span><span>;</span>
    <span>let</span> max <span>=</span> item
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> matrix<span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
      max <span>=</span> Math<span>.</span><span>max</span><span>(</span>max<span>,</span> matrix<span>[</span>j<span>]</span><span>[</span>index<span>]</span><span>)</span>
    <span>}</span>
    <span>if</span> <span>(</span>max <span>===</span> item<span>)</span> res<span>.</span><span>push</span><span>(</span>max<span>)</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><h2 id="_1385-两个数组间的距离值"> 1385.两个数组间的距离值</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1385 lang=javascript
 *
 * [1385] 两个数组间的距离值
 * 
 * 给你两个整数数组 arr1 ， arr2 和一个整数 d ，请你返回两个数组之间的 距离值 。

「距离值」 定义为符合此距离要求的元素数目：对于元素 arr1[i] ，不存在任何元素 arr2[j] 满足 |arr1[i]-arr2[j]| &lt;= d 。

 

示例 1：

输入：arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2
输出：2
解释：
对于 arr1[0]=4 我们有：
|4-10|=6 > d=2 
|4-9|=5 > d=2 
|4-1|=3 > d=2 
|4-8|=4 > d=2 
所以 arr1[0]=4 符合距离要求

对于 arr1[1]=5 我们有：
|5-10|=5 > d=2 
|5-9|=4 > d=2 
|5-1|=4 > d=2 
|5-8|=3 > d=2
所以 arr1[1]=5 也符合距离要求

对于 arr1[2]=8 我们有：
|8-10|=2 &lt;= d=2
|8-9|=1 &lt;= d=2
|8-1|=7 > d=2
|8-8|=0 &lt;= d=2
存在距离小于等于 2 的情况，不符合距离要求 

故而只有 arr1[0]=4 和 arr1[1]=5 两个符合距离要求，距离值为 2
示例 2：

输入：arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3
输出：2
示例 3：

输入：arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6
输出：1
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} arr1
 * @param {number[]} arr2
 * @param {number} d
 * @return {number}
 */</span>
<span>var</span> <span>findTheDistanceValue</span> <span>=</span> <span>function</span> <span>(</span><span>arr1<span>,</span> arr2<span>,</span> d</span><span>)</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr1<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    res<span>++</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> arr2<span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>Math<span>.</span><span>abs</span><span>(</span>arr1<span>[</span>i<span>]</span> <span>-</span> arr2<span>[</span>j<span>]</span><span>)</span> <span>&lt;=</span> d<span>)</span> <span>{</span>
        res<span>--</span>
        <span>break</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br></div></div><h2 id="_1389-按既定顺序创建目标数组"> 1389.按既定顺序创建目标数组</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1389 lang=javascript
 *
 * [1389] 按既定顺序创建目标数组
 * 
 * 给你两个整数数组 nums 和 index。你需要按照以下规则创建目标数组：

目标数组 target 最初为空。
按从左到右的顺序依次读取 nums[i] 和 index[i]，在 target 数组中的下标 index[i] 处插入值 nums[i] 。
重复上一步，直到在 nums 和 index 中都没有要读取的元素。
请你返回目标数组。

题目保证数字插入位置总是存在。

 

示例 1：

输入：nums = [0,1,2,3,4], index = [0,1,2,2,1]
输出：[0,4,1,3,2]
解释：
nums       index     target
0            0        [0]
1            1        [0,1]
2            2        [0,1,2]
3            2        [0,1,3,2]
4            1        [0,4,1,3,2]
示例 2：

输入：nums = [1,2,3,4,0], index = [0,1,2,3,0]
输出：[0,1,2,3,4]
解释：
nums       index     target
1            0        [1]
2            1        [1,2]
3            2        [1,2,3]
4            3        [1,2,3,4]
0            0        [0,1,2,3,4]
示例 3：

输入：nums = [1], index = [0]
输出：[1]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @param {number[]} index
 * @return {number[]}
 */</span>
<span>var</span> <span>createTargetArray</span> <span>=</span> <span>function</span> <span>(</span><span>nums<span>,</span> index</span><span>)</span> <span>{</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    res<span>.</span><span>splice</span><span>(</span>index<span>[</span>i<span>]</span><span>,</span> <span>0</span><span>,</span> nums<span>[</span>i<span>]</span><span>)</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br></div></div><h2 id="_1394-找出数组中的幸运数"> 1394.找出数组中的幸运数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1394 lang=javascript
 *
 * [1394] 找出数组中的幸运数
 * 
 * 在整数数组中，如果一个整数的出现频次和它的数值大小相等，我们就称这个整数为「幸运数」。

给你一个整数数组 arr，请你从中找出并返回一个幸运数。

如果数组中存在多个幸运数，只需返回 最大 的那个。
如果数组中不含幸运数，则返回 -1 。
 

示例 1：

输入：arr = [2,2,3,4]
输出：2
解释：数组中唯一的幸运数是 2 ，因为数值 2 的出现频次也是 2 。
示例 2：

输入：arr = [1,2,2,3,3,3]
输出：3
解释：1、2 以及 3 都是幸运数，只需要返回其中最大的 3 。
示例 3：

输入：arr = [2,2,2,3,3]
输出：-1
解释：数组中不存在幸运数。
示例 4：

输入：arr = [5]
输出：-1
示例 5：

输入：arr = [7,7,7,7,7,7,7]
输出：7
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} arr
 * @return {number}
 */</span>
<span>var</span> <span>findLucky</span> <span>=</span> <span>function</span> <span>(</span><span>arr</span><span>)</span> <span>{</span>
  <span>const</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span>
  <span>let</span> res <span>=</span> <span>-</span><span>1</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    map<span>.</span><span>set</span><span>(</span>arr<span>[</span>i<span>]</span><span>,</span> map<span>.</span><span>has</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span> <span>?</span> map<span>.</span><span>get</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span> <span>+</span> <span>1</span> <span>:</span> <span>1</span><span>)</span>
  <span>}</span>
  <span>for</span> <span>(</span><span>const</span> <span>[</span>k<span>,</span> v<span>]</span> <span>of</span> map<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>k <span>===</span> v<span>)</span> res <span>=</span> Math<span>.</span><span>max</span><span>(</span>res<span>,</span> k<span>)</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div><h2 id="_1399-统计最大组的数目"> 1399.统计最大组的数目</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1399 lang=javascript
 *
 * [1399] 统计最大组的数目
 * 
 * 给你一个整数 n 。请你先求出从 1 到 n 的每个整数 10 进制表示下的数位和（每一位上的数字相加），然后把数位和相等的数字放到同一个组中。

请你统计每个组中的数字数目，并返回数字数目并列最多的组有多少个。

 

示例 1：

输入：n = 13
输出：4
解释：总共有 9 个组，将 1 到 13 按数位求和后这些组分别是：
[1,10]，[2,11]，[3,12]，[4,13]，[5]，[6]，[7]，[8]，[9]。总共有 4 个组拥有的数字并列最多。
示例 2：

输入：n = 2
输出：2
解释：总共有 2 个大小为 1 的组 [1]，[2]。
示例 3：

输入：n = 15
输出：6
示例 4：

输入：n = 24
输出：5
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number} n
 * @return {number}
 */</span>
<span>var</span> <span>countLargestGroup</span> <span>=</span> <span>function</span> <span>(</span><span>n</span><span>)</span> <span>{</span>
  <span>const</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span>
  <span>let</span> res <span>=</span> <span>0</span><span>,</span> max <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> a <span>=</span> i<span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span><span>split</span><span>(</span><span>""</span><span>)</span><span>.</span><span>reduce</span><span>(</span><span>(</span><span>p<span>,</span> v</span><span>)</span> <span>=></span> p <span>+</span> <span>Number</span><span>(</span>v<span>)</span><span>,</span> <span>0</span><span>)</span>
    map<span>.</span><span>set</span><span>(</span>a<span>,</span> map<span>.</span><span>has</span><span>(</span>a<span>)</span> <span>?</span> map<span>.</span><span>get</span><span>(</span>a<span>)</span> <span>+</span> <span>1</span> <span>:</span> <span>1</span><span>)</span>
    max <span>=</span> Math<span>.</span><span>max</span><span>(</span>max<span>,</span> map<span>.</span><span>get</span><span>(</span>a<span>)</span><span>)</span>
  <span>}</span>
  <span>for</span> <span>(</span><span>const</span> v <span>of</span> map<span>.</span><span>values</span><span>(</span><span>)</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>v <span>===</span> max<span>)</span> res<span>++</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div><h2 id="_1403-非递增顺序的最小子序列"> 1403.非递增顺序的最小子序列</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1403 lang=javascript
 *
 * [1403] 非递增顺序的最小子序列
 * 
 * 给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。

如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。

与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。

注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。

 

示例 1：

输入：nums = [4,3,10,9,8]
输出：[10,9] 
解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。 
示例 2：

输入：nums = [4,4,7,6,7]
输出：[7,7,6] 
解释：子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 = 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。  
示例 3：

输入：nums = [6]
输出：[6]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number[]}
 */</span>
<span>var</span> <span>minSubsequence</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
  nums<span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> b <span>-</span> a<span>)</span>
  <span>let</span> count <span>=</span> nums<span>.</span><span>reduce</span><span>(</span><span>(</span><span>p<span>,</span> v</span><span>)</span> <span>=></span> p <span>+</span> v<span>)</span><span>,</span> s <span>=</span> <span>0</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    s <span>+=</span> nums<span>[</span>i<span>]</span>
    count <span>-=</span> nums<span>[</span>i<span>]</span>
    res<span>.</span><span>push</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span>
    <span>if</span> <span>(</span>s <span>></span> count<span>)</span> <span>return</span> res
  <span>}</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><h2 id="_1408-数组中的字符串匹配"> 1408.数组中的字符串匹配</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1408 lang=javascript
 *
 * [1408] 数组中的字符串匹配
 * 
 * 给你一个字符串数组 words ，数组中的每个字符串都可以看作是一个单词。请你按 任意 顺序返回 words 中是其他单词的子字符串的所有单词。

如果你可以删除 words[j] 最左侧和/或最右侧的若干字符得到 words[i] ，那么字符串 words[i] 就是 words[j] 的一个子字符串。

 

示例 1：

输入：words = ["mass","as","hero","superhero"]
输出：["as","hero"]
解释："as" 是 "mass" 的子字符串，"hero" 是 "superhero" 的子字符串。
["hero","as"] 也是有效的答案。
示例 2：

输入：words = ["leetcode","et","code"]
输出：["et","code"]
解释："et" 和 "code" 都是 "leetcode" 的子字符串。
示例 3：

输入：words = ["blue","green","bu"]
输出：[]
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string[]} words
 * @return {string[]}
 */</span>
<span>var</span> <span>stringMatching</span> <span>=</span> <span>function</span> <span>(</span><span>words</span><span>)</span> <span>{</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> words<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> i <span>+</span> <span>1</span><span>;</span> j <span>&lt;</span> words<span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
      <span>let</span> item
      <span>if</span> <span>(</span>words<span>[</span>i<span>]</span><span>.</span><span>includes</span><span>(</span>words<span>[</span>j<span>]</span><span>)</span><span>)</span> item <span>=</span> words<span>[</span>j<span>]</span>
      <span>else</span> <span>if</span> <span>(</span>words<span>[</span>j<span>]</span><span>.</span><span>includes</span><span>(</span>words<span>[</span>i<span>]</span><span>)</span><span>)</span> item <span>=</span> words<span>[</span>i<span>]</span>
      <span>if</span> <span>(</span>item <span>&amp;&amp;</span> <span>!</span>res<span>.</span><span>includes</span><span>(</span>item<span>)</span><span>)</span> res<span>.</span><span>push</span><span>(</span>item<span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><h2 id="_1413-逐步求和得到正数的最小值"> 1413.逐步求和得到正数的最小值</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1413 lang=javascript
 *
 * [1413] 逐步求和得到正数的最小值
 * 
 * 给你一个整数数组 nums 。你可以选定任意的 正数 startValue 作为初始值。

你需要从左到右遍历 nums 数组，并将 startValue 依次累加上 nums 数组中的值。

请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 正数 作为 startValue 。

 

示例 1：

输入：nums = [-3,2,-3,4,2]
输出：5
解释：如果你选择 startValue = 4，在第三次累加时，和小于 1 。
                累加求和
                startValue = 4 | startValue = 5 | nums
                  (4 -3 ) = 1  | (5 -3 ) = 2    |  -3
                  (1 +2 ) = 3  | (2 +2 ) = 4    |   2
                  (3 -3 ) = 0  | (4 -3 ) = 1    |  -3
                  (0 +4 ) = 4  | (1 +4 ) = 5    |   4
                  (4 +2 ) = 6  | (5 +2 ) = 7    |   2
示例 2：

输入：nums = [1,2]
输出：1
解释：最小的 startValue 需要是正数。
示例 3：

输入：nums = [1,-2,-3]
输出：5
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number}
 */</span>
<span>var</span> <span>minStartValue</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>1</span><span>,</span> count <span>=</span> <span>0</span>
  <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
    count <span>=</span> res
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      count <span>+=</span> nums<span>[</span>i<span>]</span>
      <span>if</span> <span>(</span>count <span>&lt;</span> <span>1</span><span>)</span> <span>{</span>
        res<span>++</span>
        <span>break</span>
      <span>}</span>
      <span>if</span> <span>(</span>i <span>===</span> nums<span>.</span>length <span>-</span> <span>1</span><span>)</span> <span>return</span> res
    <span>}</span>
  <span>}</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br></div></div><h2 id="_1417-重新格式化字符串"> 1417.重新格式化字符串</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1417 lang=javascript
 *
 * [1417] 重新格式化字符串
 * 
 * 给你一个混合了数字和字母的字符串 s，其中的字母均为小写英文字母。

请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。

请你返回 重新格式化后 的字符串；如果无法按要求重新格式化，则返回一个 空字符串 。

 

示例 1：

输入：s = "a0b1c2"
输出："0a1b2c"
解释："0a1b2c" 中任意两个相邻字符的类型都不同。 "a0b1c2", "0a1b2c", "0c2a1b" 也是满足题目要求的答案。
示例 2：

输入：s = "leetcode"
输出：""
解释："leetcode" 中只有字母，所以无法满足重新格式化的条件。
示例 3：

输入：s = "1229857369"
输出：""
解释："1229857369" 中只有数字，所以无法满足重新格式化的条件。
示例 4：

输入：s = "covid2019"
输出："c2o0v1i9d"
示例 5：

输入：s = "ab123"
输出："1a2b3"
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @return {string}
 */</span>
<span>var</span> <span>reformat</span> <span>=</span> <span>function</span> <span>(</span><span>s</span><span>)</span> <span>{</span>
  <span>const</span> arr1 <span>=</span> <span>[</span><span>]</span><span>,</span> arr2 <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>s<span>[</span>i<span>]</span><span>.</span><span>charCodeAt</span><span>(</span><span>)</span> <span>&lt;</span> <span>58</span><span>)</span> arr1<span>.</span><span>push</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span>
    <span>else</span> arr2<span>.</span><span>push</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span>
  <span>}</span>
  <span>if</span> <span>(</span>Math<span>.</span><span>abs</span><span>(</span>arr1<span>.</span>length <span>-</span> arr2<span>.</span>length<span>)</span> <span>></span> <span>1</span><span>)</span> <span>return</span> <span>""</span>
  <span>let</span> max<span>,</span> min
  <span>if</span> <span>(</span>arr1<span>.</span>length <span>></span> arr2<span>.</span>length<span>)</span> <span>{</span>
    max <span>=</span> arr1
    min <span>=</span> arr2
  <span>}</span> <span>else</span> <span>{</span>
    max <span>=</span> arr2
    min <span>=</span> arr1
  <span>}</span>
  <span>let</span> res <span>=</span> <span>""</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> max<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    res <span>+=</span> max<span>[</span>i<span>]</span>
    <span>if</span> <span>(</span>min<span>[</span>i<span>]</span><span>)</span> res <span>+=</span> min<span>[</span>i<span>]</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br></div></div><h2 id="_1422-分割字符串的最大得分"> 1422.分割字符串的最大得分</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1422 lang=javascript
 *
 * [1422] 分割字符串的最大得分
 * 
 * 给你一个由若干 0 和 1 组成的字符串 s ，请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。

「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。

 

示例 1：

输入：s = "011101"
输出：5 
解释：
将字符串 s 划分为两个非空子字符串的可行方案有：
左子字符串 = "0" 且 右子字符串 = "11101"，得分 = 1 + 4 = 5 
左子字符串 = "01" 且 右子字符串 = "1101"，得分 = 1 + 3 = 4 
左子字符串 = "011" 且 右子字符串 = "101"，得分 = 1 + 2 = 3 
左子字符串 = "0111" 且 右子字符串 = "01"，得分 = 1 + 1 = 2 
左子字符串 = "01110" 且 右子字符串 = "1"，得分 = 2 + 1 = 3
示例 2：

输入：s = "00111"
输出：5
解释：当 左子字符串 = "00" 且 右子字符串 = "111" 时，我们得到最大得分 = 2 + 3 = 5
示例 3：

输入：s = "1111"
输出：3
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {string} s
 * @return {number}
 */</span>
<span>var</span> <span>maxScore</span> <span>=</span> <span>function</span> <span>(</span><span>s</span><span>)</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> s<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> left <span>=</span> s<span>.</span><span>substring</span><span>(</span><span>0</span><span>,</span> i<span>)</span><span>.</span><span>match</span><span>(</span><span><span>/</span><span>0</span><span>/</span><span>g</span></span><span>)</span>
    <span>const</span> right <span>=</span> s<span>.</span><span>substring</span><span>(</span>i<span>,</span> s<span>.</span>length<span>)</span><span>.</span><span>match</span><span>(</span><span><span>/</span><span>1</span><span>/</span><span>g</span></span><span>)</span>
    <span>const</span> n1 <span>=</span> left <span>?</span> left<span>.</span>length <span>:</span> <span>0</span>
    <span>const</span> n2 <span>=</span> right <span>?</span> right<span>.</span>length <span>:</span> <span>0</span>
    res <span>=</span> Math<span>.</span><span>max</span><span>(</span>res<span>,</span> n1 <span>+</span> n2<span>)</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><h2 id="_1431-拥有最多糖果的孩子"> 1431.拥有最多糖果的孩子</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1431 lang=typescript
 *
 * [1431] 拥有最多糖果的孩子
 * 
 * 给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。

对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。

 

示例 1：

输入：candies = [2,3,5,1,3], extraCandies = 3
输出：[true,true,true,false,true] 
解释：
孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。
孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。
孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。
孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。
孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。
示例 2：

输入：candies = [4,2,1,1,2], extraCandies = 1
输出：[true,false,false,false,false] 
解释：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。
示例 3：

输入：candies = [12,1,12], extraCandies = 10
输出：[true,false,true]
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>kidsWithCandies</span><span>(</span>candies<span>:</span> <span>number</span><span>[</span><span>]</span><span>,</span> extraCandies<span>:</span> <span>number</span><span>)</span><span>:</span> <span>boolean</span><span>[</span><span>]</span> <span>{</span>
  <span>const</span> res <span>=</span> <span>[</span><span>]</span><span>,</span> max <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>...</span>candies<span>)</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> candies<span>.</span>length<span>;</span> i<span>++</span><span>)</span> res<span>.</span><span>push</span><span>(</span>candies<span>[</span>i<span>]</span> <span>+</span> extraCandies <span>>=</span> max<span>)</span><span>;</span>
  <span>return</span> res<span>;</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h2 id="_1436-旅行终点站"> 1436.旅行终点站</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1436 lang=typescript
 *
 * [1436] 旅行终点站
 * 
 * 给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。

题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。

 

示例 1：

输入：paths = [["London","New York"],["New York","Lima"],["Lima","Sao Paulo"]]
输出："Sao Paulo" 
解释：从 "London" 出发，最后抵达终点站 "Sao Paulo" 。本次旅行的路线是 "London" -> "New York" -> "Lima" -> "Sao Paulo" 。
示例 2：

输入：paths = [["B","C"],["D","B"],["C","A"]]
输出："A"
解释：所有可能的线路是：
"D" -> "B" -> "C" -> "A". 
"B" -> "C" -> "A". 
"C" -> "A". 
"A". 
显然，旅行终点站是 "A" 。
示例 3：

输入：paths = [["A","Z"]]
输出："Z"
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>destCity</span><span>(</span>paths<span>:</span> <span>string</span><span>[</span><span>]</span><span>[</span><span>]</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>paths<span>.</span>length <span>===</span> <span>1</span><span>)</span> <span>return</span> paths<span>[</span><span>0</span><span>]</span><span>[</span><span>1</span><span>]</span><span>;</span>
  <span>const</span> b <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>)</span><span>,</span> e <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>)</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> paths<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    b<span>.</span><span>add</span><span>(</span>paths<span>[</span>i<span>]</span><span>[</span><span>0</span><span>]</span><span>)</span>
    e<span>.</span><span>add</span><span>(</span>paths<span>[</span>i<span>]</span><span>[</span><span>1</span><span>]</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>b<span>.</span><span>has</span><span>(</span>paths<span>[</span>i<span>]</span><span>[</span><span>1</span><span>]</span><span>)</span><span>)</span> <span>{</span>
      b<span>.</span><span>delete</span><span>(</span>paths<span>[</span>i<span>]</span><span>[</span><span>1</span><span>]</span><span>)</span><span>;</span>
      e<span>.</span><span>delete</span><span>(</span>paths<span>[</span>i<span>]</span><span>[</span><span>1</span><span>]</span><span>)</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>e<span>.</span><span>has</span><span>(</span>paths<span>[</span>i<span>]</span><span>[</span><span>0</span><span>]</span><span>)</span><span>)</span> <span>{</span>
      e<span>.</span><span>delete</span><span>(</span>paths<span>[</span>i<span>]</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
      b<span>.</span><span>delete</span><span>(</span>paths<span>[</span>i<span>]</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>[</span><span>...</span>e<span>]</span><span>[</span><span>0</span><span>]</span>
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div><h2 id="_1437-是否所有-1-都至少相隔-k-个元素"> 1437.是否所有-1-都至少相隔-k-个元素</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1437 lang=typescript
 *
 * [1437] 是否所有 1 都至少相隔 k 个元素
 * 
 * 给你一个由若干 0 和 1 组成的数组 nums 以及整数 k。如果所有 1 都至少相隔 k 个元素，则返回 True ；否则，返回 False 。

 

示例 1：



输入：nums = [1,0,0,0,1,0,0,1], k = 2
输出：true
解释：每个 1 都至少相隔 2 个元素。
示例 2：



输入：nums = [1,0,0,1,0,1], k = 2
输出：false
解释：第二个 1 和第三个 1 之间只隔了 1 个元素。
示例 3：

输入：nums = [1,1,1,1,1], k = 0
输出：true
示例 4：

输入：nums = [0,1,0,1], k = 1
输出：true
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>kLengthApart</span><span>(</span>nums<span>:</span> <span>number</span><span>[</span><span>]</span><span>,</span> k<span>:</span> <span>number</span><span>)</span><span>:</span> <span>boolean</span> <span>{</span>
  <span>let</span> prev <span>=</span> <span>-</span><span>1</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>===</span> <span>1</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>prev <span>!==</span> <span>-</span><span>1</span> <span>&amp;&amp;</span> i <span>-</span> prev <span>-</span> <span>1</span> <span>&lt;</span> k<span>)</span> <span>return</span> <span>false</span><span>;</span>
      prev <span>=</span> i<span>;</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>true</span><span>;</span>
<span>}</span>
<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><h2 id="_1446-连续字符"> 1446.连续字符</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1446 lang=typescript
 *
 * [1446] 连续字符
 * 
 * 给你一个字符串 s ，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。

请你返回字符串 s 的 能量。

 

示例 1：

输入：s = "leetcode"
输出：2
解释：子字符串 "ee" 长度为 2 ，只包含字符 'e' 。
示例 2：

输入：s = "abbcccddddeeeeedcba"
输出：5
解释：子字符串 "eeeee" 长度为 5 ，只包含字符 'e' 。
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>maxPower</span><span>(</span>s<span>:</span> <span>string</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>let</span> max <span>=</span> <span>1</span><span>,</span>
    curr <span>=</span> s<span>[</span><span>0</span><span>]</span><span>,</span>
    len <span>=</span> <span>1</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> s<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>s<span>[</span>i<span>]</span> <span>===</span> curr<span>)</span> <span>{</span>
      len<span>++</span><span>;</span>
      <span>if</span> <span>(</span>i <span>===</span> s<span>.</span>length <span>-</span> <span>1</span><span>)</span> <span>{</span>
        max <span>=</span> Math<span>.</span><span>max</span><span>(</span>max<span>,</span> len<span>)</span><span>;</span>
      <span>}</span>
      <span>continue</span><span>;</span>
    <span>}</span>
    curr <span>=</span> s<span>[</span>i<span>]</span><span>;</span>
    max <span>=</span> Math<span>.</span><span>max</span><span>(</span>max<span>,</span> len<span>)</span><span>;</span>
    len <span>=</span> <span>1</span><span>;</span>
  <span>}</span>
  <span>return</span> max<span>;</span>
<span>}</span>
<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><h2 id="_1450-在既定时间做作业的学生人数"> 1450.在既定时间做作业的学生人数</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1450 lang=typescript
 *
 * [1450] 在既定时间做作业的学生人数
 * 
 * 给你两个整数数组 startTime（开始时间）和 endTime（结束时间），并指定一个整数 queryTime 作为查询时间。

已知，第 i 名学生在 startTime[i] 时开始写作业并于 endTime[i] 时完成作业。

请返回在查询时间 queryTime 时正在做作业的学生人数。形式上，返回能够使 queryTime 处于区间 [startTime[i], endTime[i]]（含）的学生人数。

 

示例 1：

输入：startTime = [1,2,3], endTime = [3,2,7], queryTime = 4
输出：1
解释：一共有 3 名学生。
第一名学生在时间 1 开始写作业，并于时间 3 完成作业，在时间 4 没有处于做作业的状态。
第二名学生在时间 2 开始写作业，并于时间 2 完成作业，在时间 4 没有处于做作业的状态。
第三名学生在时间 3 开始写作业，预计于时间 7 完成作业，这是是唯一一名在时间 4 时正在做作业的学生。
示例 2：

输入：startTime = [4], endTime = [4], queryTime = 4
输出：1
解释：在查询时间只有一名学生在做作业。
示例 3：

输入：startTime = [4], endTime = [4], queryTime = 5
输出：0
示例 4：

输入：startTime = [1,1,1,1], endTime = [1,3,2,4], queryTime = 7
输出：0
示例 5：

输入：startTime = [9,8,7,6,5,4,3,2,1], endTime = [10,10,10,10,10,10,10,10,10], queryTime = 5
输出：5
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>busyStudent</span><span>(</span>
  startTime<span>:</span> <span>number</span><span>[</span><span>]</span><span>,</span>
  endTime<span>:</span> <span>number</span><span>[</span><span>]</span><span>,</span>
  queryTime<span>:</span> <span>number</span>
<span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>0</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> startTime<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>startTime<span>[</span>i<span>]</span> <span>&lt;=</span> queryTime <span>&amp;&amp;</span> endTime<span>[</span>i<span>]</span> <span>>=</span> queryTime<span>)</span> res<span>++</span><span>;</span>
  <span>}</span>
  <span>return</span> res<span>;</span>
<span>}</span>
<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><h2 id="_1455-检查单词是否为句中其他单词的前缀"> 1455.检查单词是否为句中其他单词的前缀</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1455 lang=typescript
 *
 * [1455] 检查单词是否为句中其他单词的前缀
 * 
 * 给你一个字符串 sentence 作为句子并指定检索词为 searchWord ，其中句子由若干用 单个空格 分隔的单词组成。请你检查检索词 searchWord 是否为句子 sentence 中任意单词的前缀。

如果 searchWord 是某一个单词的前缀，则返回句子 sentence 中该单词所对应的下标（下标从 1 开始）。如果 searchWord 是多个单词的前缀，则返回匹配的第一个单词的下标（最小下标）。如果 searchWord 不是任何单词的前缀，则返回 -1 。

字符串 s 的 前缀 是 s 的任何前导连续子字符串。

 

示例 1：

输入：sentence = "i love eating burger", searchWord = "burg"
输出：4
解释："burg" 是 "burger" 的前缀，而 "burger" 是句子中第 4 个单词。
示例 2：

输入：sentence = "this problem is an easy problem", searchWord = "pro"
输出：2
解释："pro" 是 "problem" 的前缀，而 "problem" 是句子中第 2 个也是第 6 个单词，但是应该返回最小下标 2 。
示例 3：

输入：sentence = "i am tired", searchWord = "you"
输出：-1
解释："you" 不是句子中任何单词的前缀。
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>isPrefixOfWord</span><span>(</span>sentence<span>:</span> <span>string</span><span>,</span> searchWord<span>:</span> <span>string</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>const</span> arr <span>=</span> sentence<span>.</span><span>split</span><span>(</span><span>" "</span><span>)</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>arr<span>[</span>i<span>]</span><span>.</span><span>indexOf</span><span>(</span>searchWord<span>)</span> <span>===</span> <span>0</span><span>)</span> <span>return</span> i <span>+</span> <span>1</span><span>;</span>
  <span>}</span>
  <span>return</span> <span>-</span><span>1</span><span>;</span>
<span>}</span>
<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id="_1460-通过翻转子数组使两个数组相等"> 1460.通过翻转子数组使两个数组相等</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1460 lang=typescript
 *
 * [1460] 通过翻转子数组使两个数组相等
 * 
 * 给你两个长度相同的整数数组 target 和 arr 。每一步中，你可以选择 arr 的任意 非空子数组 并将它翻转。你可以执行此过程任意次。

如果你能让 arr 变得与 target 相同，返回 True；否则，返回 False 。

 

示例 1：

输入：target = [1,2,3,4], arr = [2,4,1,3]
输出：true
解释：你可以按照如下步骤使 arr 变成 target：
1- 翻转子数组 [2,4,1] ，arr 变成 [1,4,2,3]
2- 翻转子数组 [4,2] ，arr 变成 [1,2,4,3]
3- 翻转子数组 [4,3] ，arr 变成 [1,2,3,4]
上述方法并不是唯一的，还存在多种将 arr 变成 target 的方法。
示例 2：

输入：target = [7], arr = [7]
输出：true
解释：arr 不需要做任何翻转已经与 target 相等。
示例 3：

输入：target = [3,7,9], arr = [3,7,11]
输出：false
解释：arr 没有数字 9 ，所以无论如何也无法变成 target 。
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>canBeEqual</span><span>(</span>target<span>:</span> <span>number</span><span>[</span><span>]</span><span>,</span> arr<span>:</span> <span>number</span><span>[</span><span>]</span><span>)</span><span>:</span> <span>boolean</span> <span>{</span>
  <span>return</span> target<span>.</span><span>sort</span><span>(</span><span>(</span>a<span>,</span> b<span>)</span> <span>=></span> a <span>-</span> b<span>)</span><span>.</span><span>join</span><span>(</span><span>""</span><span>)</span> <span>===</span> arr<span>.</span><span>sort</span><span>(</span><span>(</span>a<span>,</span> b<span>)</span> <span>=></span> a <span>-</span> b<span>)</span><span>.</span><span>join</span><span>(</span><span>""</span><span>)</span><span>;</span>
<span>}</span>
<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><h2 id="_1464-数组中两元素的最大乘积"> 1464.数组中两元素的最大乘积</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1464 lang=typescript
 *
 * [1464] 数组中两元素的最大乘积
 * 
 * 给你一个整数数组 nums，请你选择数组的两个不同下标 i 和 j，使 (nums[i]-1)*(nums[j]-1) 取得最大值。

请你计算并返回该式的最大值。

 

示例 1：

输入：nums = [3,4,5,2]
输出：12 
解释：如果选择下标 i=1 和 j=2（下标从 0 开始），则可以获得最大值，(nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12 。 
示例 2：

输入：nums = [1,5,4,5]
输出：16
解释：选择下标 i=1 和 j=3（下标从 0 开始），则可以获得最大值 (5-1)*(5-1) = 16 。
示例 3：

输入：nums = [3,7]
输出：12
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>maxProduct</span><span>(</span>nums<span>:</span> <span>number</span><span>[</span><span>]</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
  <span>const</span> <span>[</span>i<span>,</span> j<span>]</span> <span>=</span> nums<span>.</span><span>sort</span><span>(</span><span>(</span>a<span>,</span> b<span>)</span> <span>=></span> b <span>-</span> a<span>)</span><span>;</span>
  <span>return</span> <span>(</span>i <span>-</span> <span>1</span><span>)</span> <span>*</span> <span>(</span>j <span>-</span> <span>1</span><span>)</span><span>;</span>
<span>}</span>
<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><h2 id="_1470-重新排列数组"> 1470.重新排列数组</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1470 lang=typescript
 *
 * [1470] 重新排列数组
 * 
 * 给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,...,xn,y1,y2,...,yn] 的格式排列。

请你将数组按 [x1,y1,x2,y2,...,xn,yn] 格式重新排列，返回重排后的数组。

 

示例 1：

输入：nums = [2,5,1,3,4,7], n = 3
输出：[2,3,5,4,1,7] 
解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7]
示例 2：

输入：nums = [1,2,3,4,4,3,2,1], n = 4
输出：[1,4,2,3,3,2,4,1]
示例 3：

输入：nums = [1,1,2,2], n = 2
输出：[1,2,1,2]
 
 */</span>

<span>// @lc code=start</span>
<span>function</span> <span>shuffle</span><span>(</span>nums<span>:</span> <span>number</span><span>[</span><span>]</span><span>,</span> n<span>:</span> <span>number</span><span>)</span><span>:</span> <span>number</span><span>[</span><span>]</span> <span>{</span>
  <span>const</span> res<span>:</span> <span>number</span><span>[</span><span>]</span> <span>=</span> <span>[</span><span>]</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> res<span>.</span><span>push</span><span>(</span>nums<span>[</span>i<span>]</span><span>,</span> nums<span>[</span>i <span>+</span> n<span>]</span><span>)</span><span>;</span>
  <span>return</span> res<span>;</span>
<span>}</span>
<span>// @lc code=end</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><h2 id="_1822-数组元素积的符号"> 1822.数组元素积的符号</h2>
<div><pre><code><span>/*
 * @lc app=leetcode.cn id=1822 lang=javascript
 *
 * [1822] 数组元素积的符号
 * 
 * 已知函数 signFunc(x) 将会根据 x 的正负返回特定值：

如果 x 是正数，返回 1 。
如果 x 是负数，返回 -1 。
如果 x 是等于 0 ，返回 0 。
给你一个整数数组 nums 。令 product 为数组 nums 中所有元素值的乘积。

返回 signFunc(product) 。

 

示例 1：

输入：nums = [-1,-2,-3,-4,3,2,1]
输出：1
解释：数组中所有值的乘积是 144 ，且 signFunc(144) = 1
示例 2：

输入：nums = [1,5,0,2,-3]
输出：0
解释：数组中所有值的乘积是 0 ，且 signFunc(0) = 0
示例 3：

输入：nums = [-1,1,-1,1,-1]
输出：-1
解释：数组中所有值的乘积是 -1 ，且 signFunc(-1) = -1
 
 */</span>

<span>// @lc code=start</span>
<span>/**
 * @param {number[]} nums
 * @return {number}
 */</span>
<span>var</span> <span>arraySign</span> <span>=</span> <span>function</span> <span>(</span><span>nums</span><span>)</span> <span>{</span>
  <span>let</span> res <span>=</span> <span>1</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>&lt;</span> <span>0</span><span>)</span> res <span>=</span> res <span>*</span> <span>-</span><span>1</span>
    <span>else</span> <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>===</span> <span>0</span><span>)</span> <span>return</span> <span>0</span>
  <span>}</span>
  <span>return</span> res
<span>}</span><span>;</span>
<span>// @lc code=end</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div>]]></content>
    <author>
      <name>xiechengyu</name>
    </author>
    <category term="学习"/>
    <contributor>
      <name>xiechengyu</name>
    </contributor>
    <published>2022-06-19T16:56:31.000Z</published>
    <rights>Copyright by xiechengyu</rights>
  </entry>
</feed>